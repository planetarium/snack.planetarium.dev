<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><title/><link rel="self" href="https://snack.planetarium.dev/kor/index.xml"/><link rel="alternate" href="https://snack.planetarium.dev/kor/" title=""/><link rel="alternate" href="https://snack.planetarium.dev/eng/" hreflang="en" title=""/><updated>2025-03-20T00:00:00+00:00</updated><id>https://snack.planetarium.dev/kor/</id><entry><title>라이브 게임 에셋 관리 개선기 - 3.DLC를 통한 에셋 패치 시스템</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2025/03/asset-load-3/" title="라이브 게임 에셋 관리 개선기 - 3.DLC를 통한 에셋 패치 시스템"/><id>https://snack.planetarium.dev/kor/2025/03/asset-load-3/</id><published>2025-03-20T00:00:00+00:00</published><updated>2025-03-20T00:00:00+00:00</updated><content type="html">&lt;h1 id="인트로">인트로&lt;/h1>
&lt;hr>
&lt;p>지금까지 클라이언트 단에서 사용하는 에셋들을 최적화하고 관리하는 방법들에 대해 알아보았다. 이제는 클라이언트만의 영역을 넘어 외부 서버에서 게임 에셋을 다운로드 하여 사용하는 패치 시스템에 대한 내용을 정리해 볼 것이다. 이번 편에서는 어드레서블 에셋과 AWS를 이용한 게임의 에셋 패치 시스템에 대한 내용을 다룬다. 관련 내용은 이전 글에서도 설명하였으니 이 글을 보기 전에 같이 보고오면 좋을 것이다.&lt;/p>
&lt;p>&lt;a href="https://velog.io/@eugene-doobu/%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EA%B2%8C%EC%9E%84-%EC%97%90%EC%85%8B-%EA%B4%80%EB%A6%AC-%EA%B0%9C%EC%84%A0%EA%B8%B0-1.%EC%96%B4%EB%93%9C%EB%A0%88%EC%84%9C%EB%B8%94-%EC%97%90%EC%85%8B-%EB%8F%84%EC%9E%85">라이브-게임-에셋-관리-개선기-1.어드레서블-에셋-도입&lt;/a>&lt;/p>
&lt;p>1부. 어드레서블 에셋 도입&lt;br>
2부. 메모리 사용 구조 개선 / 리소스 최적화&lt;br>
번외1. 리소스 최적화 기법&lt;br>
&lt;strong>3부. DLC를 통한 패치 시스템&lt;/strong> &amp;lt;- 현재 글&lt;/p>
&lt;h1 id="에셋-패치-시스템이-필요한-이유">에셋 패치 시스템이 필요한 이유&lt;/h1>
&lt;hr>
&lt;p>DLC를 통한 패치 시스템이 모바일 프로젝트의 에셋 관리에서 가장 핵심적인 부분이 될 가능성이 높다. 이미 패치 시스템이 도입된 다른 게임들을 예시로 그 이유를 알아보자.&lt;/p>
&lt;h3 id="1-에셋-메타데이터">1. 에셋 메타데이터&lt;/h3>
&lt;p>&lt;img alt="번들 구조" src="https://velog.velcdn.com/images/eugene-doobu/post/a7a9a353-b1e9-4fc7-993d-dc2d09a84320/image.png">&lt;/p>
&lt;p>&lt;em>&amp;ldquo;출처: UniteSeoul2018 - 에셋번들 실전 가이드 (AssetBundle Best Practices)&amp;rdquo;&lt;/em>&lt;/p>
&lt;p>기존의 방식대로 프로젝트 빌드에 모든 에셋을 포함시키면 일어나는 문제 중 하나가 &lt;code>Lookup Table&lt;/code>과 프로젝트 로드에 필요한 &lt;code>에셋 메타데이터&lt;/code>의 크기가 비대해진다는 것이다. 관련 데이터 파일들은 생각보다 무겁고, Lookup Table은 트리 구조(플랫폼에 따라 RB트리, BST)로 되어있는데 모든 에셋을 로드하기 위해 &lt;code>nlogn&lt;/code>의 복잡도를 가지기 때문에 이를 로드하기 위한 시간이 생각보다 오래 걸릴 수 있다. 이 작업은 특히 디바이스의 사양이 낮은 모바일에 치명적으로 작용할 수 있다.&lt;/p>
&lt;p>이를 에셋번들로 분리함으로써 번들마다 별도의 테이블을 갖게 만들고, 필요한 순간 비동기적으로 로드해서 사용하게 한다면 앱 실행시 에셋을 로드하는 부담을 크게 줄일 수 있게 된다.&lt;/p>
&lt;h3 id="2-패치시스템--앱-용량-줄이기">2. 패치시스템 + 앱 용량 줄이기&lt;/h3>
&lt;p>&lt;img alt="프커업뎃" src="https://velog.velcdn.com/images/eugene-doobu/post/16e88043-d629-48ed-b874-806831075476/image.png">&lt;/p>
&lt;p>&lt;em>&amp;ldquo;게임 프린세스 커넥트! Re:Dive 추가 다운로드 팝업&amp;rdquo;&lt;/em>&lt;/p>
&lt;p>위 게임은 내가 몰래 숨어서 플레이하고 있는 미소녀 수집형 게임인 &amp;lsquo;프리코네&amp;rsquo;의 업데이트 팝업이다. 2024년 4월 18일 기준, iOS 앱스토어에 업로드 된 이 게임의 기본 크기는 &lt;strong>290.1MB&lt;/strong> 이정도는 &amp;lsquo;일반적인 서비스 어플&amp;rsquo;들보다 약간 큰 정도이다. 하지만 게임을 실제로 플레이하기 위해서는 추가적으로 10.73GB의 데이터를 다운로드 받아야 한다.&lt;/p>
&lt;p>이처럼 대부분의 모바일 게임들은 실제 앱스토어에는 앱을 구동시키기 위한 코드와 최소한의 에셋들만 포함되어있는 빌드파일을 올려놓고, 대부분의 핵심 에셋들은 별도로 다운받는 구조로 제작되어 있다. 위에 예시로 든 프리코네의 경우, 신규 캐릭터 획득시마다 그 캐릭터와 관련된 리소스나 게임 스토리를 보기 위한 리소스도 필요시마다 추가로 다운로드 하고 있어 실제로 게임 플레이를 하면서 다운받는 리소스의 양은 훨씬 많아질 수 있다.&lt;/p>
&lt;p>이렇게 외부에서 리소스를 다운 받는 이유는 다음과 같다.&lt;/p>
&lt;ol>
&lt;li>앱 스토어에서 보이는 앱 용량이 진입장벽으로 느껴질 수 있다.&lt;/li>
&lt;li>안드로이드는 apk로 앱을 업로드 시 150MB 이하로 유지해야 하는 전통이 있었다.&lt;/li>
&lt;li>그리고 패치 시스템을 이용하면 &lt;strong>번거로운 앱 심사 과정을 회피하고 업데이트&lt;/strong>를 할 수 있다&lt;/li>
&lt;/ol>
&lt;p>사실 개인적인 입장에서는 3번이 핵심이라고 생각한다. 게임개발을 하다 보면 추가로 빌드 과정을 진행하는 것도 엄청난 일이며 이를 앱스토어에 심사받고 정해진 기간까지 심사가 통과할지 기도하는 일도 회사 팀원들의 마음을 힘들게 한다. 이 과정은 많은 시간과 정성이 필요하며, 때로는 예상치 못한 심사 지연이나 거절 사유를 해결하기 위해 추가적인 노력(과 야근)이 필요할 수 있다.&lt;/p>
&lt;h3 id="앱-패치-심사">앱 패치 심사&lt;/h3>
&lt;pre tabindex="0">&lt;code>애플의 앱스토어 심사는 구글 마켓에 비해
까다롭고 오래 걸리는 것으로 유명합니다.
몇 시간 정도 걸리는 안드로이드 심사와 달리
애플 앱 심사는 약 일주일 정도 걸리는데요.
일주일을 기다린 앱 심사 결과가
거부(reject)면 재심사까지 더해 약 2주일,
한번 더 reject되면 3주까지 늘어나기도 하죠.
그렇기에 앱스토어 심사를 가장 빨리 통과하는
방법은 거부(reject)당하지 않는 거죠.
- 디스이즈게임, [카드뉴스] 거부를 거부한다! 앱스토어 심사에서 리젝당하지 않는 법
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.thisisgame.com/webzine/nboard/257/?n=61254?n">https://www.thisisgame.com/webzine/nboard/257/?n=61254?n&lt;/a>&lt;/p>
&lt;p>모바일게임을 만들고 앱 마켓에 등록하기 위해서는 필수적으로 심사 과정을 거쳐야 한다. 앱 심사는 대부분 첫 심사가 매우 까다롭고 이후 심사는 상대적으로 너그럽게 진행되는 편인 것 같다. 하지만 첫 심사가 아니라고 방심하면은 안 된다. 앱 심사 거절은 언제 어디서 일어날지 모른다.&lt;/p>
&lt;p>만약 코드 수정이 아닌 단순 리소스 수정이라면, 위와 같은 패치 시스템을 이용해서 앱 심사를 우회하고 바로 유저들에게 콘텐츠 업데이트를 할 수 있다. 한번 DLC 업데이트에 익숙해지고 나면, 단순 리소스 수정 같은 일로 하루 이상의 딜레이를 가질 수 있는 앱 심사 과정을 거쳐야 하는 것이 매우 번거로운 일로 느껴질 수 있을 것이다.&lt;/p>
&lt;h1 id="적용사례">적용사례&lt;/h1>
&lt;hr>
&lt;p>에셋을 패치 하려면 유저들이 앱 실행 중 항상 접근할 수 있는 웹 서버에 사용할 에셋들을 업로드해야 한다. 나는 회사에서 사용 중인 AWS S3 버킷에 에셋을 업로드하고 게임에서 이를 로드해서 사용해보는 테스트를 하였다.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/6qXSP9vJ06s?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div>
&lt;p>(위 영상에서 &amp;lsquo;바로 로드 안됨&amp;rsquo;이라고 나오는 부분의 문제는 해결했는데, 어이없게도 에셋 로드를 하고 로드가 완료되는 걸 기다리지 않고 오브젝트를 생성하고 있었다.)&lt;/p>
&lt;p>위 어드레서블의 장점에서 &amp;lsquo;Remote&amp;rsquo;로 에셋을 저장해주는 세팅을 하면 에셋이 원격 저장소에 저장된다고 말했다. 위 영상이 바로 &lt;strong>ActorPrefab&lt;/strong> 그룹을 Remote에 저장되도록 세팅하고 그 에셋들을 S3 원격 저장소에 올려서 사용하는 영상이다. 영상을 보면 알 수 있듯이, 어드레서블에서 제공해주는 기능만을 이용하면 프로젝트의 외딴곳에 에셋이 빌드되고 이를 수동으로 손으로 옮겨서 S3 버킷에 업로드해주는걸 볼 수 있을 것이다.&lt;/p>
&lt;p>또한 현재 클라이언트에 있는 에셋이 최신 에셋인지 파악하기 위해 해시 값들을 관리해야 하고, 이러한 해시 값을 관리해주는 카탈로그 개념에 대해 인지하고 있어야 한다. 이에 대한 경험과 자세한 설명들은 추후 DLC를 통한 패치 시스템에 대한 글을 쓸 때 다뤄보려고 했으나..&lt;/p>
&lt;h2 id="적용-중단">적용 중단&lt;/h2>
&lt;p>다양한 이유로 해당 작업이 중단되었다. 내부 판단으로 굳이 패치시스템까지 적용할 필요가 없다는 결론이 났다. 해당 작업을 위해 리서치한 내용들이 있었는데 이 내용들은 다음 기회에 따로 다뤄보도록 하겠다.&lt;/p>
&lt;ul>
&lt;li>S3에서 에셋 관리 전략&lt;/li>
&lt;li>프로젝트에서의 에셋 관리 전략&lt;/li>
&lt;li>에셋 그룹화 및 번들 패킹 전략&lt;/li>
&lt;li>CloudFront와 캐시무효화&lt;/li>
&lt;/ul>
&lt;h1 id="끝">끝&lt;/h1>
&lt;hr>
&lt;p>드디어 첫 글을 작성한 2024년 7월부터 2025년 3월까지, 긴 시간동안 나태함에 빠져 빠르게 진행하지 못했던 라이브 게임 에셋 관리 개선기에 대한 글 시리즈 작성을 마무리 하였다. 결국 첫 글에서 약속했던 패치시스템을 적용하는 모습은 보여주진 못했지만 지금도 다양한 일을 진행하고 있다. 다음에 재미있는 주제로 새로운 시리즈를 연재할 수 있게 다양한 시도를 하면서 개발자 생활을 이어나가야겠다.&lt;/p>
&lt;p>&lt;img alt="끝" src="https://velog.velcdn.com/images/eugene-doobu/post/90050fa4-f365-4df1-892d-c069ea731f08/image.png">&lt;/p></content><author><name>홍유진</name><uri>https://github.com/eugene-doobu</uri><email>eugene@planetariumhq.com</email></author></entry><entry><title>라이브 게임 에셋 관리 개선기 - 번외1.리소스 최적화 기법</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2025/02/asset-load-extra1/" title="라이브 게임 에셋 관리 개선기 - 번외1.리소스 최적화 기법"/><id>https://snack.planetarium.dev/kor/2025/02/asset-load-extra1/</id><published>2025-02-11T00:00:00+00:00</published><updated>2025-02-11T00:00:00+00:00</updated><content type="html">&lt;p>이번 글은 이전 글에서 이야기한 최적화 기법의 세부 내용을 다루는 글입니다. 이 글을 읽기 전에 이전 글을 읽어보는 걸 추천합니다.&lt;/p>
&lt;p>&lt;a href="https://velog.io/@eugene-doobu/%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EA%B2%8C%EC%9E%84-%EC%97%90%EC%85%8B-%EA%B4%80%EB%A6%AC-%EA%B0%9C%EC%84%A0%EA%B8%B0-2.%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9-%EC%A0%88%EA%B0%90%EB%82%98%EC%9D%B8%ED%81%AC%EB%A1%9C%EB%8B%88%ED%81%B4">라이브 게임 에셋 관리 개선기 - 2.메모리 사용 절감
&lt;/a>&lt;/p>
&lt;p>1부. 어드레서블 에셋 도입 &lt;br>
2부. 메모리 사용 구조 개선 / 리소스 최적화 &amp;lt;- 현재 글 &lt;br>
&lt;strong>번외1. 리소스 최적화 기법&lt;/strong> &lt;br>
3부. DLC를 통한 패치 시스템&lt;/p>
&lt;h1 id="인트로">인트로&lt;/h1>
&lt;hr>
&lt;p>이전 글에서 게임의 용량과 메모리에 대한 내용에 대해 이야기 하고 게임 리소스를 최적화하여 앱스토어에 올라가는 앱의 용량과 게임의 메모리 사용량을 줄이는 작업을 해 보았다. 이번 글에서는 이전 글에서 간단하게 설명만 하고 지나간 리소스 최적화에 사용한 설정에 관한 내용을 정리해 보려고 한다.&lt;/p>
&lt;p>이번 번외편에서는 이전에 다룬 텍스처 압축, 텍스처 패킹과 스프라이트 아틀라스, 그리고 오디오 압축 등 주요 리소스 최적화 기법에 대해 간단히 정리해보고자 한다. 단순 나열식에 가까운 글이 될 것 같아 &lt;code>어떤 방식들이 있구나&lt;/code> 하는 정도로 가볍게 훑어 보는걸 추천한다.&lt;/p>
&lt;h1 id="0-다시-한번-나인크로니클">0. 다시 한번 나인크로니클&lt;/h1>
&lt;hr>
&lt;p>&lt;img alt="플레이화면" src="https://velog.velcdn.com/images/eugene-doobu/post/bcf8edab-ac8b-4dc9-b6e3-f837c17a49a4/image.png">&lt;/p>
&lt;p>게임 최적화를 하기 이전에 게임이 어떤 특징을 가지고 있는지 알아야 한다. 특히 어떤 디바이스를 사용하느냐에 따라 사용되는 옵션과 전략이 크게 달라질 수 있다. 먼저 &lt;a href="https://github.com/planetarium/NineChronicles">나인크로니클&lt;/a>(9C)은 풀 블록체인 기반의 2D RPG게임이며 &lt;strong>모바일-PC 크로스 플랫폼&lt;/strong>을 지원한다. 블록체인 게임이라는 굉장히 특별한 특징이지만, 리소스 최적화와는 크게 연관은 없는 내용이라 &lt;code>2D&lt;/code>와 &lt;code>모바일-PC 크로스 플랫폼&lt;/code>이라는 점이 핵심이 된다.&lt;/p>
&lt;h3 id="2d-게임에서의-최적화">2D 게임에서의 최적화&lt;/h3>
&lt;p>2D 게임의 경우 확실히 3D게임 보다는 최적화 부담이 덜하긴 하지만, 텍스처가 많아지고 이에 대한 관리를 소홀히 하면 큰 문제가 생길 수도 있다. 특히 여러 스프라이트를 겹쳐서 사용하는 경우가 많은데, 이러한 경우 렌더러가 한 픽셀을 여러번 렌더하는 &lt;strong>OverDraw현상이 발생&lt;/strong>하여 불필요한 연산이 많아질 수 있다.&lt;/p>
&lt;p>&lt;img alt="OverDraw" src="https://velog.velcdn.com/images/eugene-doobu/post/7e3792c4-00c6-4416-8b9a-0dc1d20286a3/image.png">&lt;/p>
&lt;p>위 스크린샷은 9c 메인 화면에서 &lt;code>OverDraw&lt;/code>옵션을 활성화 시킨 모습이다. 화면의 대부분이 흰색으로 보이는데, 이는 씬에서 사용하는 파티클이 중첩되어 렌더링되어 나타난 현상으로 보인다. 좌상단에 있는 퀘스트 UI를 아래 OverDraw를 비활성화 시킨 UI랑 비교해보면, 던전 아이콘(마름모 모양)이 사각형 형태로 오버드로우 되고 있음을 알 수 있다.&lt;/p>
&lt;p>&lt;img alt="퀘스트 UI" src="https://velog.velcdn.com/images/eugene-doobu/post/13402bbc-b3a2-4bb7-81fe-83e9d50bfd42/image.png">&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>OverDraw:&lt;/strong> 게임 오브젝트를 투명한 “실루엣”으로 렌더링합니다. 투명한 컬러가 중첩되면 한 오브젝트 위에 다른 오브젝트가 그려진 곳을 쉽게 파악할 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="pc-모바일-게임에서의-최적화">PC-모바일 게임에서의 최적화&lt;/h3>
&lt;p>크로스 플랫폼의 경우 일반적으로 PC의 성능이 모바일보다 압도적으로 좋기 때문에, 모바일을 대상으로 최적화한다면 PC 도 자연스럽게 최적화가 될 것으로 생각한다. 따라서 저번 글에서도 오로지 모바일 스토어 상에서의 빌드 용량과 메모리 사용량을 비교를 하였다.&lt;/p>
&lt;p>모바일 게임 최적화는 옛날부터 핫한 주제였기에 다양한 글들이 있다. 이에 대한 관심이 있다면 유니티 블로그에 작성된 아래 글을 읽어 보는 것을 추천한다.&lt;/p>
&lt;p>&lt;a href="https://unity.com/kr/blog/games/optimize-your-mobile-game-performance-expert-tips-on-graphics-and-assets">모바일 게임 성능 최적화: 그래픽과 에셋에 관한 전문가 팁&lt;/a>&lt;/p>
&lt;h1 id="1-스프라이트-아틀라스">1. 스프라이트 아틀라스&lt;/h1>
&lt;hr>
&lt;p>&lt;img alt="Atlas" src="https://velog.velcdn.com/images/eugene-doobu/post/f74ac31a-012f-412d-ba47-0d6bd81eb2c5/image.png">&lt;/p>
&lt;p>스프라이트 아틀라스는 게임에서 사용하는 스프라이트 텍스처들을 위 스크린샷과 같이 하나로 묶어 하나의 텍스처처럼 사용하는 것이다. 게임에서 사용하는 자잘한 텍스처들이 많을수록 최적화를 위해 스프라이트 아틀라스를 적용하는게 좋다.&lt;/p>
&lt;p>&lt;img alt="Batches" src="https://velog.velcdn.com/images/eugene-doobu/post/ea15b26a-0ffd-49c5-98a3-0a19a923d42b/image.png">&lt;/p>
&lt;p>&lt;strong>1. 드로우콜 줄이기&lt;/strong>&lt;/p>
&lt;p>CPU가 GPU에게 일을 시키기 위해서는 어떤걸 그려야 한다고 명령을 호출해야 하는데, 이를 &lt;code>드로우콜(DrawCall)&lt;/code> 이라고 한다. GPU는 연산이 빠르지만, CPU와 데이터를 주고 받는 시간은 느리기 때문에 GPU를 최대한으로 활용하기 위해서는 이 드로우콜 횟수를 줄여야 한다. 유니티에서는 &lt;strong>동일한 메터리얼을 사용하는 오브젝트들을 묶어 1개의 드로우콜로 묶어서 보내주는&lt;/strong> &lt;code>배칭(Batching)기능&lt;/code>이 있다. 2D Sprite도 배칭이 가능하며 텍스처 아틀라스와 같은 기법을 활용하여 스프라이트들을 하나의 이미지에 모아 GPU로 보내줄 수 있는 것이다. 배치의 수는 유니티의 Statisics에서 쉽게 확인할 수 있다.&lt;/p>
&lt;p>&lt;strong>2.텍스처 압축 포멧의 POT(Power of two)&lt;/strong>&lt;/p>
&lt;p>텍스처 압축 포맷중 압축을 하기 위한 조건이 POT(Power of two)인 경우가 있다. 해당 조건이 있는 포맷의 경우 텍스처 이미지의 사이드가 2의 승수가 아닌 경우 텍스처 압축이 불가능 하다. UI에 사용하는 아이콘들은 이러한 조건을 갖추기 어렵기 때문에, 이러한 텍스처들을 모아 2의 승수의 크기로 아틀라스를 뽑아주면 텍스처 압축이 가능해진다. 텍스처 압축에 대한 내용은 뒤에서 자세하게 다루도록 하겠다.&lt;/p>
&lt;h3 id="아틀라스-이중압축">아틀라스 이중압축&lt;/h3>
&lt;p>&lt;img alt="아틀라스 이중 압축" src="https://velog.velcdn.com/images/eugene-doobu/post/3570d562-9a88-4368-b54e-0e928d66e428/image.png">&lt;/p>
&lt;p>(사진 출처: &lt;a href="https://discussions.unity.com/t/do-sprite-atlases-double-compress-sprites/228209">unity discussions&lt;/a>)&lt;/p>
&lt;p>텍스처 압축은 텍스처의 품질을 변경시키는데, 아틀라스에서 가져오는 텍스처들은 압축이 되어있는지 안되어있는지 체크되지 않는다. 위 스크린샷을 보면, 압축되지 않은(RGBA 32 bit)포맷 으로 설정하고 압축된 텍스처와 압축되지 않은 텍스처를 가져오는 경우 &lt;strong>압축된 텍스처가 품질이 저하된 그대로 아틀라스에 들어오는 것을 확인&lt;/strong>할 수 있다. 따라서 스프라이트 아틀라스를 사용하는 경우, 아틀라스에 포함될 텍스처들은 압축이 되지 않도록 잘 분리를 해주어야 좋다.&lt;/p>
&lt;p>(텍스처 압축 포맷은 결국 랜덤 액세스가 가능하게 포맷당 정해진 비트를 사용하므로 이중 압축이 되어도 성능적으로 이득을 보는 건 없다)&lt;/p>
&lt;h1 id="2-텍스처-압축">2. 텍스처 압축&lt;/h1>
&lt;hr>
&lt;p>iOS: &lt;code>625MB&lt;/code> -&amp;gt; &lt;code>460MB&lt;/code> (앱 스토어 커넥트에서 &lt;code>압축 파일 크기&lt;/code>)
Android: &lt;code>648MB&lt;/code> -&amp;gt; &lt;code>478MB&lt;/code> (구글 플레이 콘솔에서 &lt;code>원본 파일&lt;/code>)&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/4419">텍스처 패킹에 대한 PR&lt;/a>&lt;/p>
&lt;p>이전 글에서 텍스처 압축을 통해 앱스토어의 용량을 약 26%씩 줄인 결과를 보여주었다. 실제로는 이 작업이 머지되면서 대형 컨텐츠들이 업데이트 되었고, 텍스처 압축 전 빌드 용량은 이 컨텐츠 리소스들이 포함되지 않은 상태였기에 실제로는 26% 이상의 용량이 절약되었을 것이다.&lt;/p>
&lt;p>&lt;img alt="용량의 차이" src="https://velog.velcdn.com/images/eugene-doobu/post/86efd201-4480-4df8-b2bb-d83940a3b1b0/image.png">&lt;/p>
&lt;p>이처럼 2D 프로젝트에서 텍스처 압축은 엄청난 힘을 보여준다. 이번 챕터에서는 유니티에서 사용할 수 있는 텍스처 압축 옵션들은 어떤 것들이 있고 프로젝트에 어떻게 적용하였는지에 대해 설명해보고자 한다.&lt;/p>
&lt;h3 id="텍스쳐-파일-포맷">텍스쳐 파일 포맷&lt;/h3>
&lt;p>&lt;img alt="파일 포멧" src="https://velog.velcdn.com/images/eugene-doobu/post/247b5455-9714-402f-8ad8-a4dc92764bad/image.png">&lt;/p>
&lt;p>&lt;em>(사진 출처: 유니티 코리아 유튜브)&lt;/em>&lt;/p>
&lt;p>흔히 텍스처 포맷이라고 하면 우리가 흔하게 볼 수 있는 &lt;code>파일 포맷&lt;/code>을 생각해볼 수 있다. 이는 일반적으로 디스크에 파일을 저장할 때 저장 용량을 아끼기 위한 압축 포맷으로 생각하면 된다.&lt;/p>
&lt;p>유니티에서는 다양한 파일 포맷을 가져와 별도의 처리 없이 사용할 수 있다. 물론 PSD를 사용하면 프로젝트 자체의 용량이 어마어마 해진다던지, PNG를 사용하면 알파 채널을 컨트롤 하기 힘들어 추가 옵션을 설정해야 한다던지 차이점이 조금씩 존재하지만, 결과적으로 게임 빌드파일에 들어갈 텍스처 어떤 포맷을 사용하든 상관없다.&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>사용 가능 포맷:&lt;/strong> BMP, EXR, GIF ,HDR, IFF, JPG, PICT, PNG, PSD, TGA, TIFF&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>이러한 텍스처 포맷들은 디스크에 GPU를 위한 형태로 저장되어 있지 않다. 따라서 게임에 텍스처를 효율적으로 사용하기 위해서는 디스크에 저장된 이미지 파일들을 GPU를 위한 텍스처 포맷으로 따로 지정해주어야 한다. 실제 게임에서는 GPU를 위해 변경된 포맷으로 텍스처를 변환 시켜 사용하기 때문에 디스크에 저장되어 있는 포맷이 무엇인지는 상관 없는 것이다.&lt;/p>
&lt;p>텍스처 포맷을 지정할 때 현재 사용하는 디바이스에서 지원해주고, 시각적인 효과 대비 이미지 품질이 적게 변하는 포맷으로 잘 조율하여 변경하여야 한다. 텍스처 압축에서 가장 중요한 것은 적절한 압축 포맷을 사용하는 것이다.&lt;/p>
&lt;h4 id="왜-gpu에서-못써요">왜 GPU에서 못써요?&lt;/h4>
&lt;p>디스크에 저장되는 파일 포맷들은 보통 저장 용량을 아끼기 위한 압축 포맷인 경우가 많은데, 예를 들어 PNG 파일은 &lt;code>가변 비율 압축&lt;/code>을 사용하여 자신의 용량을 압축하고 있다. 예를 들어 aaaabbbcccccd라는 원본 데이터가 있을 때, a4b3c5d1과 같은 식으로 디스크에 저장 되게 되는 것이다. GPU에서 텍스처를 사용할 때에는 보통 UV좌표를 이용해서 텍스처의 특정 부분을 &lt;code>랜덤 엑세스&lt;/code>하여 색상을 가져오게 되는데, &lt;code>시작 주소+오프셋&lt;/code>방식으로 접근하는 랜덤 액세스 방식은 위처럼 압축되어 있는 데이터에 사용하기가 힘들다. 따라서 GPU에서 랜덤 액세스를 통해 샘플링을 할 수 있도록 포맷을 변경해줘야 한다.&lt;/p>
&lt;h2 id="텍스처-압축-포맷">텍스처 압축 포맷&lt;/h2>
&lt;p>대표적인 압축 포맷인 ETC2, ASTC, PVRTC에 대한 정보를 정리해보았다.&lt;/p>
&lt;h3 id="etc2-범용성을-앞세운-안드로이드-표준">ETC2: 범용성을 앞세운 안드로이드 표준&lt;/h3>
&lt;p>&lt;img alt="ETC2" src="https://velog.velcdn.com/images/eugene-doobu/post/ab79022c-26e9-41f3-a169-40ae6d8d1cf4/image.png">&lt;/p>
&lt;p>(사진 출처: Ericsson AB 2009, ETC2-PACKAGE)&lt;/p>
&lt;p>&lt;strong>ETC2&lt;/strong>(Ericsson Texture Compression 2)는 OpenGL ES 3.0 이상 버전을 지원하는 대부분의 안드로이드 기기에서 표준처럼 사용되는 압축 포맷이다. &lt;code>ETC1&lt;/code>의 후속 버전으로, 알파채널을 지원하고 전반적인 압축 후 이미지 퀄리티가 ETC1보다 개선되었다.&lt;/p>
&lt;h3 id="특징">특징&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>범용 지원&lt;/strong>: 안드로이드 환경 전반에 광범위하게 적용되어 있어 호환성 면에서 유리하다.&lt;/li>
&lt;li>&lt;strong>알파 지원&lt;/strong>: ETC1은 알파 채널을 지원하지 않았지만, ETC2는 RGBA 형태로 알파까지 담을 수 있다.&lt;/li>
&lt;li>&lt;strong>고정 비트레이트&lt;/strong>: ASTC처럼 가변 비트레이트를 지원하지는 않아, 화질과 크기를 섬세하게 조절하기는 어렵다.&lt;/li>
&lt;/ol>
&lt;p>ETC2는 현재 &lt;strong>안드로이드에서 가장 호환성이 좋은 텍스처 포맷&lt;/strong>으로 생각하면 된다. 저사양 안드로이드 디바이스들을 타겟으로 삼고 있는 경우 ETC2 포맷을 선택하는 것이 좋다. 뒤에서 소개할 &lt;code>ASTC&lt;/code> 포맷이 압축 품질, 유연성 면에서 우수하기 때문에 주 타겟으로 삼고있는 디바이스가 저사양 기기가 아니라면 ASTC포맷을 사용하는게 유리하다.&lt;/p>
&lt;p>(ASTC 6X6의 경우 ETC2와 비슷한 품질을 보여주지만 용량은 절반 수준이다)&lt;/p>
&lt;h3 id="pvrtc-ios-위주의-압축">PVRTC: iOS 위주의 압축&lt;/h3>
&lt;p>&lt;img alt="PVRTC" src="https://velog.velcdn.com/images/eugene-doobu/post/7a01acc4-5eca-49c4-8a18-8bb234169335/image.png">&lt;/p>
&lt;p>(사진 출처: imaginationtech)&lt;/p>
&lt;h3 id="개요">개요&lt;/h3>
&lt;p>&lt;strong>PVRTC&lt;/strong>(PowerVR Texture Compression)는 iOS 디바이스를 중심으로 많이 사용되는 텍스처 압축 포멧이다. 모든 세대의 iPhone, iPod Touch, iPad에서 사용가능하며, PowerVR GPU를 사용하는 특정 Android 기기에서도 지원된다. &lt;strong>텍스처의 해상도가 2의 지수승 정사각형이어야 한다&lt;/strong>는 제약이 있다.&lt;/p>
&lt;h3 id="특징-1">특징&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>블록 크기&lt;/strong>: PVRTC는 텍스처가 2의 거듭제곱 해상도를 권장하며, 블록 단위 압축 특성이 있어 이미지가 특정 크기여야 최적 결과를 얻기 쉬움&lt;/li>
&lt;li>블록 경계를 뭉개며 &lt;strong>블러링&lt;/strong>을 시켜주며, &lt;strong>블록 경계에서 색이 번지는 현상&lt;/strong>이 일어날 수 있다. 도트나 아이콘에는 좋지 않다.&lt;/li>
&lt;/ol>
&lt;p>조사하면 할 수록 현재 시점에서 이 포맷을 왜 쓰는지 이해가 가지 않았다. 텍스처의 해상도가 2의 지수승 정사각형이어야 한다는 제약이 너무 크게 느껴졌다. 소형 아이콘은 아틀라스로 묶어서 쓴다고 하더라도 모든 텍스처를 그렇게 쓰기는 힘들다고 생각된다. iOS도 역시 가능하면 &lt;strong>ASTC&lt;/strong>를 사용하는게 가장 좋은 방향인 것 같다. 근데 ETC2랑 상황이 다르게 ASTC는 iOS유저라면 거의 확정적으로 사용할 수 있다.&lt;/p>
&lt;p>(PVRTC를 사용해야하는 특별한 이유가 있다면 댓글로 알려주세요&amp;hellip;)&lt;/p>
&lt;h3 id="astc-다양한-비트레이트로-품질-조절">ASTC: 다양한 비트레이트로 품질 조절&lt;/h3>
&lt;p>&lt;img alt="ASTC" src="https://velog.velcdn.com/images/eugene-doobu/post/fd357a41-c2a4-4622-bc64-58a5ee2fbec0/image.png">&lt;/p>
&lt;p>(사진 출처: developer.arm.com)&lt;/p>
&lt;p>&lt;strong>ASTC&lt;/strong>(Adaptive Scalable Texture Compression)는 ARM과 AMD가 공동 개발한 압축 포맷이다. 가변 비트레이트를 지원하며 개발자가 해상도·화질·압축률 간의 트레이드오프를 자유롭게 조정할 수 있다. 또한 위에서 설명한 이전 시대의 포맷들 보다 압축률 대비 텍스처 품질도 뛰어나다.&lt;/p>
&lt;h3 id="특징-2">특징&lt;/h3>
&lt;ol>
&lt;li>&lt;strong>가변 블록 크기&lt;/strong>: 4×4부터 12×12 픽셀 블록까지, 비트레이트를 자유롭게 설정 → 원하는 균형점을 찾기 쉬움&lt;/li>
&lt;li>&lt;strong>멀티플랫폼 지원 확대&lt;/strong>: 최신 안드로이드 기기나 iOS Metal 등에서 점차 지원이 확산.&lt;/li>
&lt;li>&lt;strong>고품질 유지&lt;/strong>: 높은 비트레이트(예: 4×4 블록)로 설정하면 일반 DXT나 ETC2보다 화질이 우수한 압축 결과를 낼 수 있음&lt;/li>
&lt;li>비교적 &lt;strong>최신 기기에서만 지원&lt;/strong>한다. 2024-02-16 기준으로 ASTC 포맷을 지원하지 않는 기기들이 있어 해당 포맷을 적용할지에 대한 고민이 필요했다.&lt;/li>
&lt;/ol>
&lt;p>유연한 포맷으로 모델링이라던지 정밀도가 높아야 하는 텍스처는 압축 블럭을 작게 지정(4x4)하고, 이펙트와 같은 휘발성이 높거나 디테일이 높지 않아도 되는 경우 압축 블럭을 크기 지정(12x12)하는 식으로 사용할 수 있다. 어느정도 압축(6x6 정도)을 하더라도 ETC2나 PVRTC와 비슷한 품질이 나오기 때문에 주 타겟 디바이스가 &lt;strong>ASTC를 지원한다면 ASTC를 선택하는걸 추천&lt;/strong>한다&lt;/p>
&lt;h2 id="나인크로니클에서의-텍스처-압축">나인크로니클에서의 텍스처 압축&lt;/h2>
&lt;h3 id="기존상태">기존상태&lt;/h3>
&lt;p>&lt;img alt="build report" src="https://velog.velcdn.com/images/eugene-doobu/post/5dca7eb2-279e-4bb1-8847-ce76a4e315f1/image.png">&lt;/p>
&lt;p>텍스처 압축 설정 전에 빌드 리포트를 뽑아 리소스의 사이즈를 체크해 본 결과이다. 빌드 리포트의 상위권에 많은 양의 Uncompressed Texture2D 친구들이 있었다. 이것만 압축해도 빌드 용량을 크게 줄일 수 있다. 살펴보니 압축 옵션이 되있는 것들과 안 되 있는 것들이 섞여있던 상태. 우선 되있는 것들의 포맷에 맞춰야 한다는 생각이 들었다.&lt;/p>
&lt;p>또한 위의 &lt;strong>이중압축 문제&lt;/strong>가 발생하지 않게 아틀라스에 포함될 텍스쳐는 압축을 하지 않아야 한다. 아틀라스에 포함되는 텍스처들과 포함되지 않는 텍스처들이 프로젝트에서 분리가 되어있지 않아 이러한 구분이 까다로웠다. 아틀라스로 관리될 텍스쳐들은 확실히 분리하는게 좋다.&lt;/p>
&lt;h3 id="시장조사">시장조사&lt;/h3>
&lt;p>2024-02-16기준으로 디바이스별 텍스처 압축 포맷 지원에 대한 통계를 찾아보았다.&lt;/p>
&lt;h4 id="안드로이드">안드로이드&lt;/h4>
&lt;p>&lt;img alt="Android Texture" src="https://velog.velcdn.com/images/eugene-doobu/post/53fb8ec7-fcc9-4ec5-8a45-331eeb06356c/image.png">&lt;/p>
&lt;p>(+2022.8.8기준 PVRTC 11%)&lt;/p>
&lt;h4 id="ios">iOS&lt;/h4>
&lt;p>&lt;img alt="iOS Usage" src="https://velog.velcdn.com/images/eugene-doobu/post/2fa6cd66-a63c-4516-8586-5d5fe96f5084/image.png">&lt;/p>
&lt;p>현재 89% 유저가 ios16 이상 기기 사용, &lt;strong>ios13이상 사용시 확정적으로 astc 지원&lt;/strong>&lt;/p>
&lt;p>(2021년 4월 기준, &lt;a href="https://forum.unity.com/threads/ios-changed-default-texture-compression-format-from-pvrtc-to-astc.1088845/">약 2%의 유저들만 A7(astc 지원 안하는 기기)칩을 이용&lt;/a>한다고 함)&lt;/p>
&lt;p>ios의 경우 아래 포함 상위 기기에서 모두 지원(A8 processor)&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IPhone_6">iPhone 6 &amp;amp; 6 Plus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IPod_Touch_(6th_generation)">iPod Touch (6th generation)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/IPad_Mini_4">iPad Mini 4&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Apple_TV">Apple TV HD&lt;/a> (formerly 4th generation)&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/HomePod">HomePod (1st generation)&lt;/a>&lt;/li>
&lt;/ul>
&lt;h4 id="나인크로니클-플레이-유저">나인크로니클 플레이 유저&lt;/h4>
&lt;p>회사 내부에서 사용하고 있는 솔루션들의 통계를 통해 게임을 플레이하는 유저들의 국가 통계를 알 수 있었다. 확인 결과 역시 안드로이드는 ETC2로 가는게 안전하다는 판단이 들었다. iOS의 경우 굳이 PVRTC를 사용할 이유를 찾지 못하였다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;h3 id="안드로이드--etc2">안드로이드 → ETC2&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>일부 색상 손실&lt;/strong>&lt;/li>
&lt;li>&lt;strong>95%의 디바이스 지원&lt;/strong>&lt;/li>
&lt;li>ETC2가 지원되지 않는 5% 기기는 무압축 32/16bit텍스처 지원&lt;/li>
&lt;li>기존에도 해당 압축 옵션을 사용한 텍스처들이 꽤 있음&lt;/li>
&lt;/ul>
&lt;h3 id="ios--astc">IOS → ASTC&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>iPhone 5s 타겟으로 최적 지원 안됨&lt;/strong> (ios13부터 100%기기 모두 지원)
→ 확인상 거의 모든 텍스처가 ASTC 아니면 압축안함으로 설정되어 있었음. 따라서 디바이스가 ASTC를 지원하지 않아도 사실상 변경사항 거의 없음&lt;/li>
&lt;/ul>
&lt;p>따라서, 앞으로&lt;/p>
&lt;ul>
&lt;li>PVRTC를 사용하지 않음으로 텍스처 이미지를 정사각형으로 뽑을 필요가 없다.&lt;/li>
&lt;li>텍스처 추출은 안드로이드(ETC2)를 위해 일단 POT으로 뽑아야함&lt;/li>
&lt;/ul>
&lt;p>&lt;img alt="Spine Pot" src="https://velog.velcdn.com/images/eugene-doobu/post/c428b723-c5bc-4141-b992-8f0b832bdbfc/image.png">&lt;/p>
&lt;p>이 기준에 맞게 프로젝트에서 사용하는 &lt;a href="https://github.com/planetarium/NineChronicles/pull/4373">스파인 리소스들을 정리&lt;/a>하였다.&lt;/p>
&lt;h1 id="3-오디오-압축-기법">3. 오디오 압축 기법&lt;/h1>
&lt;hr>
&lt;p>오디오도 설정에 따라 프로젝트의 메모리 사용량이 크게 달라진다.&lt;/p>
&lt;h3 id="모노와-스테레오">모노와 스테레오&lt;/h3>
&lt;p>사운드는 모노와 스테레오 사운드로 나뉜다. 스테레오는 2개의 채널을 사용하므로 모노의 2배의 용량을 사용한다고 보면 된다. 사운드의 용량도 가벼운 편이 아니므로 디바이스와 게임 콘텐츠 특성을 고려해 올바른 옵션을 선택하여야 한다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>모노&lt;/strong>: 하나의 채널을 통해 믹싱되고 재생되는 오디오를 말하며, 이는 하나의 스피커 또는 여러 개의 스피커가 동일한 소리를 동시에 내는 형태입니다.&lt;/li>
&lt;li>&lt;strong>스테레오(Stereo)&lt;/strong>: 왼쪽과 오른쪽 두 채널을 사용하여 서로 다른 오디오 신호를 전달하며, 깊이와 차원의 감각을 더해줍니다.
(출처: &lt;a href="https://kr.kef.com/blogs/news/mono-vs-stereo-speakers-sound-differences">KEF: 모노(Mono) vs. 스테레오(Stereo) 사운드: 차이점은 무엇일까요?&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>일반적으로 모바일 디바이스의 경우 게임에서 스테레오 사운드를 사용할 일이 거의 없다. 모바일의 경우 대부분 MONO로 설정해주면 된다.&lt;/p>
&lt;h3 id="로드타입">로드타입&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>Decompress on load&lt;/strong>: 압축을 풀어서 올리는 굉장히 위험한 옵션. 재생속도가 굉장히 빠른 특성이 있다. 사운드의 길이가 짧고 반응속도가 매우 중요한 경우 사용하는게 좋다.&lt;/li>
&lt;li>&lt;strong>Compressed into memory&lt;/strong>: 압축된 사운드 사용, 일반적인 효과음을 이 옵션으로 지정하는게 좋다.&lt;/li>
&lt;li>&lt;strong>Streaming&lt;/strong>: 보통 사운드 길이가 긴 배경음악, 반응속도가 중요하지 않은 사운드에 적용하는게 좋다.&lt;/li>
&lt;/ul>
&lt;p>위 설명대로 대부분의 경우 효과음은 &lt;code>Compressed into memory&lt;/code>, 배경음악은 &lt;code>Streaming&lt;/code>을 사용하면 될 것 같다.&lt;/p>
&lt;h3 id="compression-format">Compression Format&lt;/h3>
&lt;ul>
&lt;li>PCM: 비압축 포맷으로 퀄리티가 중요하며 재생시간이 짧은 오디오 파일에 적합하다.&lt;/li>
&lt;li>Vorbis: 중간길이 정도의 효과음 또는 배경음악에 적합하며 압축률(Quality)를 조절할 수 있다. 대부분의 경우 이 옵션을 선택한다.&lt;/li>
&lt;li>ADPCM: 압축률이 PCM대비 3.5배이기에 메모리는 덜 쓸 수 있지만, CPU자원은 조금 더 사용한다. 노이즈가 발생하기에 노이즈가 크게 상관없는 효과음에 적합하다.&lt;/li>
&lt;/ul>
&lt;p>또한 사운드가 Mute되어도 프로세스에 메모리는 존재하는 상태로 남아있는다. 이러한 점을 주의하고 프로파일링을 통해 낭비되고 있는 메모리가 없는지 체크하는게 중요하다.&lt;/p>
&lt;h3 id="9c에서의-사운드-압축">9C에서의 사운드 압축&lt;/h3>
&lt;p>&lt;img alt="오디오" src="https://velog.velcdn.com/images/eugene-doobu/post/0f339d05-40aa-480a-a248-9d8093f2e7e4/image.png">&lt;/p>
&lt;p>메모리 프로파일링 도중.. 뭔가 엄청나 보이는 메모리를 차지하는 AudioClip을 발견하였고, 이를 계기로 프로젝트 오디오 파일들의 압축 옵션을 확인하게 되었었다. 적용 내용은 간단하게 모든 bgm에 대해 동일한 옵션을 적용하였다.&lt;/p>
&lt;ul>
&lt;li>LoadType: Streaming&lt;/li>
&lt;li>Compression Format: ADPCM&lt;/li>
&lt;li>Sample Rate Setting: Override Sample Rate&lt;/li>
&lt;li>Sample Rate: 22,050&lt;/li>
&lt;/ul>
&lt;p>또한 사운드의 디테일을 크게 살릴 필요성이 없다고 판단되어 모든 사운드를 &lt;strong>MONO&lt;/strong>형태로 저장하기로 하였다.&lt;/p>
&lt;p>이런 간단한 변경을 통해 iOS기준 &lt;strong>백메가 단위의 상당히 많은 메모리를 절약&lt;/strong>시킬 수 있었다.&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/5283">사운드 옵션 pr&lt;/a>&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>추천 옵션&lt;/strong>
&lt;strong>배경음악&lt;/strong>: Streaming + Vorbis
&lt;strong>효과음&lt;/strong>: Compressed into memory + ADPCM&lt;/p>
&lt;/blockquote>
&lt;h2 id="4-스파인-데이터-개선">4. 스파인 데이터 개선&lt;/h2>
&lt;p>이전 글에서 GC에 대한 설명과, 유니티 환경에서 GC가 왜 중요한지에 대해 이야기를 나눈 바 있다. 유니티에서 제공하는 &lt;a href="https://unity.com/blog/games/optimize-your-mobile-game-performance-tips-on-profiling-memory-and-code-architecture-from">모바일 디바이스 최적화 책&lt;/a>서는 메모리와 GC 파트에서 다음과 같은 내용을 강조한다.&lt;/p>
&lt;p>&lt;strong>불필요한 힙 할당으로 인해 GC 스파이크가 발생할 수 있다는 점에 유의하세요:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>문자열: C#에서 문자열은 값 유형이 아닌 참조 유형입니다. 불필요한 문자열 생성이나 조작을 줄입니다. &lt;strong>JSON 및 XML(혹은 csv)과 같은 문자열 기반 데이터 파일을 구문 분석하지 말고&lt;/strong>, 대신 &lt;strong>ScriptableObjects나 MessagePack 또는 Protobuf와 같은 형식으로 데이터를 저장&lt;/strong>합니다. 런타임에 문자열을 빌드해야 하는 경우 StringBuilder 클래스 사용
&amp;hellip;&lt;/li>
&lt;/ul>
&lt;p>&lt;img alt="스파인 프로파일링" src="https://velog.velcdn.com/images/eugene-doobu/post/24a170b7-b77e-4137-a59b-eacd149d5396/image.png">&lt;/p>
&lt;p>기존 9C 프로젝트는 JSON 기반 데이터 파일을 런타임에 파싱하여 스파인 애니메이션을 수행하고 있었다. 에디터 프로파일링 결과, JSON 데이터 파싱 과정에서 상당한 GC Alloc이 발생하고, 이에 따른 처리 시간이 소요되는 것을 확인할 수 있었다.&lt;/p>
&lt;h3 id="스파인-데이터-포맷-변경">스파인 데이터 포맷 변경&lt;/h3>
&lt;p>스파인 데이터 포맷을 JSON에서 바이너리 형태로 변경했다. 기존 스파인 데이터(JSON 포맷)는 아래와 같이 설정값을 직관적으로 확인하고 수정하기 쉽다는 장점이 있었다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;skeleton&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;hash&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;pk8bvriq1EUyoeKgE79GQivbfyg&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;spine&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;3.8.99&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;x&amp;#34;&lt;/span>: -&lt;span style="color:#00d;font-weight:bold">384.15&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;y&amp;#34;&lt;/span>: -&lt;span style="color:#00d;font-weight:bold">105.72&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;width&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">674&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;height&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">450&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;images&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;./images/&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;audio&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;C:/Users/user/Desktop/animation/Cut_Scene&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;bones&amp;#34;&lt;/span>: [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;root&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;x&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">1.47&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;cutscene_01&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;parent&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;root&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;rotation&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">50.7&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;x&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">291.32&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;y&amp;#34;&lt;/span>: -&lt;span style="color:#00d;font-weight:bold">106.04&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;slots&amp;#34;&lt;/span>: [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;skins&amp;#34;&lt;/span>: [{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;default&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;attachments&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;cutscene&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;cutscene_01&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;x&amp;#34;&lt;/span>: -&lt;span style="color:#00d;font-weight:bold">40.95&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;y&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">405.78&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;rotation&amp;#34;&lt;/span>: -&lt;span style="color:#00d;font-weight:bold">50.7&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;width&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">674&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;height&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">450&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;animations&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이러한 특성 때문에 스파인 리소스를 처음 임포트하고 확인해보는 과정에서는 json형태로 데이터를 저장하는게 유리할 수 있다. 그러나 인게임에서는 이러한 장점이 필요 없고, 오히려 로드시 성능에 악영향을 미친다는 단점만 남는다. 실제 환경에서의 성능을 위해 binary형태로 데이터를 저장하는 방식으로 설정을 변경하였다.&lt;/p>
&lt;h3 id="스파인-버전-업">스파인 버전 업&lt;/h3>
&lt;p>기존에 사용하던 스파인 3.8 버전을 4.1 버전으로 업그레이드했다.
특히 대규모 프로젝트 환경에서 성능이 크게 개선되었다고 한다.&lt;/p>
&lt;p>추가로 버전 관리를 용이하게 하기 위해 스파인을 Git 패키지 형태로 프로젝트에 임포트하도록 수정했다.&lt;/p>
&lt;p>&lt;a href="https://ko.esotericsoftware.com/spine-changelog#v4-0-00-beta">스파인 4-0-00 체인지로그&lt;/a>&lt;br>
&lt;a href="https://github.com/planetarium/NineChronicles/pull/4119">스파인 업그레이드PR&lt;/a>&lt;/p>
&lt;h3 id="스파인-성능비교">스파인 성능비교&lt;/h3>
&lt;p>&lt;img alt="스파인 변경 전 이미지" src="https://velog.velcdn.com/images/eugene-doobu/post/67b123f0-3347-41ef-b54a-757e38c943c9/image.png">&lt;/p>
&lt;p>변경 전 스파인 프로파일링&lt;/p>
&lt;hr>
&lt;p>&lt;img alt="스파인 변경 후 이미지" src="https://velog.velcdn.com/images/eugene-doobu/post/75bb8871-4d37-4cba-923c-a468076ed0ff/image.png">&lt;/p>
&lt;p>변경 후 스파인 프로파일링&lt;/p>
&lt;hr>
&lt;p>같은 스테이지에서 몬스터 생성 과정을 비교한 결과, &lt;code>2.5MB / 162.94ms&lt;/code>에서 &lt;code>0.7MB / 27.06ms&lt;/code>로 성능이 개선된 것을 확인할 수 있었다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>내용을 정리하면서 텍스처 압축에 대해 다시 한 번 정리할 수 있었고, 내가 이런 일을 했었구나도 정리해볼 수 있었다. 관련 자료를 검색하면서 좋은 블로그들도 몇 개 찾았다. 아래 참고에 봤던 블로그들을 모아놨으니 해당 주제에 관심이 있다면 하나씩 같이 보는걸 추천한다.&lt;/p>
&lt;p>&lt;img alt="잘자요" src="https://velog.velcdn.com/images/eugene-doobu/post/0415a8b3-1cd9-4a3a-8f92-f947b720b0a7/image.png">&lt;/p>
&lt;hr>
&lt;h3 id="참고">참고&lt;/h3>
&lt;p>&lt;a href="https://namu.wiki/w/%ED%85%8D%EC%8A%A4%EC%B2%98%20%EC%95%95%EC%B6%95%20%ED%8F%AC%EB%A7%B7">나무위키-텍스처 압출 포맷&lt;/a>&lt;br>
&lt;a href="https://www.youtube.com/watch?v=BeEjoTa9sSo">[유니티 TIPS] 알쓸유잡 | 효율적인 텍스처 압축 이해하기&amp;amp; 꿀팁&lt;/a>&lt;br>
&lt;a href="https://mentum.tistory.com/585">아틀라스 리소스 폴더 주의&lt;/a>&lt;br>
&lt;a href="https://mentum.tistory.com/586">아틀라스 이중압축&lt;/a>&lt;br>
&lt;a href="https://chulin28ho.tistory.com/362">&amp;ldquo;유니티에서는&amp;quot;어째서 PNG보다는 TGA가 더 쓸모있는 파일 포맷인가?&lt;/a>&lt;br>
&lt;a href="https://hotfoxy.tistory.com/116">텍스처 압축과 ASTC&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://velog.io/@eugene-doobu/%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EA%B2%8C%EC%9E%84-%EC%97%90%EC%85%8B-%EA%B4%80%EB%A6%AC-%EA%B0%9C%EC%84%A0%EA%B8%B0-%EB%B2%88%EC%99%B81.%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%B5%9C%EC%A0%81%ED%99%94-%EA%B8%B0%EB%B2%95">블로그 원본&lt;/a>&lt;/p></content><author><name>홍유진</name><uri>https://github.com/eugene-doobu</uri><email>eugene@planetariumhq.com</email></author></entry><entry><title>Hacktoberfest 2024 후기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2024/11/hacktoberfest/" title="Hacktoberfest 2024 후기"/><link rel="alternate" href="https://snack.planetarium.dev/1/01/hacktoberfest/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2024/11/hacktoberfest/</id><published>2024-11-12T00:00:00+00:00</published><updated>2024-11-12T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요! 저희 DX팀은 2024년 10월 25일부터 27일까지 3일 동안 Hacktoberfest 스프린트 행사를 진행했어요.&lt;/p>
&lt;p>이 글에서는 Hacktoberfest가 어떤 행사인지 간략히 소개하고, 이번 온/오프라인 스프린트가 어떻게 진행되었는지, 그리고 Hacktoberfest를 통해 받은 소중한 기여 내용을 공유하려고 해요.&lt;/p>
&lt;h2 id="-hacktoberfest에-대하여">📝 Hacktoberfest에 대하여&lt;/h2>
&lt;p>혹시 &lt;dfn>Hacktoberfest&lt;/dfn>라는 행사를 들어보셨나요? Hacktoberfest는 매년 10월 1일부터 31일까지 한 달간 진행되는 오픈 소스 행사예요. 전 세계 누구나 참여할 수 있으며, 10월 동안 공개 저장소에 4개의 풀 리퀘스트를 제출하면 목표를 달성한 것으로 인정되고 보상이 주어지는 방식이에요. 예전에는 굿즈를 제공했지만, 요즘은 디지털 뱃지를 주는 것 같아요.&lt;/p>
&lt;p>오픈 소스 저장소 메인테이너 입장에서는 Hacktoberfest에 참여하려면 저장소의 토픽에 &lt;code>hacktoberfest&lt;/code>를 추가하거나, 특정 이슈에 &lt;code>hacktoberfest&lt;/code> 라벨을 달아야 해요. 기여자는 이 &lt;code>hacktoberfest&lt;/code> 라벨이 달린 이슈들을 찾아 해결함으로써 행사에 참여할 수 있어요.&lt;/p>
&lt;figure>&lt;img src="/1/01/hacktoberfest/images/hacktoberfest-issues.png"
alt="hacktoberfest 라벨이 붙은 이슈들" width="500">&lt;figcaption>
&lt;p>&lt;q>hacktoberfest&lt;/q> 라벨이 붙은 이슈들&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h2 id="-온오프라인-스프린트-행사">🙌 온/오프라인 스프린트 행사&lt;/h2>
&lt;p>Hacktoberfest는 기본적으로 어디서든 GitHub나 GitLab 등을 통해 참가할 수 있는 프로젝트예요. 하지만 온라인 또는 오프라인으로 별도의 행사를 열 수도 있어요.&lt;/p>
&lt;p>그래서 제가 속해 있는 DX 팀에서는 오픈 소스 기여를 어려워하는 분들을 돕기 위해 Planetarium의 저장소들을 대상으로 기여를 돕는 온/오프라인 행사를 기획했어요. Google Form을 통해 참가 신청을 받고 홍보한 덕분에 많은 분이 참가해 주셨고, 저희는 준비를 시작했어요.&lt;/p>
&lt;p>먼저, 10월 25일과 26일에 진행된 온라인 행사는 &lt;a href="https://planetarium.dev/discord">디스코드 서버&lt;/a>에서 열렸어요. 디스코드의 &amp;ldquo;메인 스테이지&amp;rdquo; 음성 채널에서 오프닝 발표를 진행한 뒤, Git과 GitHub에 익숙하지 않은 분들을 위해 Git 세션을 준비해 진행했어요.&lt;/p>
&lt;figure>&lt;img src="/1/01/hacktoberfest/images/hacktoberfest-discord-1.png"
alt="메인 스테이지 채널에서 오프닝 발표 진행" width="500">&lt;figcaption>
&lt;p>메인 스테이지 채널에서 오프닝 발표 진행&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>이후에는 DX 팀원들이 각자의 채널에서 참가자분들이 관심 있는 이슈에 대해 이야기를 나누고, 적절한 이슈를 배정해 드렸어요. 디스코드를 통해 실시간으로 소통하며 어려운 부분을 해결하실수 있도록 돕고, 기여 내용이 머지되어 업스트림에 반영될 수 있도록 도와드렸어요.&lt;/p>
&lt;figure>&lt;img src="/1/01/hacktoberfest/images/hacktoberfest-discord-2.png"
alt="기여자분 마다 메인테이너가 배정되어 기여를 도와드렸어요" height="500">&lt;figcaption>
&lt;p>기여자분 마다 메인테이너가 배정되어 기여를 도와드렸어요&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>10월 27일에 진행된 오프라인 행사에서도 온라인 행사와 마찬가지로 오프닝 발표와 Git 세션이 진행되었어요.&lt;/p>
&lt;figure>&lt;img src="/1/01/hacktoberfest/images/hacktoberfest-offline-git.png"
alt="오프라인 행사장에서 DX팀 지원님이 Git 세션을 진행해주셨어요" width="500">&lt;figcaption>
&lt;p>오프라인 행사장에서 DX팀 &lt;a href="https://github.com/Atralupus">지원&lt;/a>님이 Git 세션을 진행해주셨어요&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>사무실에서 열린 덕분에 Planetarium 엔지니어들이 참가자들과 직접 만나 함께 기여 활동을 할 수 있었어요.&lt;/p>
&lt;figure>&lt;img src="/1/01/hacktoberfest/images/hacktoberfest-offline-contribution.jpg"
alt="회의실에서 DX팀 승민님이 기여를 도와드리는 중" width="500">&lt;figcaption>
&lt;p>회의실에서 DX팀 &lt;a href="https://github.com/boscohyun">승민&lt;/a>님이 기여를 도와드리는 중&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;h2 id="-기여받은-부분들">🙏 기여받은 부분들&lt;/h2>
&lt;p>앞서 사진과 함께 보여드린 온/오프라인 행사를 포함해, 10월 동안 많은 기여가 있었습니다. 그중 몇 가지 주요 기여를 소개해 드리려고 해요.&lt;/p>
&lt;hr>
&lt;p>블록체인 라이브러리인 &lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a>은 .NET 패키지 레지스트리인 NuGet에 배포되고 있어요. 버전 목록에서 최신 버전을 쉽게 찾을 수 있도록 dev 릴리스에는 &lt;code>-dev.&amp;lt;timestamp&amp;gt;&lt;/code>와 같은 타임스탬프 기반의 suffix를 붙이고 있는데요, 타임스탬프가 zerofill 없이 발행되면서 버전들이 릴리스 시간 순서대로 정렬되지 않는 문제가 있었어요.&lt;/p>
&lt;p>다행히 &lt;a href="https://github.com/uday-rana">uday-rana&lt;/a> 님의 기여로 이제는 릴리스 시간 순서대로 정렬되어 최신 dev 릴리스를 쉽게 찾을 수 있게 되었어요. (&lt;a href="https://github.com/planetarium/libplanet/pull/3957">PR&lt;/a>)&lt;/p>
&lt;figure>&lt;img src="/1/01/hacktoberfest/images/libplanet-nuget-versions.png"
alt="시간 순서대로 정렬된 Libplanet dev 릴리스들" width="500">&lt;figcaption>
&lt;p>시간 순서대로 정렬된 Libplanet dev 릴리스들&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>Planetarium에서 오픈소스로 개발 중인 게임 &lt;a href="https://nine-chronicles.dev/">Nine Chronicles&lt;/a>에는 게임의 프로토콜 로직을 포함한 &lt;a href="https://github.com/planetarium/lib9c">lib9c&lt;/a>라는 라이브러리가 있어요. 이 라이브러리에는 블록체인에 트랜잭션이 어떻게 생겨야 하는지, 전투가 어떤 규칙으로 이루어지는지, 그리고 마켓 관련 동작이 어떻게 이루어져야 하는지에 대한 코드가 작성되어 있어요. 하지만 C#으로 작성되어 있어 JavaScript로 개발된 사내 프로젝트에서 활용하기에 어려움이 있었어요. 이에 JavaScript로 쉽게 트랜잭션을 만들 수 있는 라이브러리를 만들었지만, 기능이 부족한 상태였어요.&lt;/p>
&lt;p>다행히 &lt;a href="https://github.com/kanade012">kanade012&lt;/a>님과 &lt;a href="https://github.com/originchoi">originchoi&lt;/a>님의 기여로 &lt;strong>액션 포인트 리필&lt;/strong>, &lt;strong>아레나 참가&lt;/strong>, &lt;strong>그라인딩&lt;/strong>과 같은 게임 내 행동을 위한 트랜잭션을 이제는 C#이 아닌 JavaScript만으로도 만들 수 있게 되었어요. (&lt;a href="https://github.com/planetarium/lib9c/pull/2941">“액션 포인트 리필” PR&lt;/a>, &lt;a href="https://github.com/planetarium/lib9c/pull/2946">“아레나 참가” PR&lt;/a>, &lt;a href="https://github.com/planetarium/lib9c/pull/2949">“그라인딩” PR&lt;/a>)&lt;/p>
&lt;figure>&lt;img src="/1/01/hacktoberfest/images/lib9cjs-prs.png"
alt="자바스크립트 라이브러리에 기능을 추가한 PR들" width="500">&lt;figcaption>
&lt;p>자바스크립트 라이브러리에 기능을 추가한 PR들&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>라이브러리뿐만 아니라, Planetarium에서 오픈소스로 개발 중인 게임 &lt;a href="https://nine-chronicles.dev/">Nine Chronicles&lt;/a>의 &lt;a href="https://github.com/planetarium/NineChronicles">유니티 클라이언트&lt;/a>에도 기여해주신 분이 계셨어요. 게임의 월드 보스 콘텐츠를 플레이할 때, 우측 상단의 플레이 버튼이 언어 설정과 상관없이 영어로 표시되는 문제가 있었어요.&lt;/p>
&lt;p>&lt;a href="https://github.com/HohyunKim-kr">HohyunKim-kr&lt;/a>님의 기여로 이제 버튼이 의도한 언어로 제대로 표시되도록 수정되었어요. (&lt;a href="https://github.com/planetarium/NineChronicles/pull/6232">PR&lt;/a>)&lt;/p>
&lt;figure>&lt;img src="/1/01/hacktoberfest/images/9c-unity-bugfix.png"
alt="HohyunKim-kr 님이 올려주신 PR" width="500">&lt;figcaption>
&lt;p>HohyunKim-kr 님이 올려주신 PR&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>외에도 정말 많은 분들이 기여를 해주신 덕분에 많은 기능이 생기고, 많은 버그 및 오타들이 수정될 수 있었어요. 🙏&lt;/p>
&lt;h2 id="-끝마치며">🔍 끝마치며&lt;/h2>
&lt;p>Hacktoberfest 스프린트 행사를 급하게 준비하느라 부족한 점도 많았지만, 사내에서 많은 도움을 주신 덕분에 잘 준비할 수 있었어요. 많은 분들이 참가해 주시고 다양한 기여를 해주셔서 정말 감사드립니다. 🙏&lt;/p>
&lt;p>또한, 이런 오픈 소스 행사에 관심이 있고 한국에서 활동하며 직접 기여해보고 싶으신 분들께 다음과 같은 행사들을 추천드리고 싶어요:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://festa.io/events/6342">Open Contribution Jam 2024&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://x.com/sprintseoul">SprintSeoul&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.contribution.ac/">Open Source Contribution Academy&lt;/a>&lt;/li>
&lt;li>PyCon Sprint (&lt;a href="https://2024.pycon.kr/program/sprint">파이콘 한국 2024 스프린트&lt;/a>)&lt;/li>
&lt;/ul>
&lt;p>혹시 제가 모르는 다른 행사들도 있다면 &lt;a href="https://planetarium.dev/discord">Planetarium Dev 디스코드 서버&lt;/a>에 들어와 알려주세요! 😉&lt;/p></content><author><name>이도건</name><uri>https://github.com/moreal</uri><email>dogeon@planetariumhq.com</email></author></entry><entry><title>라이브 게임 에셋 관리 개선기 - 2.메모리 사용 절감</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2024/09/asset-load-2/" title="라이브 게임 에셋 관리 개선기 - 2.메모리 사용 절감"/><id>https://snack.planetarium.dev/kor/2024/09/asset-load-2/</id><published>2024-09-30T00:00:00+00:00</published><updated>2024-09-30T00:00:00+00:00</updated><content type="html">&lt;h1 id="인트로">인트로&lt;/h1>
&lt;hr>
&lt;p>&lt;a href="../../08/asset-load-1/">저번 글&lt;/a>에서, 게임이 오래 지속적으로 업데이트되면 컨텐츠가 계속해서 늘어나게 되고, 이를 따로 관리하기 위해 에셋 번들 등의 기법을 통해 에셋을 빌드와 분리해서 관리하기도 한다는 것에 대해 이야기하였다. 이렇게 빌드와 에셋이 분리되더라도 게임을 실행시키기 위해서는 빌드 파일과 온라인에서 별도로 다운받은 에셋들을 동시에 메모리에 올려야 한다. 즉, 게임이 계속 개발되며 리소스가 늘어나게 되면 메모리에 로드해야 하는 에셋들의 수도 늘어난다는 뜻이다.&lt;/p>
&lt;p>&lt;img alt="또리코네" src="https://velog.velcdn.com/images/eugene-doobu/post/87876574-6623-4eff-8876-586698d8541b/image.png">&lt;/p>
&lt;p>현재 애플 iOS의 최신 기기인 iPhone 16 Pro Max의 경우에도 RAM 용량은 8GB이며, 조금 구버전의 디바이스인 iPhone 12의 경우 RAM 용량은 4GB로, 위 프리코네의 추가 리소스를 한 번에 담을 수 없는 크기이다. 그리고 전 세계 사람들이 플레이하는 게임을 만들기 위해서는 현 시대 최고 스펙의 장비가 아닌 저사양 디바이스를 타겟으로 테스트를 해야 많은 사람들이 안정적으로 플레이할 수 있는 게임이 된다.&lt;/p>
&lt;p>이와 같은 논리는 PC 게임에도 동일하게 적용된다. 사람들은 데스크탑 기준으로 보통 16GB 램을 주로 사용하는 것으로 보이며, 신경 좀 쓰면 32GB, 돈 좀 쓰면 64GB의 램을 사용하는 게 일반적일 것이다.&lt;em>(뇌피셜임)&lt;/em> 하지만 요즘 나오는 PC 게임들의 용량은 점점 커지고 있으며 이제는 100GB 게임의 시대라고 해도 될 정도이다. 아래 리스트는 최근 출시된 고용량의 게임들을 정리해놓은 것이다.&lt;/p>
&lt;ul>
&lt;li>ARK: Survival Evolved - 275GB&lt;/li>
&lt;li>Call of Duty: Modern Warfare - 250GB&lt;/li>
&lt;li>final fantasy: 15 - 160GB&lt;/li>
&lt;li>Star Wars Jedi: Survivor - 130GB&lt;/li>
&lt;li>The Last of Us Part 1 - 100GB&lt;/li>
&lt;li>Diablo 4 - 90GB&lt;/li>
&lt;/ul>
&lt;p>이처럼 게임에는 리소스를 로드하기 위해 큰 메모리가 필요하고, 모든 게임 리소스를 한 번에 RAM에 올릴 수 없다는 것을 알 수 있을 것이다. 그렇다고 게임 리소스를 필요한 순간마다 즉시 로드하고 해제한다면 게임이 뚝뚝 끊길 것이며 이는 유저에게 불쾌한 경험이 될 것이다. 그리고 디바이스의 메모리에는 우리가 만든 게임뿐만 아니라 다양한 프로세스가 올라갈 수 있음을 명심해야 한다.&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/c5b8889a-e2bf-41d7-9427-699a82ac4dba/image.png" width="60%">
&lt;/center>
&lt;p>이러한 이유로 에셋 로드/언로드 타이밍을 지정해 메모리 관리를 하는 것은 게임 개발에서 특히 중요한 부분이고, 이번 글에서는 나인크로니클(9C)에서 메모리 관리를 위해 어떤 작업을 하였는지 작성해보겠다. 또한 현재 타겟 플랫폼에 맞게 사용할 리소스를 최적화하여 게임에 사용되는 리소스를 줄이는 작업도 진행하였는데, 이 부분에 대해서도 같이 다뤄보도록 하겠다.&lt;/p>
&lt;p>&lt;img alt="고기굽기" src="https://velog.velcdn.com/images/eugene-doobu/post/d6e0e64a-f04a-4b67-84e5-8bbce5db2744/image.png">&lt;/p>
&lt;p>1부. 어드레서블 에셋 도입&lt;br>
&lt;strong>2부. 메모리 사용 구조 개선 / 리소스 최적화&lt;/strong> &amp;lt;- 현재 글&lt;br>
번외1. 리소스 최적화 기법&lt;br>
3부. DLC를 통한 패치 시스템&lt;/p>
&lt;h2 id="개요">개요&lt;/h2>
&lt;hr>
&lt;h4 id="오브젝트-풀-개요">오브젝트 풀 개요&lt;/h4>
&lt;p>몇 메가바이트 단위 혹은 그 이상의 크기를 가진 리소스를 메인 스레드를 블록하고 로드하려고 시도하면, 일정한 FPS를 유지해야 하는 게임의 프레임에 큰 영향을 주게 된다. 로드를 비동기로 한다고 하더라도 상황에 따라 프레임에 영향을 주지 않을 뿐, 게임 플레이 자체가 어색해지는 상황이 생길 수 있다. 예를 들어, 총을 발사하려고 공격 키를 눌렀는데 총알 리소스가 로드되기 위해 0.5초 동안 발사가 안 된다고 생각해보자. 유저 경험이 매우 불편할 것이다.&lt;/p>
&lt;p>또한 로드된 오브젝트를 사용 직후 바로 파괴한다고 하면, C#의 가비지 컬렉터에 좋지 않은 영향을 줄 수 있다. 특히 총알과 같이 자주 사용되는 오브젝트들은 메모리 파편화를 일으키고 Full GC의 호출을 가속화시킬 것이다. 유니티의 GC는 .NET의 GC보다 효율적이지 못하다. 세대 구분, SOH와 LOH, 메모리 재정렬 같은 개념이 없기 때문에 더욱 예민하게 다루어주어야 한다.&lt;/p>
&lt;p>GC는 언제 호출될지 파악할 수 없기 때문에, 이러한 점을 고려하지 않고 개발을 하다 보면 게임이 지속해서, 혹은 중요한 순간에 뚝 끊길 수 있는 위험이 생기게 된다.&lt;/p>
&lt;p>&lt;img alt="GC" src="https://velog.velcdn.com/images/eugene-doobu/post/669b11a3-2c58-4121-8012-8ce1d80edc23/image.png">&lt;/p>
&lt;p>이러한 문제를 해결하기 위해 &lt;strong>오브젝트 풀링(Object Pooling)&lt;/strong> 기법을 활용할 수 있다. 오브젝트 풀링은 자주 사용되는 오브젝트를 미리 생성해 두고, 필요하지 않을 때는 일시적으로 비활성화했다가 다시 필요해지면 재사용하는 방법이다. 이를 통해 메모리 할당과 해제를 최소화하여 가비지 컬렉션의 빈도를 낮추고, 게임의 성능을 향상시킬 수 있다. 예를 들어, 총알 객체를 매번 생성하고 파괴하는 대신, 미리 일정 수의 총알 객체를 생성해 두고 필요할 때 가져와 사용한 후 다시 반환하는 방식이다. 이렇게 하면 메모리 파편화와 GC로 인한 성능 저하를 효과적으로 줄일 수 있다.
&lt;br>&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/52bbe188-d36f-40a4-9e05-bab95e0fe1d7/image.png" width="50%">
&lt;/center>
&lt;p>위 사진에서 곰이 레몬이 필요할 때마다 들고 있는 상황이라고 생각해보자. 기존의 방식이 레몬이 필요할 때마다 씻고 옷을 입고 밖으로 나가서 시장에서 레몬을 구매해 오는 것이었다면, 오브젝트 풀은 레몬을 미리 여러 개 구매해 뒀다가 필요할 때마다 필요한 만큼 들고 있는 것이라고 할 수 있다.&lt;/p>
&lt;h4 id="오브젝트-풀-개선">오브젝트 풀 개선&lt;/h4>
&lt;p>9C에서는 자주 사용될 오브젝트를 오브젝트 풀링을 위해 사용하도록 구현되어 있다. 아래 스크린샷과 같이 다양한 콘텐츠들에 사용될 오브젝트들이 풀에 등록이 되어 있었다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">&lt;img alt="UI 풀" src="https://velog.velcdn.com/images/eugene-doobu/post/58325cf4-70b6-4e4a-bba1-d4e7c9ddec09/image.png">&lt;/th>
&lt;th style="text-align: left">&lt;img alt="스테이지 풀" src="https://velog.velcdn.com/images/eugene-doobu/post/08db71e2-9239-417a-807c-79b6c01b83d1/image.png">&lt;/th>
&lt;th style="text-align: left">&lt;img alt="오디오 풀" src="https://velog.velcdn.com/images/eugene-doobu/post/a808393d-6645-4133-8761-a935ef24ebcd/image.png">&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>게임에 사용하는 모든 UI 1종씩&lt;/li>
&lt;li>게임에 사용하는 이펙트 3~5개씩, 필요한 경우 추가 생성&lt;/li>
&lt;li>모든 사운드 오브젝트 1종씩&lt;/li>
&lt;/ul>
&lt;p>이 풀의 문제는 게임 콘텐츠의 모든 오브젝트들의 수명이 영구적이었다는 것이다. 이로 인해 메모리가 계속 쌓이는 상황이었으며, iOS의 경우 특정 디바이스에서 앱이 종료되는 문제가 발생할 정도로 메모리 이슈가 있어 한 번의 응급처치가 들어간 상황이었다.&lt;/p>
&lt;p>이후 신규 콘텐츠의 업데이트가 연달아서 예정되어 있던 상황이라, 언제 터질지 모르는 메모리 문제를 빨리 해결해야겠다고 생각했고, 빠른 시간 안에 메모리 사용량을 줄일 방법을 찾기 위해 프로파일링 툴을 통해 현재 게임을 위해 사용하고 있는 메모리를 검사해보았다.&lt;/p>
&lt;h1 id="에디터-프로파일링">에디터 프로파일링&lt;/h1>
&lt;p>&lt;img alt="스크린샷" src="https://velog.velcdn.com/images/eugene-doobu/post/d190a35a-cb0f-4760-bcad-bafc8372d7ec/image.png">&lt;/p>
&lt;p>위 오브젝트 풀에 저장되어 있는 오브젝트들이 얼마만큼의 메모리를 점유하고 있는지 확인하기 위한 테스트를 진행했다. 먼저 비교 대상인 A의 경우 기존 게임에서 스테이지에 돌입 후 메모리 캡처를 한 것이고, B는 현재 사용 중이지 않는 UI(Widget), 이펙트, 사운드를 제거 후 &lt;code>GC.Collect()&lt;/code>를 강제로 돌린 후 캡처를 한 결과이다.&lt;/p>
&lt;ul>
&lt;li>(In Used) Native Memory -&amp;gt; 393.5 MB 차이 발생&lt;/li>
&lt;li>Untracked Memory -&amp;gt; 366.5 MB 차이 발생&lt;/li>
&lt;/ul>
&lt;p>에디터에서 진행한 프로파일링은 에디터의 UI, 내부적인 시스템으로 인해 많은 노이즈가 끼어있어 정확한 수치를 믿을 수는 없다. 그리고 문제가 되는 모바일 디바이스와 에디터가 구동되고 있는 윈도우의 플랫폼 차이가 존재하기에 더욱 그렇다. 하지만 현재 사용하지 않을 오브젝트만 적당히 제거 한다면 1~200MB 정도의 절감할 수 있을 것이라는 기대를 할 수 있게 되었다.&lt;/p>
&lt;p>하지만 여기서 문제가 있다. 기존 모든 리소스를 일단 생성해 두고 사용하던 풀 방식에서, 필요한 오브젝트만 생성하여 사용하는 방식으로 바꾸는 것은 기존 방식에서 큰 변화가 필요했고, 그중에서도 가장 많은 메모리를 차지하는 것으로 추정되는 UI의 구조를 변경하는 것은 현재 게임의 핵심 구조를 뜯어고치는 정도의 대규모 리메이크가 필요한 작업이었다.&lt;/p>
&lt;p>심지어 팀원들이 관련하여 콘텐츠 작업을 지속적으로 진행해야 했기에, 특히 관리하기 힘든 게임 에셋의 작업 충돌을 피하기 위해 이와 같은 대규모 개선 작업은 진행하기 어려웠다. 게다가, 라이브 서비스 중인 게임의 경우 업데이트와 패치가 실시간으로 이루어지기 때문에, 대규모 변경은 예상치 못한 버그를 초래할 수 있다는 우려도 있다. 이는 유저들에게 직접적인 영향을 줄 수 있어 더욱 신중한 접근이 필요했다. 현실적으로 단기간에 메모리 사용량을 줄이기 위한 방법을 찾기 위해 어떤 에셋이 얼마만큼 메모리를 사용하는지 분석해 보기로 하였다.&lt;/p>
&lt;p>(이 글을 쓰는 지금 시점 UI구조를 바꾼것으로 인한 버그가 발생해서 급하게 고치고 오는 길이다)&lt;/p>
&lt;p>&lt;img alt="메모리분석" src="https://velog.velcdn.com/images/eugene-doobu/post/6a8dba62-3d12-4c50-9ad8-79d0320316ec/image.png">&lt;/p>
&lt;p>위 A와 B 스냅샷에서 리소스가 사용하는 메모리 사용량의 변화를 체크한 결과이다. 메모리 사용량을 기준으로 내림차순 정렬을 하였더니, 같은 리소스가 A와 B에서 다른 해시 값을 가지며 &lt;code>new/delete&lt;/code>가 반복되어 표시되는 경향이 있어 어떤 리소스를 얼마만큼 줄였는지에 대해서 파악이 힘들었다.&lt;/p>
&lt;p>하지만 어떤 일을 하면 메모리 사용량을 줄일 수 있는지 파악할 수는 있었다. 대부분의 메모리가 &lt;code>Texture2D&lt;/code>, &lt;code>AudioClip&lt;/code>을 위해 할당된 것을 확인할 수 있었다. 가장 상위에 위치한 2048x2048 사이즈의 이미지(아틀라스)가 압축되지 않은 사이즈인 32MB 용량으로 존재하는 것을 확인할 수 있고, 이와 비슷한 Texture2D 여러 개 존재하다. AudioClip도 이상할 정도의 메모리를 점유하고 있는 걸 보니 이 둘만 줄여도 많은 양의 메모리가 줄어들 것으로 기대할 수 있었다.&lt;/p>
&lt;ul>
&lt;li>압축되지 않은 텍스처들이 많이 존재&lt;/li>
&lt;li>사운드 옵션이 통일되어 있지 않고, 특정 사운드에서 많은 메모리 사용 중&lt;/li>
&lt;li>시트 데이터로 보이는 것들 중 많은 메모리를 점유 중인 것이 있음&lt;/li>
&lt;li>렌더 텍스처들이 먹는 메모리도 컸음&lt;/li>
&lt;li>특정 콘텐츠에서만 사용하는 리소스들이 항상 많은 크기의 메모리를 점유 중&lt;/li>
&lt;/ul>
&lt;p>그 외에도 당장 적용하기 힘들지만 장기적으로 적용할 만한 개선 사항들을 파악할 수 있었다. 일단은 텍스처와 사운드에 대한 용량을 줄이는 것으로 빠르게 효율적인 메모리 사용량 감소 작업을 진행할 것이다.&lt;/p>
&lt;p>(스프라이트 아틀라스는 여러 스프라이트 이미지를 하나의 큰 이미지 파일로 결합하는 기술이다. 그래픽 처리 효율성을 향상시키고, 렌더링 속도를 높이며, 메모리 사용을 최적화하는 데 도움을 준다. 이에 대한 자세한 설명과 적용 과정은 별도의 글에서 다뤄보도록 하겠다.)&lt;/p>
&lt;h1 id="ios-프로파일링">iOS 프로파일링&lt;/h1>
&lt;p>iOS에서 메모리 프로파일링을 하는 이유는 다음과 같다&lt;/p>
&lt;ul>
&lt;li>PC와 모바일을 동시에 지원할 경우, 메모리 문제는 보통 iOS 디바이스에서 가장 먼저 발생한다&lt;/li>
&lt;li>iOS프로파일러가 쓰기 편하다&lt;/li>
&lt;li>이전에 에디터에서 프로파일링을 했지만, 그 결과에는 에디터 자체의 데이터가 포함되어 불필요한 노이즈가 발생한다. 이러한 노이즈를 제거하고 정확한 메모리 사용량을 측정하기 위해 특정 디바이스에서 앱을 실행하고 프로파일링하는 것이 좋다.&lt;/li>
&lt;/ul>
&lt;h3 id="1-기존-프로젝트에서-성능측정">1. 기존 프로젝트에서 성능측정&lt;/h3>
&lt;p>&lt;img alt="iOS 프로파일링" src="https://velog.velcdn.com/images/eugene-doobu/post/4e20be6b-a335-4eed-8216-54aa733cfafe/image.png">&lt;/p>
&lt;p>기존 프로젝트에서 콘텐츠를 진행하면서 메모리 사용량을 측정해보았다. 콘텐츠를 실행할 때 필요한 리소스들이 누적되어 메모리 사용량이 지속적으로 증가하는 것을 확인할 수 있었다.&lt;/p>
&lt;pre tabindex="0">&lt;code>로비 : 1.51GB
마켓 : 1.56GB
워크샵-소환 : 1.67GB
소환영상 시청중 : 1.73GB
월드보스 전투중 : 1.82GB
로비 : 1.8GB
몬스터콜렉션 : 1.83GB
아레나 전투 로딩 : 1.94GB
아레나 전투 후 로비 : 1.96GB
제작강화룬업글분해 후 로비: 2.01GB
시즌패스 : 2.14GB
컬랙션 : 2.14GB
스테이지 329 : 2.2GB
로비 : 2.17GB
어드벤처보스 1층 전투 : 2.32GB
어드벤처보스 돌파 : 2.43GB
로비 : 2.41GB
&lt;/code>&lt;/pre>&lt;p>&lt;img alt="gpu" src="https://velog.velcdn.com/images/eugene-doobu/post/fe239a4d-152c-4969-ada4-b4e537324ca0/image.png">&lt;/p>
&lt;p>이렇게 iOS에서 GPU 성능측정과 리소스별 메모리 사용량을 점검할 수 있다. 위 에디터 프로파일링 결과와 비슷하게 압축되지 않은 아틀라스들이 상당히 많은 메모리를 차지하는 것을 확인할 수 있다. 실제 게임이 돌아가는 모바일 디바이스에서도 텍스처 압축만 잘 하면 많은 메모리 여유를 확보할 수 있음을 확신하는 순간이였다.&lt;/p>
&lt;h3 id="2-메모리-정리-기능-추가">2. 메모리 정리 기능 추가&lt;/h3>
&lt;p>텍스처 압축에 앞서, &amp;lsquo;로비로 갈 때마다&amp;rsquo; 메모리를 수동으로 정리하는 기능을 추가했다. 이전에 9C에서는 대부분의 오브젝트들이 풀에 저장되어 지속적으로 메모리가 쌓이는 형태라고 이야기했지만, 그렇지 않은 콘텐츠들도 존재했다. 기본적으로 전투에서 등장하는 몬스터 스파인 리소스들은 필요할 때 로드하고 전투가 끝나면 파괴하는 구조로 구현되어 있었다.&lt;/p>
&lt;p>또한 이전에 iOS에서 메모리 사용량이 많아 앱이 종료되는 이슈가 있었고, 이에 따른 응급처치가 이루어졌는데, 로그인 단계에서 사용하는 오브젝트들을 로비로 들어오는 과정에서 파괴하는 기능이 구현되어 있었다. 하지만 이러한 작업에서도 메모리가 깔끔하게 정리되지 않는 문제가 있었다.&lt;/p>
&lt;p>유니티에서는 특정 리소스를 사용하던 오브젝트가 해제되어도 사용하던 리소스를 즉시 해제하지 않고, 씬이 종료될 때 해제하도록 구현되어 있다. 이는 메모리 관리 측면에서 이점이 있을 수 있지만, 우리가 원하는 메모리 최적화에는 걸림돌이 될 수 있다. 예를 들어, 게임 플레이 도중에 필요하지 않게 된 거대한 텍스처나 오디오 클립이 있다면, 해당 오브젝트를 파괴해도 메모리에서 즉시 해제되지 않기 때문에 메모리 사용량이 계속 높게 유지된다.&lt;/p>
&lt;p>문제는 9c가 단일 씬 구조로 되어있었기에 로비에 진입하면서 파괴된 오브젝트들에서 사용하던 리소스가 제대로 정리되지 않던 문제가 있었던 것이다. 오브젝트 풀에 쌓이고 있는 오브젝트를 정리하기 전에, 이러한 리소스 청소 과정을 도입해야 겠다고 생각하였고, 해당 기능을 추가하고 메모리 사용량을 다시 측정해보았다. 변경된 코드는 매우 간단하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-c#" data-lang="c#">&lt;span style="display:flex;">&lt;span> &lt;span style="color:#888">// Clear Memory&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Resources.UnloadUnusedAssets();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> GC.Collect();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/5319">PR: clear memory on room enter&lt;/a>&lt;/p>
&lt;p>이와 같이 코드를 수정하고 나서 다시 메모리를 측정 한 결과이다. 최종 결과 기준 약 200MB 정도의 메모리 사용이 절감되었다.&lt;/p>
&lt;pre tabindex="0">&lt;code>로비: 1.44GB (기존 1.51GB)
마켓→소환→월드보스전투
로비: 1.61GB (기존 1.8GB)
몬콜→아레나 전투
로비: 1.63GB (기존 1.96GB)
제작강화룬업글분해
로비: 1.72GB (기존 2.01GB)
시즌패스 컬랙션 스테이지329, 330,331(원래 329만 했었는데 실수로 두스테이지 더돔)
로비: 1.92GB(기존 2.17GB 이상)
&lt;/code>&lt;/pre>&lt;h3 id="3-오디오아틀라스-압축-옵션을-적용하고-다시-테스트">3. 오디오/아틀라스 압축 옵션을 적용하고 다시 테스트&lt;/h3>
&lt;p>다음으로, 아틀라스들이 압축될 수 있도록 설정하고 사운드 옵션을 통일하여 다시 빌드를 진행했다. 이때 사용한 옵션들과 세부 사항은 이 글에서 다루기에는 분량이 많아질 것 같아 별도의 글에서 따로 다뤄보도록 하겠다.&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/5318">PR: 아틀라스 셋팅 통일&lt;/a>&lt;br>
&lt;a href="https://github.com/planetarium/NineChronicles/pull/5283">PR: audio controller polishing&lt;/a>&lt;/p>
&lt;pre tabindex="0">&lt;code>로비: 1.13GB(기존 1.44GB) [초기: 1.51GB]
마켓→소환→월드보스전투
로비: 1.3GB(기존 1.61GB) [초기: 1.51GB]
몬콜→아레나 전투
로비: 1.31GB(기존 1.63GB) [초기: 1.96GB]
제작강화룬업글분해
로비: 1.4GB(기존 1.72GB) [초기: 2.01GB]
시즌패스 컬랙션 스테이지329
로비: 1.48GB(기존 1.92GB) [초기: 2.17GB]
&lt;/code>&lt;/pre>&lt;h3 id="결론">결론&lt;/h3>
&lt;ul>
&lt;li>사용하지 않는 리소스 정리로 인한 여유 메모리 확보&lt;/li>
&lt;li>오디오 및 아틀라스 설정을 정리하여 리소스 메모리 사용량 감소&lt;/li>
&lt;/ul>
&lt;p>클라이언트 메모리 사용량을 30% 감소(2.1gb → 1.4gb)&lt;/p>
&lt;h1 id="앱-용량">앱 용량&lt;/h1>
&lt;hr>
&lt;p>이번 글은 메모리 최적화에 대한 주제를 다루는 글이지만, 관련 작업을 하면서 앱 용량도 효과적으로 줄일 수 있었다.&lt;/p>
&lt;p>&lt;img alt="8월드" src="https://velog.velcdn.com/images/eugene-doobu/post/9354bf71-652f-4d8d-a333-a950540ca25f/image.jpg">&lt;/p>
&lt;h3 id="1-기존-빌드-결과물-용량">1. 기존 빌드 결과물 용량&lt;/h3>
&lt;p>앱 용량 비교는 많은 리소스가 추가되었던 8월드를 기준으로 한다. 실제 앱 용량을 비교하기 전에, 모바일 빌드 CI에서 나온 결과물의 용량을 먼저 확인하여 얼마나 용량이 줄었는지 파악했다. 이 결과물은 실제 앱 용량이 아니라 해당 플랫폼에 업데이트를 준비하기 위한 것으로, 실제 앱 용량은 이보다 더 가볍다.&lt;/p>
&lt;p>&lt;strong>안드로이드: 1.2gb&lt;/strong>&lt;br>
&lt;strong>IOS: 2.76gb&lt;/strong>&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/4336">8월드 리소스 PR&lt;/a>&lt;/p>
&lt;h3 id="2-스프라이트-리소스-정리">2. 스프라이트 리소스 정리&lt;/h3>
&lt;p>이번에는 기존 프로젝트에서 사용하는 많은 양의 텍스처가 압축되지 않고 있다는 문제를 발견했다. 또한 하나의 텍스처가 여러 아틀라스에서 중복 포함되는 문제가 있었고, 모든 스파인 아틀라스가 &lt;code>POT(Power of Two)&lt;/code> 형태가 아니라 특정 디바이스에서 압축이 불가능한 상황이었다.&lt;/p>
&lt;p>이를 해결하기 위해 먼저 안드로이드에서의 압축을 위해 스파인 아틀라스 텍스처를 POT 형태로 고정하여 추출하였다. 이후 모든 텍스처에 대해 압축 설정과 아틀라스 정리를 진행했다.&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/4373">PR: 스파인 atlas pot&lt;/a>&lt;br>
&lt;a href="https://github.com/planetarium/NineChronicles/pull/4419">PR: 텍스처 패킹&lt;/a>&lt;/p>
&lt;p>&lt;strong>안드로이드: 899MB&lt;/strong> - 8월드 대비 -301MB&lt;br>
&lt;strong>IOS: 2.07GB&lt;/strong> - 8월드 대비 -690MB&lt;/p>
&lt;p>해당 챕터에서 사용한 최적화 기법들에 대한 상세 내용은 추후 별도의 글에서 다뤄보도록 하겠다.&lt;/p>
&lt;h3 id="실제-앱-용량-비교">실제 앱 용량 비교&lt;/h3>
&lt;p>빌드 산출물은 위와 같은 결과가 나왔다. 이제 실제 앱 스토어에 등록되어있는 앱의 크기를 통해 유저들이 다운받을 앱 용량이 얼마나 줄었는지 확인해보자.&lt;/p>
&lt;p>iOS: &lt;code>625MB&lt;/code> -&amp;gt; &lt;code>460MB&lt;/code> (앱 스토어 커넥트에서 &lt;code>압축 파일 크기&lt;/code>)&lt;br>
Android: &lt;code>648MB&lt;/code> -&amp;gt; &lt;code>478MB&lt;/code> (구글 플레이 콘솔에서 &lt;code>원본 파일&lt;/code>)&lt;/p>
&lt;p>iOS의 경우 &lt;strong>165mb차이로 26.4%&lt;/strong>&lt;br>
Android의 경우 &lt;strong>170mb차이로 26.2%&lt;/strong>&lt;/p>
&lt;p>평균 26.3% 정도의 용량을 절감시킬 수 있었다. 이로 인해 앱 다운로드를 통하여 소모될 전력을 절감시켜 지구 온난화의 가속을 둔화시킬 수 있었다.&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/9d2c5536-1000-49cd-b07e-208537b63c4a/image.png" width="40%">
&lt;/center>
&lt;h1 id="마무리">마무리&lt;/h1>
&lt;hr>
&lt;p>사실 아직도 최적화 할 일이 많이 남아있다.&lt;/p>
&lt;h3 id="오브젝트-풀의-메모리-사용량">오브젝트 풀의 메모리 사용량&lt;/h3>
&lt;p>처음에 9c의 오브젝트 풀 구조에 대한 문제점을 이야기하였다. 하지만 이를 근본적으로 고치는 작업은 진행하지 못했다. 이를 해결하지 못하면 콘텐츠가 추가됨에 따라 앱 사용 메모리가 지속해서 증가하는 현상이 계속 존재할 것이고, 언젠가는 발목을 크게 잡게 될 가능성이 있다.&lt;/p>
&lt;p>이를 개선하기 위한 첫 삽으로 로그인 씬을 분리하는 작업을 진행해 보았다. 실제 메모리 사용량을 절감하는 데 큰 도움은 안되지만, 앞으로는 콘텐츠 별로 씬을 분리할 수 있고, 모든 오브젝트가 항상 살아있는 것이 아닌 필요한 순간마다 생성해서 풀에 등록해 놓을 수 있도록 적용하는 작업을 시작할 수 있게 되었다.&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/5452">PR: 로그인 씬 분리&lt;/a>&lt;/p>
&lt;h3 id="아틀라스-정리">아틀라스 정리&lt;/h3>
&lt;p>위에서 스프라이트 리소스 정리를 진행하였지만 모든 아틀라스에 대한 정리를 진행하지 못했다. 여전히 중복해서 아틀라스에 등록되는 텍스처가 존재하고, 아틀라스 구조에 대한 일관성을 확보하지 못했다. 한 화면에 그려질 가능성이 있는 오브젝트들만 패킹하여 렌더링할 수 있도록 아틀라스가 구성이 되어야 할 텐데, 이에 대한 점검도 필요할 것으로 보인다. 이에 대응하기 위한 이슈는 만들어 두었지만, 손을 대고 있지 못하는 상황이다.&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/issues/4324">issue: 아틀라스 리소스 정리&lt;/a>&lt;/p>
&lt;p>이는 모두 9c에서 사용하는 근본 구조에서 기인한 문제라고도 볼 수 있다. 프로젝트의 초기 단계부터 구조가 설계되고, 그 위에 추가적인 콘텐츠 코드들이 쌓이고 에셋들도 그것에 맞게 쌓아가다 보면 후반에 와서 최적화를 하기에는 곤란해진다. 언젠가 이를 개선할 기회가 생기거나 다시 메모리 문제가 생기기 직전의 상태까지 온다면 버그와 작업 충돌이 생길 수 있음을 각오하고 해당 구조를 뜯어고쳐야 할 순간이 올지도 모르겠다.&lt;/p>
&lt;p>이 외에도 몬스터 스파인 에셋 데이터를 저장하는 방식을 바꾸어 로드시간을 단축하기도 하였다. 이와 관련된 내용과 해당 글에서 적용한 최적화 기법에 대한 자세한 내용들은 다음에 작성할 &lt;code>번외1. 리소스 최적화 기법&lt;/code>글에서 자세히 다뤄보도록 하겠다.&lt;/p>
&lt;p>&lt;img alt="끝" src="https://velog.velcdn.com/images/eugene-doobu/post/7ac2a11d-0b69-4e2d-83a3-b4e2dc6c8360/image.png">&lt;/p>
&lt;p>&lt;a href="https://velog.io/@eugene-doobu/%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EA%B2%8C%EC%9E%84-%EC%97%90%EC%85%8B-%EA%B4%80%EB%A6%AC-%EA%B0%9C%EC%84%A0%EA%B8%B0-2.%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%82%AC%EC%9A%A9-%EC%A0%88%EA%B0%90%EB%82%98%EC%9D%B8%ED%81%AC%EB%A1%9C%EB%8B%88%ED%81%B4">블로그 원본&lt;/a>&lt;/p></content><author><name>홍유진</name><uri>https://github.com/eugene-doobu</uri><email>eugene@planetariumhq.com</email></author></entry><entry><title>라이브 게임 에셋 관리 개선기 - 1.어드레서블 에셋 도입</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2024/08/asset-load-1/" title="라이브 게임 에셋 관리 개선기 - 1.어드레서블 에셋 도입"/><id>https://snack.planetarium.dev/kor/2024/08/asset-load-1/</id><published>2024-08-01T00:00:00+00:00</published><updated>2024-08-01T00:00:00+00:00</updated><content type="html">&lt;h1 id="인트로">인트로&lt;/h1>
&lt;hr>
&lt;p>&lt;img alt="나나이트" src="https://velog.velcdn.com/images/eugene-doobu/post/e5dd641b-c37f-416d-ac5f-38666cf72a45/image.png">&lt;/p>
&lt;p>게임에는 일반적으로 서비스 앱보다 훨씬 많은 리소스가 사용된다. 이는 게임이 사용자에게 지속해서 재미와 몰입감을 제공하기 위해 풍부한 컨텐츠와 동적인 경험이 필요하기. 만약 우리가 게임을 다운받았는데 게임 캐릭터는 다 똑같이 생긴 졸라맨 뿐이고 공격 커맨드가 하나뿐인 액션게임이었다고 생각해보자. ~~(엥 이거 개꿀잼 게임 슈퍼액션히어로아닌가?)~~ 이렇게 만들어도 게임이 재밌을 수는 있으나, 대부분은 대충 만든 디지털 쓰레기 게임이라고 생각하고 게이머들이 관심을 안 줄 것이다.&lt;/p>
&lt;p>게임에는 보통 대규모의 이미지와 3D모델들이 필요하며, 일반적인 서비스 애플리케이션보다 리소스가 집약적으로 사용된다. 현대의 컴퓨터와 모바일 기기가 성능이 개선되었음에도, 여전히 프로그램 최적화에 대한 필요성은 존재한다. 특히 모바일 기기에서는 메모리 관리가 중요한 고려사항으로 남아있다. 리소스를 무분별하게 추가하는 경우 기기의 메모리 한계에 빠르게 도달할 수 있다. 이는 간단한 게임의 개발에서는 큰 문제가 되지 않을 수 있지만, 지속해서 컨텐츠를 업데이트하고 확장해야 하는 게임의 경우 메모리 관리는 필수적인 요소가 된다.&lt;/p>
&lt;p>게임이 단순한 실시간 메모리 사용량을 넘어서 장기적으로 업데이트되고, 시즌별 이벤트를 진행하면서, 이전 시즌의 이벤트 에셋들이 항상 필요하지 않은 경우가 많다. 이런 이벤트 에셋들은 다음 시즌에 어떻게 활용될지 불확실하므로 클라이언트 프로젝트에서 완전히 삭제하기는 어려운 상황일 수 있다. 이 경우 이벤트 에셋들을 게임 빌드에서 분리하여 필요할 때만 추가 데이터 다운로드를 통해 플레이어에게 제공하는 방법이 효과적일 수 있다. 이러한 데이터 분리 방식은 단지 이벤트 시에만 유용한 것이 아니라, DLC를 통해 게임 콘텐츠를 추가로 판매할 때에도 활용될 수 있다. 특히 모바일 게임에서는 이러한 분리 기능이 에셋 관리의 핵심적인 요소로 자리 잡을 것이다.&lt;/p>
&lt;p>이처럼 게임에는 많은 양의 에셋들이 사용되기 때문에 게임개발을 장기간 안정적으로 진행하기 위해서 프로젝트의 에셋 관리는 필수적이라고 할 수 있다. 이 시리즈에서는 실제 라이브 서비스 중인 게임의 리소스 로드 구조를 개선하고, 게임의 사용성을 높이며 더 많은 리소스를 자유롭게 활용할 수 있도록 하는 다양한 에셋 관리 방법과 실 적용기를 다룰 예정이다. 이번 시리즈는 총 4개의 글로 이루어질 것으로 예상하며, 아래 순서대로 개선 방안을 제시하고 적용해보고자 한다.&lt;/p>
&lt;p>&lt;strong>1부. 어드레서블 에셋 도입&lt;/strong> (현재글)
2부. 메모리 사용 구조 개선 / 리소스 최적화
3부. DLC를 통한 패치 시스템&lt;/p>
&lt;p>(이런 내용들이 궁금하다면 미리 팔로우! 눌러주세요~~)&lt;/p>
&lt;h1 id="어드레서블-에셋-이란">어드레서블 에셋 이란?&lt;/h1>
&lt;hr>
&lt;h2 id="어드레서블이-뭔가요">어드레서블이 뭔가요?&lt;/h2>
&lt;p>어드레서블 도입과정을 설명하기 위해서는 유니티의 Resources 폴더와 에셋번들에 대한 이해가 필요한데, 이 글을 읽는 사람이 유니티를 깊게 사용해본 사람이 아니라는 가정하에 간단하게 설명해보고자 한다.&lt;/p>
&lt;h3 id="에셋번들">에셋번들&lt;/h3>
&lt;p>에셋번들은 게임에서 사용하는 &lt;strong>에셋들을 묶은 그룹&lt;/strong>으로써 게임의 최종 빌드파일과 별도로 관리할 수 있는 특징을 가지고 있다. 이처럼 에셋을 묶어서 별도의 파일 개념으로 관리하는 이유는, 프로젝트를 새로 빌드하지 않고도 게임에서 사용하는 에셋의 수정을 편하게 하기 위해서인 경우가 많다.&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/cf27ba81-8e8f-41f0-98bf-fd02cc588c81/image.png" width="55%">
&lt;/center>
&lt;p>이렇게 에셋번들을 사용해서 프로젝트를 진행하려면 에셋을 관리해주는 많은 코드가 필요하다. 이 별도의 에셋 파일이 어떻게 묶여서 저장되고, 게임 실행시에는 어디에 있는 에셋을 불러와서 사용할 것이며, 메모리 관리적인 측면에서 게임 시작 시 모든 에셋을 들고 있을 수 없기에 적재적소에 에셋을 로드해야 하는데, 어떤 시점에 메모리에 로드된 에셋을 내리고 새로운 에셋을 로드할지에 대해서 모두 개발자가 코드로 정리를 해줘야 한다. 또한, 아래 설명할 에셋 관리 문제 때문에 에셋을 효율적으로 관리하기 위한 전략을 수립하고, 이에 대한 구현을 진행해줘야 한다.&lt;/p>
&lt;h4 id="의존성-관리-문제">의존성 관리 문제&lt;/h4>
&lt;p>&lt;img alt="칼글이" src="https://velog.velcdn.com/images/eugene-doobu/post/2f94ce80-241e-4e17-abdf-06cd6862b6fb/image.png">&lt;/p>
&lt;p>위 스크린샷처럼 칼을 든 빨간 동글이와 회색이가 각각 별도의 에셋번들로 묶인다고 하자. 각 에셋번들만 로드해도 우리가 빌드했던 오브젝트가 그대로 게임 씬에 생성할 수 있다고 해보자. 이때 에셋번들은 오브젝트를 구성할 서브에셋들을 로드하여 빌드된다. 빨간 동글이로 예시를 들자면, 빨간 동글이 오브젝트에는 (칼, 동글이 리소스)라는 두개의 서브 에셋이 포함된 것이다. 두 오브젝트를 동시에 메모리에 로드했을때 우리의 메모리는 어떻게 될까?&lt;/p>
&lt;p>&lt;img alt="칼글이 메모리" src="https://velog.velcdn.com/images/eugene-doobu/post/dec0c217-5bae-47c9-9e86-6f65dd47ec88/image.png">&lt;/p>
&lt;p>빨간색 배경 -&amp;gt; 빨간 동글이를 포함한 에셋번들이 올라간 메모리
회색 배경 -&amp;gt; 회색이를 포함한 에셋번들이 올라간 메모리&lt;/p>
&lt;p>위 이미지에서 보이는 것 처럼, 두 오브젝트가 들고있는 칼이 각각 별도의 에셋으로 구분되어 메모리에 중복되어 올라가게 될 것이다. 이런 식으로 에셋번들이 구성된다면, 에셋과 빌드된 게임을 분리하고자 하는 목적은 달성하겠지만, 메모리를 관리하는 측면에서는 큰 손해를 볼 수 있다. 심지어 이 에셋들을 s3와 같은 외부 서버에 저장한다고 했을 때, 같은 에셋들을 여러번 저장소에 올리고 유저가 다운받아야 하는 상황이 벌어진다.&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/a8c092ac-1bf5-4294-957f-7ae176da84c4/image.png" width="45%">
&lt;/center>
&lt;h4 id="에셋-관리-문제">에셋 관리 문제&lt;/h4>
&lt;p>프로젝트가 점점 커지다보면 에셋의 수는 구분하기 힘들 정도로 많아지게 된다. 이때 처음부터 에셋들을 올바른 기준으로 정리해놓지 않았다면 나중에는 에셋이 너무 많아 손을 대기 힘든 수준까지 갈 수 있다. 게임 프로젝트 GUI에서 보이는 에셋들도 관리하기 힘든데, 에셋번들은 어떤 파일에 어떤 에셋들이 포함되어 있는지 한눈에 파악하기가 힘들다.&lt;/p>
&lt;p>별도의 자동화 코드를 만들어주지 않으면, 많은 에셋번들을 정해진 기준에 따라 관리해주는 것이 사실상 불가능에 가깝다. 프로젝트 바이너리에 기본적으로 포함되는 에셋들은 프로젝트의 적당한 경로에 폴더를 만들어서 처음 가져올 때 직접 한 번만 옮겨주는 것으로 충분하지만, 에셋번들의 목적은 프로젝트의 바이너리에 포함시키지 않고 별도로 빌드해서 관리하고 사용하는 것이고, 빌드된 번들들이 많아지면 그 복잡도가 늘어날 여지가 크기에, 매번 손으로 관리하는 것은 리스크가 큰 결정이다.&lt;/p>
&lt;p>잘못하면 에셋들의 헬파티가 열릴 수 있다!!&lt;/p>
&lt;p>&lt;img alt="unhappy" src="https://velog.velcdn.com/images/eugene-doobu/post/a163e808-bcf7-45a6-b561-a504cc92ffd0/image.png">&lt;/p>
&lt;h3 id="어드레서블-에셋-시스템">어드레서블 에셋 시스템&lt;/h3>
&lt;p>어드레서블 시스템은 &lt;strong>유니티 게임엔진&lt;/strong>에서 지원해주는 에셋 관리 시스템으로, 에셋에 특정 어드레스(에셋을 식별하는 키)를 부여하여 에셋을 로드할 수 있는 기능을 지원해주는 시스템이다. &amp;ldquo;어떠한 이름으로 특정 에셋을 불러온다&amp;quot;라는 기능자체는 매우 간단하지만, 어드레서블 시스템에는 이 외에도 기존 에셋 관리 시스템을 구성할때 가려웠던 부분들을 긁어주는 기능들을 포함하고 있다.&lt;/p>
&lt;ul>
&lt;li>내부적으로는 여전히 에셋번들 단위로 그룹핑하여 사용&lt;/li>
&lt;li>&amp;lsquo;어드레서블 그룹&amp;rsquo;단위로 에셋번들을 관리, 그룹단위로 세부 설정 가능&lt;/li>
&lt;li>에셋 관리 룰을 통한 전체 검사(에셋 의존성 관리도 가능)&lt;/li>
&lt;li>원하면 에셋들을 앱 빌드 자체에 포함 가능&lt;/li>
&lt;/ul>
&lt;h4 id="에셋-그룹-관리-지원">에셋 그룹 관리 지원&lt;/h4>
&lt;p>위에서 에셋번들을 사용하면 에셋을 그룹별로 깔끔하게 정리하기 힘들다고 했었다. 어드레서블을 이용하면 유니티 에디터 자체에서 &amp;lsquo;Addressables Groups&amp;rsquo; 윈도우를 통해 에셋들을 원하는 그룹으로 묶어서 쉽게 관리할 수가 있게 된다. 그리고 이렇게 관리된 그룹별로 각기 다른 에셋번들을 관리하기 위한 세부 설정을 할 수가 있게 된다. 아래 스크린샷이 그 예시이다.&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/e37815ec-bf34-4cec-a62c-e876ced07fc8/image.png" width="80%">
&lt;/center>
&lt;p>좌측의 윈도우는 현재 프로젝트에서 사용하고 있는 어드레서블 그룹의 목록이고, 우측의 &amp;lsquo;Inspector&amp;rsquo;윈도우는 현재 선택된 에셋 그룹에 대한 세부 설정을 나타내고 있는 윈도우이다.&lt;/p>
&lt;p>설정중 가장 이해하기 쉬운 것은 빨간 동그라미로 표시한 &amp;lsquo;Build &amp;amp; Load Paths&amp;rsquo;이며 이 에셋 번들을 빌드후 에셋번들을 저장할 위치와 이 에셋을 로드할 위치를 설정해주는 부분이다. 현재 &amp;lsquo;Local&amp;rsquo;로 설정된 있는 옵션을 &amp;lsquo;Remote&amp;rsquo;로 바꾸면 원하는 웹 저장소에 에셋을 저장하기 위한 설정을 할 수도 있다. 이를 통해 특정 에셋그룹은 로컬에 빌드하고, 특정 그룹은 원격 저장소에 빌드하는 등의 셋팅도 가능하다.&lt;/p>
&lt;p>현재 나인크로니클에서 사용되고 있는 어드레서블 그룹 목록이다. ActorPrefab, CharacterSpine, LocalAssets이라는 3개의 그룹으로 나뉘어져 있다.&lt;/p>
&lt;ul>
&lt;li>ActorPrefab: 현재 게임에 사용될 몬스터 오브젝트들을 관리하고 있는 그룹. 이 오브젝트들은 1개의 오브젝트가 1개의 에셋번들로 빌드되어 관리될 것이며, s3 클라우드 저장소에 에셋을 저장해 두었다가 클라이언트 빌드 없이 패치해서 사용할 수 있도록 구성을 할 것이기 때문에 Remote 저장소를 저장경로로 셋팅할 것 이다.&lt;/li>
&lt;li>CharacterSpine: 게임 내에 사용될 캐릭터의 장비 파츠들을 관리하는 그룹. ActorPrefab 그룹과 동일한 셋팅.&lt;/li>
&lt;li>LocalAssets: 빌드에 포함되어 프로젝트 내부에서 사용할 에셋들을 관리하는 그룹. 모든 에셋이 1개의 에셋번들로 묶여 거의 상시 메모리에 올라가 있는 에셋번들로 생각하고 있으며, 이처럼 프로젝트 내에서 상시 사용할 에셋들을 한개의 그룹으로 묶어서 어드레서블 그룹으로 관리한 이유는 위에서 이야기한 &amp;lsquo;에셋의 의존성을 관리&amp;rsquo;하여 중복 리소스 로드를 막기 위함이다.&lt;/li>
&lt;/ul>
&lt;h4 id="의존성-문제-해결">의존성 문제 해결&lt;/h4>
&lt;p>어드레서블은 패키지에서 제공해주는 툴로 동일한 에셋이 여러 에셋번들에 묶여있으면, 중복으로 로드될 수 있는 리소스를 별도의 번들로 묶어 이 리소스를 포함해야 하는 에셋들에게 &lt;strong>자신의 번들을 참조하게 하는 식으로 중복 리소스 로드 문제를 방지&lt;/strong>할 수 있다. 하지만 이와 같은 과정을 어드레서블에서 자동으로 진행해주는건 아니고, 별도의 툴을 통해 개발자가 쉽게 수정할 수 있도록 도와주는 방식이다. 이 툴을 통해 에셋의 의존성을 파악하고 중복 리소스가 로드되는 문제를 아래 프로젝트 소개 이후 직접 진행해볼 예정이다.&lt;/p>
&lt;h4 id="공통된-인터페이스">공통된 인터페이스&lt;/h4>
&lt;p>어드레서블은 에셋을 관리해주는 &amp;lsquo;공통된 인터페이스&amp;rsquo;를 제공해준다는 측면에서도 이득이 있다. 만약 팀에서 자체개발한 에셋 관리 툴을 사용하다보면, 다른 팀이나 회사의 에셋 관리 툴은 다른 구조, 다른 용어를 사용하여 구현될 가능성이 높은데, 이러면 새로운 에셋 관리 구조를 파악하는데 시간이 많이 들 수 있다. (그리고 이러한 툴들은 엄청난 하드코딩으로 구현되어 있을 가능성이 높다)&lt;/p>
&lt;p>이러한 이유로 기존 에셋번들을 관리하기 위한 복잡도를 어드레서블을 통해 크게 낮출 수 있다. 러닝커브가 있음에도 많은 팀이 어드레서블을 도입하려는 이유가 이런 것이며, 한번만 배워놓으면은 동일한 방식으로 여러 프로젝트의 에셋을 관리하기도 쉬울 것이다.&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/5b9ea29d-de80-4396-9155-1e43fce86777/image.png" width="30%">
&lt;/center>
&lt;p>(혹시 안 즐거우시다면 죄송합니다)&lt;/p>
&lt;h2 id="패치-시스템">패치 시스템&lt;/h2>
&lt;p>위에서 말했듯이 DLC를 통한 패치 시스템이 모바일 프로젝트의 에셋 관리에서 가장 핵심적인 부분이 될 가능성이 높다. 이미 패치 시스템이 도입된 다른 게임들을 예시로 그 이유를 알아보자.&lt;/p>
&lt;p>&lt;img alt="프커업뎃" src="https://velog.velcdn.com/images/eugene-doobu/post/16e88043-d629-48ed-b874-806831075476/image.png">&lt;/p>
&lt;figcaption style="text-align:center; font-size:15px; color:#808080; margin-top:40px">"게임 프린세스 커넥트! Re:Dive 추가 다운로드 팝업"&lt;/figcaption>
&lt;p>위 게임은 내가 몰래 숨어서 플레이하고 있는 미소녀 수집형 게임인 &amp;lsquo;프리코네&amp;rsquo;의 업데이트 팝업이다. 2024년 4월 18일 기준, iOS 앱스토어에 업로드 된 이 게임의 기본 크기는 &lt;strong>290.1MB&lt;/strong> 이정도는 &amp;lsquo;일반적인 서비스 어플&amp;rsquo;들보다 약간 큰 정도이다. 하지만 게임을 실제로 플레이하기 위해서는 추가적으로 10.73GB의 데이터를 다운로드 받아야 한다.&lt;/p>
&lt;p>이처럼 대부분의 모바일 게임들은 실제 앱스토어에는 앱을 구동시키기 위한 코드와 최소한의 에셋들만 포함되어있는 빌드파일을 올려놓고, 대부분의 핵심 에셋들은 별도로 다운받는 구조로 제작되어 있다. 위에 예시로 든 프리코네의 경우, 신규 캐릭터 획득시마다 그 캐릭터와 관련된 리소스나 게임 스토리를 보기 위한 리소스도 필요시마다 추가로 다운로드 하고 있어 실제로 게임 플레이를 하면서 다운받는 리소스의 양은 훨씬 많아질 수 있다.&lt;/p>
&lt;p>이렇게 외부에서 리소스를 다운 받는 이유는 다음과 같다.&lt;/p>
&lt;ol>
&lt;li>앱 스토어에서 보이는 앱 용량이 진입장벽으로 느껴질 수 있다.&lt;/li>
&lt;li>안드로이드는 apk로 앱을 업로드 시 150MB 이하로 유지해야 하는 전통이 있었다.&lt;/li>
&lt;li>그리고 패치 시스템을 이용하면 &lt;strong>번거로운 앱 심사 과정을 회피하고 업데이트&lt;/strong>를 할 수 있다&lt;/li>
&lt;/ol>
&lt;p>사실 개인적인 입장에서는 3번이 핵심이라고 생각한다. 게임개발을 하다 보면 추가로 빌드 과정을 진행하는 것도 엄청난 일이며 이를 앱스토어에 심사받고 정해진 기간까지 심사가 통과할지 기도하는 일도 회사 팀원들의 마음을 힘들게 한다. 이 과정은 많은 시간과 정성이 필요하며, 때로는 예상치 못한 심사 지연이나 거절 사유를 해결하기 위해 추가적인 노력(과 야근)이 필요할 수 있다.&lt;/p>
&lt;h3 id="앱-패치-심사">앱 패치 심사&lt;/h3>
&lt;pre tabindex="0">&lt;code>애플의 앱스토어 심사는 구글 마켓에 비해
까다롭고 오래 걸리는 것으로 유명합니다.
몇 시간 정도 걸리는 안드로이드 심사와 달리
애플 앱 심사는 약 일주일 정도 걸리는데요.
일주일을 기다린 앱 심사 결과가
거부(reject)면 재심사까지 더해 약 2주일,
한번 더 reject되면 3주까지 늘어나기도 하죠.
그렇기에 앱스토어 심사를 가장 빨리 통과하는
방법은 거부(reject)당하지 않는 거죠.
- 디스이즈게임, [카드뉴스] 거부를 거부한다! 앱스토어 심사에서 리젝당하지 않는 법
&lt;/code>&lt;/pre>&lt;p>&lt;a href="https://www.thisisgame.com/webzine/nboard/257/?n=61254?n">https://www.thisisgame.com/webzine/nboard/257/?n=61254?n&lt;/a>&lt;/p>
&lt;p>모바일게임을 만들고 앱 마켓에 등록하기 위해서는 필수적으로 심사 과정을 거쳐야 한다. 앱 심사는 대부분 첫 심사가 매우 까다롭고 이후 심사는 상대적으로 너그럽게 진행되는 편인 것 같다. 하지만 첫 심사가 아니라고 방심하면은 안 된다. 앱 심사 거절은 언제 어디서 일어날지 모른다.&lt;/p>
&lt;p>만약 코드 수정이 아닌 단순 리소스 수정이라면, 위와 같은 패치 시스템을 이용해서 앱 심사를 우회하고 바로 유저들에게 콘텐츠 업데이트를 할 수 있다. 한번 DLC 업데이트에 익숙해지고 나면, 단순 리소스 수정 같은 일로 하루 이상의 딜레이를 가질 수 있는 앱 심사 과정을 거쳐야 하는 것이 매우 번거로운 일로 느껴질 수 있을 것이다.&lt;/p>
&lt;p>나인크로니클에도 이러한 패치 시스템이 도입될 것으로 예상하며, 이러한 작업은 후에 진행한 후 따로 글을 작성해 볼 예정이다. 이에 대해서 당장 시도해본 내용은 아래 프로젝트 소개 후 녹화해둔 영상과 함께 이야기해보도록 하겠다.&lt;/p>
&lt;h3 id="ios-리소스-다운로드">iOS 리소스 다운로드&lt;/h3>
&lt;p>iOS의 경우 이러한 리소스 다운로드 정책에 대해 민감하게 심사를 진행하는 편이었다. 나는 과거 iOS에서 어플을 개발하여 업로드하고, 첫 심사를 통과하고 앱 관리를 해오다가 추후 외부 게임 리소스들을 어셋번들로 분리하고 다운로드해서 사용하는 DLC 구조를 구현한 적이 있었다. 그 이후 테스트를 마치고 앱 업데이트 요청을 진행했었는데, 이때 약 일주일 동안 고통스러운 리젝대응기간을 보냈던 기억이 있다. iOS 심사 지침을 확인해보자.&lt;/p>
&lt;hr>
&lt;p>&lt;strong>4.2 최소 기능&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>4.2.3&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>(i)&lt;/strong> 앱은 다른 앱을 설치할 필요 없이 단독으로 작동할 수 있어야 합니다.&lt;/li>
&lt;li>&lt;strong>(ii)&lt;/strong> 초기 실행 시 작동하기 위해 추가 리소스를 다운로드해야 하는 앱은 다운로드하기 전에 리소스 크기를 공개하고 사용자에게 승인을 요청해야 합니다.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="변경된-심사-지침220606-문서">변경된 심사 지침(22.06.06 문서)&lt;/h3>
&lt;ul>
&lt;li>4.2.3: 출시 초기에도 앱이 충분히 기능할 수 있도록 바이너리에 풍부한 콘텐츠가 있어야 한다는 요구 사항을 삭제했습니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>iOS에서 외부 리소스 다운로드와 관련된 조항은 바로 &amp;lsquo;&lt;strong>4.2 최소기능&lt;/strong>&amp;rsquo; 파트일 것이다. 먼저 맨 처음에는 사용자가 다운받는 리소스 크기를 명시하지 않고 리소스를 다운로드시켜서 리젝을 받았었다. 이에 대한 부분은 콘텐츠 다운로드를 위한 ok/cancel 팝업을 추가하고, 다운받을 리소스 용량을 표기하였다. 해결했다고 생각하고 다시 앱 심사를 진행했었다. 이후 저 삭제된 &amp;lsquo;4.2.3&amp;rsquo; 조항 때문에 엄청난 삽질을 거듭하다 통과했지만, 여기서 라떼이야기는 생략하도록 하겠다.&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/897cbef3-cbd8-4a26-a7a2-7ac28586c76a/image.png" width="20%">
&lt;/center>
&lt;h2 id="나인크로니클9c">나인크로니클(9C)&lt;/h2>
&lt;p>&lt;img alt="9c" src="https://velog.velcdn.com/images/eugene-doobu/post/06720c11-7d52-4fbd-b921-82560bedff34/image.png">&lt;/p>
&lt;p>요번 글에서 에셋 로드 구조를 개선할 게임은 오픈소스로 개발하고 서비스되고있는 풀 블록체인 기반의 2D RPG 게임인 &lt;a href="https://github.com/planetarium/NineChronicles">나인크로니클&lt;/a>이다. 풀 블록체인 기반 게임이라는 것이 핵심적이고 재미있는 특징이지만, 이번 시리즈에서는 에셋 로드와 관련된 클라이언트 영역에 대해서만 다룰 예정이다. 이 프로젝트는 오픈소스로써 실제로 작업한 내용들을 직접 확인해볼 수 있다. 이번 시리즈에서도 작업 PR의 링크를 달거나 코드 일부분을 글에 첨부해볼 예정이다.&lt;/p>
&lt;p>&lt;img alt="전투" src="https://velog.velcdn.com/images/eugene-doobu/post/14065f1b-139a-4627-8bff-b0a99c3bf7c2/image.png">&lt;/p>
&lt;p>나인크로니클은 기본적으로 스텟을 기반으로 한 전투 시뮬레이션 게임이다. 체인 위에 기록된 나의 캐릭터의 스텟과 스킬을 기반으로, 테이블 데이터에 기록된 스테이지의 몬스터와 랜덤을 기반으로 한 전투가 시뮬레이션 되며, 그 결과가 클라이언트에게 전송되어 전투 과정을 렌더링하여 위 스크린샷처럼 전투를 진행하게 된다.&lt;/p>
&lt;h3 id="어드레서블-패키지-적용">어드레서블 패키지 적용&lt;/h3>
&lt;p>먼저 사용되는 리소스 중 다른 기능들과 의존성이 적은 부분을 찾아서 먼저 적용해보고자 했다. 그중 많은 리소스를 사용하면서도 가장 독립적인 부분이 바로 &amp;lsquo;스테이지의 몬스터 리소스&amp;rsquo;라고 판단되어 해당 부분을 우선하여 어드레서블을 이용하여 로드하도록 분리하고, 리모트 다운로드 테스트까지 진행할 계획을 세웠다. 먼저 어드레서블 리소스를 관리하기 위한 리소스 매니저를 프로젝트에 추가하였다.&lt;/p>
&lt;h4 id="리소스-매니저">리소스 매니저&lt;/h4>
&lt;p>개인적인 경험상 에셋을 여러 스크립트에서 로드하고 릴리즈하는 과정을 진행하다 보면, 꼭 리소스가 제대로 관리되지 못하고 릴리즈되지 못하는 에셋들이 생기게 되는 것 같았다. 어드레서블에서 에셋은 레퍼런스 카운트를 기반으로 관리되며(c++의 스마트포인터를 생각하면 쉬울 것), 이 에셋의 핸들을 관리해주는게 가장 기본적인 요소 중 하나이다.
(레퍼런스카운트 관리 및 어드레서블의 자세한 내용은 나중에 별도의 글로 다뤄볼까 한다)&lt;/p>
&lt;p>나는 이러한 에셋 핸들과 레퍼런스 카운트 관리를 위하여 &lt;strong>ResourceManager&lt;/strong>를 구현해서 사용하는 것을 선호한다. 프로젝트마다 디테일한 에셋 로드/언로드 타이밍은 다르겠지만, 프로젝트 전역적으로 사용되는 소수의 에셋을 제외하고는 대부분의 에셋은 씬 전환 시 날려버려도 상관 없다고 생각하기에 씬이 바뀔 때마다 &lt;strong>ResourceManager&lt;/strong>에 캐시된 모든 에셋들을 날려주는 식으로 구현했다.&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/4725">https://github.com/planetarium/NineChronicles/pull/4725&lt;/a>&lt;/p>
&lt;h4 id="battle-renderer">Battle Renderer&lt;/h4>
&lt;p>구현된 리소스 매니저를 기반으로 에셋을 로드하는 시스템을 적용하였다. 자세한 작업 내용은 아래 PR의 Desription에 적어두었다. 나인크로니클의 전투가 턴 기반이라는 것을 생각해보면, 처음 전투를 시작할 때 현재 플레이어의 스텟과 도전하고자 하는 스테이지의 데이터를 기반으로 미리 전투를 시뮬레이션할 수 있으며, 이때 시뮬레이션 된 배틀을 렌더링할 때 필요한 리소스들을 긁어와 미리 로드해둘 수 있다.&lt;/p>
&lt;p>&lt;img alt="배틀로그" src="https://velog.velcdn.com/images/eugene-doobu/post/4d4cc089-4e69-49bd-8ac3-d4f5583d973a/image.png">&lt;/p>
&lt;p>위는 배틀 시작 시 클라이언트에서 받는 시뮬레이션 결과이며, SpawnWave이벤트 안에는 어떠한 몬스터가 스폰되는지에 대한 정보가 모두 담겨있다. 이를 통해 로딩 타이밍에 스폰될 몬스터 리소스들을 미리 로드하였다가 필요한 타이밍에 스폰하면, 클라이언트는 필요한 메모리만 올려서 사용하며 몬스터 생성 시 리소스를 메모리에 올리기 위한 부하(프레임드랍) 없이 게임을 진행할 수 있게 된다. 이러한 작업의 핵심 로직은 아래 스크립트에서 확인할 수 있다.&lt;/p>
&lt;p>// in &lt;strong>BattleRenderer.cs&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-cs" data-lang="cs">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">public&lt;/span> IEnumerator LoadStageResources(BattleLog battleLog)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ReleaseMonsterResources();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">yield&lt;/span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> LoadMonsterResources(battleLog.GetMonsterIds());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _onStageStart?.Invoke(battleLog);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// TODO: 필요한 것만 로드&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">private&lt;/span> IEnumerator LoadMonsterResources(HashSet&amp;lt;&lt;span style="color:#888;font-weight:bold">int&lt;/span>&amp;gt; monsterIds)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#888;font-weight:bold">var&lt;/span> resourceManager = ResourceManager.Instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">foreach&lt;/span> (&lt;span style="color:#888;font-weight:bold">var&lt;/span> monsterId &lt;span style="color:#080;font-weight:bold">in&lt;/span> monsterIds)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">yield&lt;/span> &lt;span style="color:#080;font-weight:bold">return&lt;/span> resourceManager.LoadAsync&amp;lt;GameObject&amp;gt;(monsterId.ToString()).ToCoroutine();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadedMonsterIds.Add(monsterId);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">void&lt;/span> ReleaseMonsterResources()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#888;font-weight:bold">var&lt;/span> resourceManager = ResourceManager.Instance;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">foreach&lt;/span> (&lt;span style="color:#888;font-weight:bold">var&lt;/span> loadedMonsterId &lt;span style="color:#080;font-weight:bold">in&lt;/span> loadedMonsterIds)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> resourceManager.Release(loadedMonsterId.ToString());
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> loadedMonsterIds.Clear();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol>
&lt;li>먼저 스테이지 시작 시 전투 시뮬레이션 결과를 불러와 렌더링에 필요한 모든 에셋목록을 긁어온다&lt;/li>
&lt;li>로드할 에셋들을 차례대로 비동기로 로드하며, 로딩이 끝날 때까지 로딩 UI를 출력한다&lt;/li>
&lt;li>모든 리소스 로드가 끝나면 OnStageStart 이벤트를 실행해 구독한 객체들에 메시지를 전송한다.&lt;/li>
&lt;li>스테이지가 끝나면 ReleaseMonsterResources 메서드로 모든 리소스를 해제해준다.&lt;/li>
&lt;/ol>
&lt;p>&lt;a href="https://github.com/planetarium/NineChronicles/pull/4736">https://github.com/planetarium/NineChronicles/pull/4736&lt;/a>&lt;/p>
&lt;h3 id="어드레서블-패키지를-적용하면-모든게-다-해결될까">어드레서블 패키지를 적용하면 모든게 다 해결될까?&lt;/h3>
&lt;p>그건 아니다. 패키지를 적용하더라도 에셋을 직접적으로 관리해주는 코드가 필요하다. 아까 에셋번들을 이야기하면서 결국 어떤 에셋들을 묶어서 사용할 것인지, 에셋을 언제 메모리에 올릴지 등에 대해 많은 관리 코드가 필요하다고 했는데 이건 어드레서블을 사용해도 근본적으로 해결되지 않는 영역이다. 어드레서블을 사용해도 결국 이러한 관리 코드가 필요하기 때문에, 굳이 러닝 커브가 있는 어드레서블을 사용하지 않고 순수 에셋번들만을 이용해서 프로젝트를 진행하는 때도 있다.&lt;/p>
&lt;p>하지만 앞으로 오랜 시간 게임개발자로 밥 벌어먹고 살고자 한다면 에셋 관리 시스템은 어드레서블로 해보는 것을 추천한다. 실제로 많은 팀에서 사용하고 있고, 사용하고 있지 않다면 도입을 고려하고 있는 팀들이 많아서 면접에서 단골로 물어보는 주제이기도 하다. 소형팀이든, 대형팀이든 이런 식으로 에셋 관리하는 구조를 구축해볼 경험이 있다면 좋은 가산점이 될 것이다.(그리고 이러한 주제가 일반적인 게임개발 취준생들이 쉽게 고려해보지 못하는 주제이기도 해서 좋은 점수를 받기 좋은 포인트라 생각한다.)&lt;/p>
&lt;h3 id="중복-사용-에셋-감지">중복 사용 에셋 감지&lt;/h3>
&lt;p>이는 어드레서블의 Analyze Rules중 &lt;strong>&amp;ldquo;Check Resources to Addressable Duplicate Dependencies&amp;rdquo;&lt;/strong> 기능을 통해 확인할 수 있다. 이 기능은 Unfixable Rules 중 하나로, 이는 어드레서블에서 툴을 통한 검사는 해주겠지만, 자동으로 고칠 수는 없어서 개선을 원한다면 개발자가 수동으로 작업해야 하는 분석 규칙임을 뜻한다. 현재 작업 중인 프로젝트에 이 규칙을 검사해보면..&lt;/p>
&lt;center>
&lt;img src ="https://velog.velcdn.com/images/eugene-doobu/post/d51f11b1-1517-4380-8c84-fd754c3f10e9/image.png" width="85%">
&lt;/center>
&lt;p>짜잔.. 위에서 말한 어드레서블에서 중복으로 로드될 수 있는 에셋들을 감지하는 툴을 통해 에셋을 검사해 본 결과이다. 현재 905개의 에셋에서 중복으로 로드될 수 있는 서브에셋들의 목록들이 나왔고, 우측에 표시된 숫자들은 이 에셋에서 중복 사용 중인 서브 에셋들의 개수를 나타낸다. 현재 보이는 스크린샷에서 한 에셋당 4개 정도의 서브에셋들이 중복으로 사용되고 있으니 대략 계산해서 3,600개의 서브 에셋들이 중복으로 로드될 수 있는 상황이라는 것이다.&lt;/p>
&lt;p>&lt;img alt="망곰울먹" src="https://velog.velcdn.com/images/eugene-doobu/post/5f8cd57f-ee28-48be-a606-79fdbd2a2819/image.png">&lt;/p>
&lt;p>이는 안타깝지만, 처음부터 어드레서블 에셋을 도입하여 사용하지 않아 생긴 부작용이라고도 볼 수 있다. 기존 레거시한 방식으로 다량의 에셋들이 관리되고 있었기에, 어드레서블로 관리되는 에셋이 일부분 생김에 따라 기존 어드레서블에서 관리되던 에셋과 연관성이 있던 서브 에셋들이 이처럼 중복 로드될 가능성이 있는 에셋으로 감지되는 것이다. 실제로 현재 감지된 duplicate dependencies의 파일 목록을 자세히 보면 경로가 ＇Assets/Resources..＇로 시작하는 것을 볼 수 있다. 이 경로에 있는 에셋들은 모두 레거시한 방법으로 빌드시 무조건 포함되는 에셋들에 해당한다.&lt;/p>
&lt;p>실제 라이브 서비스 중인 프로젝트이기도 하고, 관련해서 피쳐 작업들이 계속 진행되고 있기에 이러한 에셋들을 한번에 어드레서블로 관리되도록 수정하는 것은 거의 불가능에 가깝다고 생각한다. 따라서 단기적으로는 메모리에 중복으로 로드되는 에셋들이 많더라도 감수하고 개선 작업을 천천히 진행해야 할 것이다. 이것이 가능하면 어드레서블 에셋을 초기부터 도입해야 하는 이유 중 하나라고 볼 수 있다. 유니티 메뉴얼에도 아래와 같은 내용이 적혀있다.&lt;/p>
&lt;p>&lt;img alt="유니티 메뉴얼" src="https://velog.velcdn.com/images/eugene-doobu/post/e63c0556-2d00-481e-8744-96869d6e8f62/image.png">&lt;/p>
&lt;p>위 메뉴얼 링크: &lt;a href="https://docs.unity3d.com/kr/Packages/com.unity.addressables@1.21/manual/AddressableAssetsMigrationGuide.html">https://docs.unity3d.com/kr/Packages/com.unity.addressables@1.21/manual/AddressableAssetsMigrationGuide.html&lt;/a>&lt;/p>
&lt;h3 id="에셋-패치를-하려면">에셋 패치를 하려면?&lt;/h3>
&lt;p>에셋을 패치 하려면 유저들이 앱 실행 중 항상 접근할 수 있는 웹 서버에 사용할 에셋들을 업로드해야 한다. 나는 회사에서 적극 사용 중인 AWS에서 제공해주는 S3 버킷에 에셋을 업로드하고 게임에서 이를 로드해서 사용해보는 테스트를 하였다.&lt;/p>
&lt;div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
&lt;iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/6qXSP9vJ06s?autoplay=0&amp;controls=1&amp;end=0&amp;loop=0&amp;mute=0&amp;start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
>&lt;/iframe>
&lt;/div>
&lt;p>(위 영상에서 &amp;lsquo;바로 로드 안됨&amp;rsquo;이라고 나오는 부분의 문제는 해결했는데, 어이없게도 에셋 로드를 하고 로드가 완료되는 걸 기다리지 않고 오브젝트를 생성하고 있었다.)&lt;/p>
&lt;p>위 어드레서블의 장점에서 &amp;lsquo;Remote&amp;rsquo;로 에셋을 저장해주는 세팅을 하면 에셋이 원격 저장소에 저장된다고 말했다. 위 영상이 바로 &lt;strong>ActorPrefab&lt;/strong> 그룹을 Remote에 저장되도록 세팅하고 그 에셋들을 s 3원격 저장소에 올려서 사용하는 영상이다. 영상을 보면 알 수 있듯이, 어드레서블에서 제공해주는 기능만을 이용하면 프로젝트의 외딴곳에 에셋이 빌드되고 이를 수동으로 손으로 옮겨서 S3 버킷에 업로드해주는걸 볼 수 있을 것이다.&lt;/p>
&lt;p>또한 현재 클라이언트에 있는 에셋이 최신 에셋인지 파악하기 위해 해시 값들을 관리해야 하고, 이러한 해시 값을 관리해주는 카탈로그 개념에 대해 인지하고 있어야 한다. 이에 대한 경험과 자세한 설명들은 추후 DLC를 통한 패치 시스템에 대한 글을 쓸 때 다뤄보도록 하겠다.&lt;/p>
&lt;h3 id="에셋-로드-시스템을-바꾸는-겸-시스템-개편">에셋 로드 시스템을 바꾸는 겸 시스템 개편&lt;/h3>
&lt;p>또한, 에셋 로드 시스템을 어드레서블 패키지로 바꾸는 겸 기존의 에셋 로드 시스템들을 개선하고 있다. 이는 주로 메모리 관리와 관련된 부분으로, 이어서 바로 작성할 2번째 글인 &lt;strong>&amp;lsquo;메모리 사용 구조 개편&amp;rsquo;&lt;/strong> 에서 자세히 다뤄보도록 하겠다. 해당 글에서는 mac의 Xcode를 통해 앱을 프로파일링 하며 실제 메모리 사용량과 앱 용량까지 절감시키고 있는 이야기를 살펴볼 수 있을 것이다.&lt;/p>
&lt;h1 id="끝">끝&lt;/h1>
&lt;p>&lt;img alt="끝" src="https://velog.velcdn.com/images/eugene-doobu/post/6b5d1129-ee9d-4a2c-b206-de8783f5d974/image.png">&lt;/p>
&lt;p>&lt;a href="https://velog.io/@eugene-doobu/%EB%9D%BC%EC%9D%B4%EB%B8%8C-%EA%B2%8C%EC%9E%84-%EC%97%90%EC%85%8B-%EA%B4%80%EB%A6%AC-%EA%B0%9C%EC%84%A0%EA%B8%B0-1.%EC%96%B4%EB%93%9C%EB%A0%88%EC%84%9C%EB%B8%94-%EC%97%90%EC%85%8B-%EB%8F%84%EC%9E%85">블로그 원본&lt;/a>&lt;/p></content><author><name>홍유진</name><uri>https://github.com/eugene-doobu</uri><email>eugene@planetariumhq.com</email></author></entry><entry><title>Libplanet 4.0 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2024/03/libplanet-4.1.0/" title="Libplanet 4.0 릴리스"/><id>https://snack.planetarium.dev/kor/2024/03/libplanet-4.1.0/</id><published>2024-03-12T00:00:00+00:00</published><updated>2024-03-12T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 네 번째 메이저 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/4.0.0">4.0 버전&lt;/a>이
릴리스되었습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&lt;/p>
&lt;p>이번 버전부터 Libplanet은 상태를 조금 더 효율적으로 다루기 위해, 여러 &lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.State.Account.html">Account&lt;/a>
를 다룰 수 있는 &lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.State.World.html">World&lt;/a> 를 도입하였고, 버전 마이그레이션을 큰 문제 없이 할 수 있도록
여러 API를 제공하고 있습니다.&lt;/p>
&lt;p>이 글에서는 4.0 버전의 주요 변경 사항들에 대해서 다루겠습니다.&lt;/p>
&lt;h2 id="여러-sub-state-를-들-수-있게-된-libplanet">여러 Sub-state 를 들 수 있게 된 Libplanet&lt;/h2>
&lt;p>그동안 Libplanet 은 단 하나의 상태 저장소 만을 가질 수 있었습니다. 이는 초기 개발에는 복잡한
&lt;code>Sub-state&lt;/code> 유도 과정 등을 생략하고, 하나의 공유 데이터를 사용함으로써 많은 이점을 가질 수 있었습니다.&lt;/p>
&lt;p>하지만 게임의 규모가 커짐에 따라, 한 Address 가 여러 상태 모델을 가지고 싶어하는 상황이 생겼습니다.
Libplanet 은 그동안 해당 Address 로부터 유도 된 새로운 Address 에 모델을 저장하는 방식을 채택하였습니다.
그래프로 그리면 다음과 같습니다.&lt;/p>
&lt;pre class="mermaid">flowchart LR
A[User Address] -->|"Derive(User, 'Avatar')"| B[Avatar Address]
A --> |"Get(User Address)"| S[Storage]
B --> |"Get(Avatar Address)"| S
&lt;/pre>
&lt;p>이는 한 스토리지에 여러 데이터를 저장하게 되어 성능이나 권한 문제에서 자유로울 수 없었습니다.&lt;/p>
&lt;p>이런 문제를 해결하기 위해, Libplanet 은 기존의 하나 밖에 없던 &lt;a href="https://docs.libplanet.io/3.6.0/api/Libplanet.Action.State.Account.html">&lt;code>Account&lt;/code>&lt;/a>를
&lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.State.IWorldState.html#Libplanet_Action_State_IWorldState_Legacy">&lt;code>World.Legacy&lt;/code>&lt;/a> 로 만들고, &lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.State.IWorld.html">&lt;code>World&lt;/code>&lt;/a> 밑에 여러 &lt;a href="https://docs.libplanet.io/3.6.0/api/Libplanet.Action.State.Account.html">&lt;code>Account&lt;/code>&lt;/a> 를 가질 수 있게 하였습니다.&lt;/p>
&lt;pre class="mermaid">flowchart LR
A[User Address] --> |"Get(User)"| S1["Avatar Storage"]
A[User Address] --> |"Get(User)"| S2["Agent Storage"]
S1 --> Avatar
S2 --> Agent
&lt;/pre>
&lt;p>이런 문제로, 이전과 같이 직접적으로 &lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.IActionContext.html#Libplanet_Action_IActionContext_PreviousState">&lt;code>IActionContext.PreviousState&lt;/code>&lt;/a> 혹은
&lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.IActionEvaluation.html#Libplanet_Action_IActionEvaluation_OutputState">&lt;code>IActionEvaluation.OutputState&lt;/code>&lt;/a>로부터 데이터를 읽어 올 수는 없습니다. 따라서
&lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Execute_Libplanet_Action_IActionContext_">&lt;code>IAction.Execute()&lt;/code>&lt;/a>안에서의 API 는 다음과 같이 변경됩니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>IWorld world = context.PreviousState
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IAccount avatarAccount = world.GetAccount(&lt;span style="color:#080;font-weight:bold">new&lt;/span> Address(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;0x0000000000000000&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IValue avatarList = avatarAccount.GetState(context.Signer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IAccount agentAccount = world.GetAccount(&lt;span style="color:#080;font-weight:bold">new&lt;/span> Address(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;0x0000000000000001&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IValue agent = agentAccount.GetState(context.Signer)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>각 도메인에 맞는 &lt;code>Account&lt;/code> 를 가져오는 점에 주의하십시오.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 외에도 여러 성능 개선이나 자잘한 마이너 패치가 있었습니다. 자세한 내용은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/4.0.0">전체 변경 내용&lt;/a> 에서 확인해 주세요.&lt;/p>
&lt;p>질문이나 관심이 있으신 분들은 또한 저희 &lt;a href="https://discord.gg/YaHPjcrdrw">Discord&lt;/a> 채널에 놀러와 주세요!&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>온체인 게임의 미해결 과제 (번역)</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2023/08/paradigm-onchain-game-kr-translation/" title="온체인 게임의 미해결 과제 (번역)"/><id>https://snack.planetarium.dev/kor/2023/08/paradigm-onchain-game-kr-translation/</id><published>2023-08-24T00:00:00+00:00</published><updated>2023-08-24T00:00:00+00:00</updated><content type="html">&lt;p>크립토 업계의 대표 벤처캐피탈 &lt;a href="https://paradigm.xyz">패러다임(Paradigm)&lt;/a>이 지난 8월 14일에 공유한, 온체인 게임이 나아갈 방향과 그 과정에서 고민할만한 점을 다룬 글이 공감되어 한국어로 번역해보았습니다.&lt;/p>
&lt;p>원문: &lt;a href="https://www.paradigm.xyz/2023/08/onchain-games">The Open Problems of Onchain Games&lt;/a>&lt;/p>
&lt;p>저자: &lt;a href="https://www.paradigm.xyz/team/charlienoyes">Charlie Noyes (General Partner)&lt;/a>, &lt;a href="https://www.paradigm.xyz/team/dougfeagin">Doug Feagin (Investment Partner)&lt;/a>&lt;/p>
&lt;h1 id="목차">목차&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#창발emergence을-이끌어내기-위한-설계">창발을 이끌어내기 위한 설계&lt;/a>
&lt;ul>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#모드mods">모드&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#개방된-경제-구조">개방된 경제 구조&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#온체인-게임">온체인 게임&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#미해결-과제">미해결 과제&lt;/a>
&lt;ul>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#기술적-제약들이-게임-디자인을-제한한다">기술적 제약들이 게임 디자인을 제한한다.&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#조합-가능성은-태생적으로-금융화로-이어진다">조합 가능성은 태생적으로 금융화로 이어진다.&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#메타게임은-침체-되기-마련이다">메타게임은 침체 되기 마련이다.&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#게임은-완전히-온체인이어야-하는가">게임은 완전히 온체인이어야 하는가&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#결론">결론&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#감사의-말">감사의 말&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>게임과 크립토가 교차하는 지점엔 가능성이 많아 보입니다. 비탈릭이 월드 오브 워크래프트에서 흑마법사를 플레이 하던 중 &lt;a href="https://about.me/vitalikbuterin">너프를 먹고 이더리움을 만들기로 마음 먹었다&lt;/a>는 건 유명한 일화이죠. 와우는 핵심 인프라는 아니었지만, 가상 세계가 앞으로 대규모의 자산을 저장하고 일자리를 제공하는 핵심 인프라가 될 것이라는 예상은 많은 사람들이 하고 있습니다. 그런 세계가 몇몇 중앙화된 플랫폼에 의해 지배될 것이라는 건 상상하기 어렵습니다.&lt;/p>
&lt;p>물론, 탈중앙화 어플리케이션은 이론 상 훌륭하게 들립니다. 그 중 가장 매력적인 부분은 크립토이기 때문에 가능해지는 것들이죠. 바로 온체인에서만 생겨날 수 있는 어플리케이션들 말입니다. 하지만 그동안 여러 내러티브가 등장하고 사라졌음에도 불구하고, 오직 온체인 게임만이 할 수 있는게 무엇인지 정확히 파악하기는 어려운 상황입니다.&lt;/p>
&lt;p>&lt;em>도대체 왜 게임을 블록체인에 올리나요?&lt;/em>&lt;/p>
&lt;p>이 질문에 대한 저희의 생각을 이 포스팅에 정리해보았습니다.&lt;/p>
&lt;h1 id="창발emergence을-이끌어내기-위한-설계">창발(emergence)을 이끌어내기 위한 설계&lt;/h1>
&lt;p>몇몇 게임은 창의적인 플레이어들이 새로운 컨텐츠(“UGC”)를 직접 만들 수 있는 툴을 제공함으로써 플레이어들이 더 오래 게임에 머물게 만들었습니다. UGC의 가장 큰 원천인 모드와 개방된 경제 구조는 온체인 게임이 앞서 나갈 가능성이 있는 “공격 벡터”입니다.&lt;/p>
&lt;h2 id="모드mods">모드(Mods)&lt;/h2>
&lt;p>모드란 서드 파티 개발자들이 게임의 원작자가 의도한 범위를 넘어서는 컨텐츠를 만들 수 있게 해주는 것을 말합니다. 새로운 장르를 개척한 게임 중 여럿(예: 도타, 롤, 펍지)이 다른 게임의 모딩된 버전에서 시작되었습니다. 로블록스 같은 게임들은 게임 자체를 모드 개발자 플랫폼으로 바꿔버리기도 했습니다. 게임 스튜디오들은 완성품의 가치(품질)을 중시하지만, 활발한 모더 커뮤니티는 다양성과 참신함을 중시하죠. 넷플릭스와 유튜브처럼요.&lt;/p>
&lt;p>마인크래프트는 아주 좋은 예시입니다. 게임 메카닉이 단순해 이것저것 만들어보기 좋죠. 그 메카닉을 확장하는 모드들은 서로 합쳐져서 새로운 경험을 만들어내기도 합니다. 탈옥이나 배틀로얄 같은 유명한 마인크래프트 서버들은 오리지널 마인크래프트랑은 완전히 다르죠.&lt;/p>
&lt;p>그러나 그런 마인크래프트도 한계를 갖고 있습니다. 이미 존재하는 서버에는 플레이어들이 모드를 추가할 수 없다는 점입니다. 무언가 변경하려면 서버를 새로 만들어야 합니다. 그 결과, 마인크래프트 “유니버스”는 수많은 병렬적인, 교류가 없는(non-interacting) 프라이빗 서버들로 쪼개져 있습니다.&lt;/p>
&lt;p>많은 게임들이 모딩을 구현할 때 이미 존재하는 시스템의 스크립트를 수정하는 방식이 아니라 마인크래프트처럼 새 서버를 띄우는 방식(instancing)으로 하는 데에는 여러 그럴만한 이유가 있습니다. 플레이어들이 추가한 코드가 게임의 기본 규칙들과 잘 호환되도록 하는 건 어려운 일입니다. 그게 취약점을 공격하는 코드라면 특히 문제이죠. 기본 규칙을 업데이트 하는 경우엔 이미 올라와 있는 모드들을 고장 낼 수도 있구요. 한정된 연산 자원도 똑똑하게 배분되어야 합니다.&lt;/p>
&lt;p>하지만 서버를 새로 띄우는 방식은 파편화로 이어집니다. 새 서버로 띄워진 모드들은 플레이어들의 관심을 받기 위해 다른 모든 서버들과 경쟁을 하게 됩니다. 모더들은 단순히 어떤걸 추가하면 재밌을지 고민하는 대신, 변경 사항이 새 서버를 만들만큼 가치가 있는지를 고민해야 하죠.&lt;/p>
&lt;p>많은 모드 아이디어들이 이미 존재하는 세계에 무언가를 추가한다는 &lt;em>컨텍스트 안에서만&lt;/em> 말이 된다는 점을 생각해보세요. 당신이 어떤 마인크래프트 서버에서 식당을 운영 중인데 새 메뉴를 추가하고 싶다고 가정해보죠. 이런 상황에서 새 서버를 띄운다는 건 말이 안됩니다. 손님들이 새 서버로 옮겨오도록 설득해야 하는데, 그 손님들도 이미 이 서버에 시간과 돈을 투자해 확보한 자산과 고객들이 있으니 옮기지 않을 것이기 때문이죠.&lt;/p>
&lt;p>게임 세계가 파편화되면, 확장을 점진적으로 할 수 있는 능력을 잃어버립니다.&lt;/p>
&lt;h2 id="개방된-경제-구조">개방된 경제 구조&lt;/h2>
&lt;p>게임 내 경제는 플레이어의 창의력 측면에서 거의 무한한 잠재력을 가진 또다른 차원입니다. 여기선 최초로 전업 경제학자를 직원으로 채용했던 최초의 게임인 이브 온라인을 가지고 설명해보겠습니다.&lt;/p>
&lt;p>이브 온라인 플레이어들은 게임 내 시스템과 외부 인프라를 비공식적으로 조합하여 물건을 생산하고 거래하고, 영역을 획득하고 빌려주고 소유권 경쟁을 벌이며, 산업 공동체부터 전쟁광 집단까지 다양한 조직을 만듭니다. 자원 운송 같이 단순한 임무들은 해당 임무 수행을 위해 만들어져 &lt;a href="http://www.pushx.net/">플레이어들에 의해 운영되는 기업&lt;/a>들이 있는데, 그 기업들은 고객 응대, 서비스 사용 계약, 피고용인을 위한 복리후생제도까지 완벽히 갖춰져 있습니다.&lt;/p>
&lt;p>플레이어들은 개발사로부터 제공되는 새로운 컨텐츠 때문이 아니라, 또다른 플레이어들에 의해 수많은 사건이 벌어지는 사회 경제적 세계 때문에 20년 넘게 이브온라인을 플레이하고 있습니다.&lt;/p>
&lt;p>그러나 이런 이브 온라인의 경제 시스템조차도 큰 한계를 갖고 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>한정된 게임 내 기초 요소&lt;/strong>: 개발사에 의해 정의된 기초 요소의 범위를 벗어나는 거래(예: 대여 계약)는 비공식적인, 강제 집행이 불가능한 신뢰 기반 네트워크에 의존해야 합니다. 그런 신뢰는 창발적인 경제 구조의 복잡성과 규모를 제한합니다.&lt;/li>
&lt;li>&lt;strong>규제 측면의 제약&lt;/strong>: 규제 관련 고민을 피하기 위해, 이브 온라인을 포함한 대부분의 게임들이 게임 내 재화나 서비스를 현금(fiat)으로 교환하는 것을 금지합니다. 이를 허용하는 게임들은 부담스런 조건에 동의하는 경우에만 현금 거래를 허용하며, 이를 위해 대규모의 준법 부서를 운영해야 합니다.&lt;/li>
&lt;/ul>
&lt;h1 id="온체인-게임">온체인 게임&lt;/h1>
&lt;p>크립토 네이티브 게임은 여러가지 형태를 가질 수 있습니다. 저희는 가장 크립토 네이티브한, 스펙트럼의 끝 부분에 있는 &lt;em>완전 온체인 게임(fully onchain game)&lt;/em> 에 관심을 갖고 있습니다. 오픈된 스마트 컨트랙트 플랫폼에 상태값과 로직이 전부 올라가 있는 형태 말이죠.&lt;/p>
&lt;p>온체인 게임 모드들이 자체 컨트랙트의 형태로 특별한 허가 없이 기본 게임 로직들과 함께 배포될 수 있는 것도 중요합니다. 사용자가 자신의 클라이언트에서 실행할 모드를 선택할 수 있는 것(관리자가 모드를 정하는게 아니라)도 중요합니다.&lt;/p>
&lt;p>그래서, &lt;em>왜 게임을 블록체인에 올리죠?&lt;/em> 저희는 다음의 두가지 포인트가 핵심이라고 생각합니다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>조합 가능한 모딩(composable modding)&lt;/strong>: 플레이어는 온체인 게임에 허가를 받거나 상태값을 파편화시키는 일 없이 모드를 추가할 수 있습니다. 온체인 인프라와 스마트 컨트랙트 개발자들은 누구나 허가 없이 코드를 업로드 할 수 있게 하기 위한 것들에 이미 익숙합니다. 보안 감사, 권한 관리, 자원 미터링 같은 것들이죠. 기존 게임들은 이런 환경이 도입되어있지 않고, 그들이 조합 가능한 모딩을 지원하기 위해 스스로 구조를 재편할 것 같진 않습니다.&lt;/li>
&lt;li>&lt;strong>무허가형 개방 경제(permissionless open economies)&lt;/strong>: 게임 개발자가 정의한 게임 내 기초 요소에 의해 제한되거나, 비공식적이고 강제 집행이 불가능한 계약에 의존하는 대신, 플레이어들은 게임 경제를 만들기 위해 스마트 컨트랙트를 사용할 수 있습니다. 게다가 게임 자산을 플레이어가 스스로 수탁하는 구조는 규제 준수 관련 부담을 없애주죠.&lt;/li>
&lt;/ol>
&lt;p>어쩌면 조합 가능한 모딩은 온체인 게임에 의해 가능한 “고유 특성”이라기보다, 경로 의존적인 혁신일지도 모릅니다. 기존 게임들은 조합 가능한 모딩을 지금도 지원할 수 있음에도 현재 지원하고 있지 않으며, 딱히 그걸 바꿀만한 인센티브도 없습니다. 이 모델은 그럴 필요가 있을 때에만 연구 될 것입니다 (즉, 크립토에서 말이죠).&lt;/p>
&lt;p>조합 가능한 모딩과 무허가형 경제의 조합이야말로 대규모의 창발적인 온체인 게임 세계를 만들어낼 수 있습니다. 모더들은 단순한 기본 규칙 조합들을 가져다 새로운 모드 컨텐츠로 확장합니다. 그들은 현금 거래 시장에 대한 접근성, 디파이 시장과의 가까운 거리, 실험할 수 있는 자유를 얻을 것입니다. 그 결과로 나타나는 경제는 매우 복잡할 것이며, 축적되는 컨텐츠를 생성하도록 반사적으로 인센티브를 부여할 것입니다. 실제로 거기서 돈이 벌린다는게 명확해지는 순간, 다른 크립토 어플리케이션 생태계를 탄생시켰던것과 동일한 투기-실험 사이클(speculation-experimentation cycle)을 거치며 활동이 폭발적으로 증가할 것입니다.&lt;/p>
&lt;p>대부분의 온체인 게임 논의는 그런 희망찬 미래를 상세히 그리곤 합니다. 저희는 그 곳까지 도달하는 과정에 어떤 것들이 있을지에 더 관심이 많습니다. 대규모 게임 세계가 등장할만한 상황이 되기 위해 먼저 해결되어야 하는 과제들 말이죠.&lt;/p>
&lt;h1 id="미해결-과제">미해결 과제&lt;/h1>
&lt;h2 id="기술적-제약들이-게임-디자인을-제한한다">기술적 제약들이 게임 디자인을 제한한다.&lt;/h2>
&lt;p>온체인 게임이 아직 성공하지 못한 이유에 대한 일반적인 추측은, 기술 인프라가 아직 갖춰지지 않았기 때문에 대부분의 게임이 개념 증명(proof-of-concept) 단계를 벗어나지 못했다는 것입니다. 그렇기 때문에 게임 플레이는 단순하고, 클라이언트는 버그가 많으며, 게이머들과 모드 개발자들의 참여도는 지지부진한 상태를 유지하고 있다는 것이죠.&lt;/p>
&lt;p>현재의 인프라와 개발 툴들은 한계가 있습니다. 특히 EVM은 느리고 낡았고, 현재의 솔리디티 데이터 모델은 복잡한 게임 개발에 적합하지 않으며, 어느 메인넷 체인도 게임을 배포하기에는 적합하지 않습니다 (높은 비용과 낮은 성능을 고려하면요).&lt;/p>
&lt;p>다행히도, 이 문제들의 대부분이 해결되어가는 모습이 보이고 있습니다. 크립토 커뮤니티는 롤업의 확장 가능성과 비용 감소 추세를 이미 분명히 느끼고 있습니다. 게임에 특화된 인프라를 만드는 팀도 다수 존재합니다. 예를들면, &lt;a href="https://lattice.xyz/">Lattice&lt;/a>는 EVM 게임 개발을 단순화 하는, 솔리디티 프레임워크와 호환 가능한 툴링 (인덱싱, 상태 동기화 등)을 개발하고 있습니다. &lt;a href="https://www.dojoengine.org/">Dojo&lt;/a>, &lt;a href="https://argus.gg/">Argus&lt;/a>, &lt;a href="https://github.com/curio-research/keystone">Curio&lt;/a> 등도 인프라 플랫폼을 개발 중입니다.&lt;/p>
&lt;p>어쩌면 온체인 게임의 본질적인 측면에서는 다른 문제들이 더 중요하다고 느껴질지도 모르겠습니다. 특히, 무허가형 블록체인의 특정 요소들은 핵심적인 게임 디자인 메카닉과 배치되기도 합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>불완전한 정보&lt;/strong>: 불완전한 정보는 많은 게임에서 핵심적인 메카닉입니다. 현존하는 블록체인 상에서의 해법들은 수용하기 어려운 단점들을 가지고 있습니다 (예: 다크포레스트의 &lt;a href="https://dev-guides.zkga.me/mining/what-is-mining">암호학적 전장의 안개&lt;/a>는 하드웨어 채굴 경쟁으로 귀결됩니다)&lt;/li>
&lt;li>&lt;strong>자동화 &amp;amp; 담합&lt;/strong>: 근본적으로 막을 수 없습니다. 봇은 실제 플레이어와 구분이 불가능하며, 각 플레이어가 고유하다는 것을 보장할 수 없습니다(역자주: 한 명이 여러 캐릭터를 플레이 할 수 있습니다). 게임 개발자는 봇 메타나 시빌 담합(역자주: 한 명이 플레이하는 여러 캐릭터가 담합하는 행위)에도 무너지지 않는 게임을 만들어야만 합니다.&lt;/li>
&lt;li>&lt;strong>틱 시스템&lt;/strong>: 블록체인은 비동기적인 트랜잭션으로 운영됩니다. 대부분의 게임들은 플레이어의 행동과 무관하게 돌아가는 게임 내부의 틱 기반 루프에 따라 동작합니다.&lt;/li>
&lt;/ul>
&lt;p>이 세가지 제약들로 인해 오히려 창의력이 발휘되어 그동안 없던 새로운 형태의 게임 종류가 등장할 수도 있습니다. 기존 금융의 형태를 흉내내지 않고 디파이에서 독자적으로 등장한 MakerDAO나 Uniswap처럼 말이죠. 하지만 게임은 기술적인 측면과 규제적인 측면에서 겪어왔던 제약사항이 금융 대비 적기 때문에 이미 금융보다 더 넓은 영역을 탐색해보았고, 따라서 완전히 새로운 온체인 게임이 등장할 가능성은 낮아 보입니다. 저희는 온체인 게임이 크게 성공할 가능성을 확보하기 위해서는 이러한 제약사항들로부터 발전이 필요할 것이라고 생각합니다.&lt;/p>
&lt;h3 id="연구-방향">연구 방향&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>TEE&lt;/strong>: 목적 대비 과분한 것일 수 있지만, 신뢰 실행 환경(Trusted Execution Environment, TEE)은 퍼블릭 블록체인에서 무허가 형태로 비공개 연산을 수행하기 위한 유일한 현실적인 선택지입니다.&lt;/li>
&lt;li>&lt;strong>MACI&lt;/strong>: &lt;a href="https://ethresear.ch/t/minimal-anti-collusion-infrastructure/5413">당초 온체인 투표 시스템에서의 담합 방지를 위해 비탈릭 부테린에 의해 제안된 매커니즘(Minimal Anti-collusion Infrastructure)&lt;/a>인 MACI는 온체인 게임에 적용될 수 있을 것이며 적합한 게임 시스템이 있다면 긴밀하게 통합되어 개선될 가능성도 있습니다.&lt;/li>
&lt;li>&lt;strong>커스텀 롤업&lt;/strong>: 상태 전환 함수의 일부로 글로벌 틱이 포함되도록 롤업을 변경함으로써 기존 게임의 틱 루프를 (가스비 없이) 온체인에서 구현하는 것도 가능해 보입니다. 이런 식으로 각 게임의 요건에 맞게 변경이 진행되는 것도 흥미로울 것 같습니다.&lt;/li>
&lt;/ul>
&lt;p>비공개 상태값을 위해 영지식증명을 활용하는 것도 또다른 연구 방향입니다. 하지만 저희는 영지식증명으로 수행할 수 있는 프로그래밍 불가능한 비공개성(non-programmable privacy)이 유의미한 게임 메카닉을 구현하기 충분할지에 대해 회의적입니다. 현재 기준으로 회로 작성이 어렵다는 점 역시 사용을 어렵게 만드는 부분이구요.&lt;/p>
&lt;h2 id="조합-가능성은-태생적으로-금융화로-이어진다">조합 가능성은 태생적으로 금융화로 이어진다.&lt;/h2>
&lt;blockquote>
&lt;p>완전히 외부에 공개되어 있어 누구나 사용할 수 있는 시스템이라면, 인센티브는 단순히 “제안”이 아닙니다. 인센티브는 중력이나 엔트로피같은 물리 법칙에 더 가깝죠. 만약 시스템에 인센티브와 맞지 않는 부분이 있다면, 공격 당하는 것은 시간 문제입니다. (&lt;em>Nikolai Mushegian, &lt;a href="https://bank.dev/principles">bank.dev/principles&lt;/a>&lt;/em>)&lt;/p>
&lt;/blockquote>
&lt;p>스마트 컨트랙트 블록체인은 매우 적대적이며 모든 것을 금융화하는 환경입니다. 이 특성은 디젠(degen) 문화로 인해 경로 의존적으로 나타난 것이 아닙니다. 허가 없이 조합할 수 있다는 특성으로 인해 나타난 기계적인 결과이죠. 어플리케이션들이 조합 가능성을 전제로 하는 한, 온체인 게임은 이런 인센티브에 기초 요소 수준부터 노출될 수 밖에 없습니다.&lt;/p>
&lt;p>모드의 영향력 같은 것을 고려하기 전의 “진공 상태”에서부터, 온체인 게임 개발자들은 현금 거래 시장, MEV(프론트러닝 인센티브), 경제적 공격(착취)을 피할 수 없다는 사실과 씨름해야 할 것입니다. 인센티브를 안전하게 적용할 수 있는 온체인 게임을 만들기 위해 넘어야 하는 장벽은 꽤나 높을 것입니다. 안전한 디파이 프로덕트를 개발하는 것만큼이나요.&lt;/p>
&lt;p>2차적으로 발생하는 문제는 더욱 까다롭습니다. 온체인 게임은 모딩 되도록 설계되고, 모드들은 자체적인 인센티브 구조를 가질 것입니다. 게임의 핵심 인센티브를 관리하는데 능숙한 개발자 조차도 그 게임 위에 어떤 모드가 만들어질지, 어떤 인센티브 구조가 추가될지 알 수 없는 것입니다. (이런 예측 불가능한 창발성을 이끌어내는 것이 원래 그들의 목표이지만요)&lt;/p>
&lt;p>또다른 디파이 비유를 해보죠. 어떤 오라클을 하나 생각해봅시다. 이 오라클은 외부와 차단된 진공 상태에서는 (오라클을 조작 하더라도 이익이 나지 않는) 안전한 경제 구조를 가질지도 모릅니다. 하지만 어떤 어플리케이션이 오라클을 연동하고 사용할지는 예상할 수 없습니다. 만약 대출 프로토콜이 청산을 호출하기 위해 오라클을 사용하는 경우, 오라클을 조작할 인센티브가 생기게 됩니다. 자주, 심각하게요. 비슷한 예로, 어떤 마인크래프트 모드가 블록을 먼저 채굴하기 위해 MEV 인센티브를 도입하면, 이는 모든 플레이어들의 게임 플레이에 영향을 줄 것입니다. 심지어 그 모드를 적용하지 않은 클라이언트도 영향을 받겠지요.&lt;/p>
&lt;p>이는 고치기 어려운 문제입니다. 특정 개발자들만 모드를 개발할 수 있도록 허가하고 나머지는 제한하려는 시도는 창발성을 최대한 끌어내려는 노력과 직접적으로 배치되는 일입니다. 그게 바로 온체인 게임을 만드는 가장 큰 이유인데 말이죠.&lt;/p>
&lt;p>저희는 온체인 게임 디자인에 있어, 인센티브 구조를 자유롭게 붙일 수 있도록 만드는 것이 가장 큰 난관이 될 것이라고 생각합니다. 몇몇 게임들은 규제 준수에 따른 부담 때문에 현금 거래 시장을 피합니다. 한편 더 많은 다른 게임들은, 그냥 현금 거래 시장과 연동하는게 재미 없다고 생각해서 하지 않습니다. 온체인 게임은 금융화 압박에 소비되어버리지 않으면서 금융화 압박을 레버리지 할 수 있는 방법을 찾아야 할 것입니다.&lt;/p>
&lt;h3 id="연구-방향-1">연구 방향&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>부서지지 않는 게임 디자인&lt;/strong>: 핵심 게임 메카닉은 그 위에 어떤 모드가 생길지를 결정하는 게 아니라, 영향을 줄 수 있습니다. 시스템에 도움이 되는 모드들이 생기도록 하려면 어떤 온체인 게임이어야 하는지는 아직 확인되지 않았습니다. 어떤 종류의 게임 시스템이 N차 인센티브에 의한 오염으로부터 안전한지도 마찬가지이죠.&lt;/li>
&lt;li>&lt;strong>허가&lt;/strong>: 금융화를 직접적으로 저해하는 방법은 누가 온체인 게임을 플레이 할 수 있는지, 누가 새 코드를 덧붙일 수 있는지를 제한하는 것입니다. 창발성과는 명백한 트레이드 오프가 존재하지만, 거친 무허가 세계에 게임을 내보내기 전에 울타리 안에서 테스트를 해보는 것이 필요할지도 모릅니다. 그러면서 (단순한 화이트리스팅 이상으로) 어떻게 허가를 부여하면 좋을지도 배울 수 있을 것입니다.&lt;/li>
&lt;li>&lt;strong>오더 플로우 경매&lt;/strong>: 창발적인 인센티브를 막으려고 노력하는 대신 이를 활용하는 방법도 있습니다. 예를 들면, 모든 게임 트랜잭션이 오더 플로우 경매(order flow auction)를 거치게 하고, 그 수익금을 게임의 경제 수도꼭지으로 보내는 것이죠. 모드에 의해 만들어진 모든 가치들은 게임의 경제로 다시 돌아갈 것입니다 (예: 희귀한 물품을 재구매함으로써). 하지만 그러한 근본적인 동작들은 여전히 게임 플레이를 저해할 수도 있을 것입니다 (즉, 플레이어들은 태양을 운영하기 위한 석탄 탄광이 되는 셈입니다). (역자주: &lt;a href="https://writings.flashbots.net/order-flow-auctions-and-centralisation">오더 플로우 및 경매에 대한 플래시봇 팀의 글&lt;/a>)&lt;/li>
&lt;/ul>
&lt;h2 id="메타게임은-침체-되기-마련이다">메타게임은 침체 되기 마련이다.&lt;/h2>
&lt;p>온체인 게임은 필연적으로 기존 게임보다 더 긴 릴리즈 사이클을 가질 것입니다. 창발성을 최대화 하고 싶은데, 잦은 브레이킹 업데이트(역자주: 기존 프로그램들과 충돌이 날 수 있는 변경)는 창작자들이 그 세계에 기여하고 투자하려는 의욕을 꺾기 때문입니다. 업데이트를 하려면 보안 감사도 다시 받아야 합니다. 또한 많은 온체인 게임 개발자들은 무허가적인 “자치성(autonomy)” - 어드민 키와 업데이트가 없고 영원히 존재하는 구조 - 을 목표로 하기도 합니다.&lt;/p>
&lt;p>따라서 기술적인, 철학적인 이유로 온체인 게임은 자치성의 스펙트럼에서 “영원히 업데이트 없음” 과 “종종 업데이트 함” 의 사이 어딘가에 있을 것입니다.&lt;/p>
&lt;p>극단적으로 자치적인 온체인 게임의 가장 잘 된 케이스는 적절한 기본 규칙들이 적극적인 모더 커뮤니티와 끊임없는 창발적인 경험을 이끌어내는 형태일 것입니다. 어쩌면 수십년 동안 사람의 손이 닿지 않아야 가능해지는 경험들이 만들어질 수도 있을 것입니다.&lt;/p>
&lt;p>하지만 대부분의 게임들은 메타게임의 침체를 막기 위해 관리 운영되곤 합니다. 플레이어들은 기존 게임들에서 최적의 전략을 매우 잘 찾아 왔습니다. 게다가 MEV는 이에 대해 추가적인, 명시적인 인센티브를 제공하게 됩니다. 이런 최적 전략들은 게임을 정적으로 만들고, 재미 없게 만드는 경향이 있습니다. 정말 자치적인 세계는 메타게임을 제어하는 능력을 잃게 됩니다 - 비탈릭은 어쩌면 그의 (너프먹은) 흑마법사 캐릭터에 대해 잘못된 걱정을 했을지도 모르는 거죠.&lt;/p>
&lt;p>저희는 가장 중요한 질문은 내부적인 디자인 목표와 관련된게 아니라 이것이라고 생각합니다: 성공적인 온체인 게임은 어느 정도까지 자치적일 수 있는가?&lt;/p>
&lt;h3 id="연구-방향-2">연구 방향&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>계절성(seasonality)&lt;/strong>: 많은 기존 게임들은 수개월에서 수년(와우 확장팩 같은) 주기로 업데이트를 진행합니다. 업데이트 주기는 창작자들이 향후에 동작하지 않을 수도 있는 복잡한 모드를 만들 의욕을 꺾을 수 있다는 점과 트레이드오프가 존재합니다. 저희는 이런 방식이 반복 실험 측면에서 더 가능성 있는 방법이 될 수 있다고 생각합니다(역자주: 온체인 게임에 맞는 업데이트 주기를 찾아야 한다는 의미로 보입니다).&lt;/li>
&lt;li>&lt;strong>자동 피드백 시스템&lt;/strong>: 비트코인이 해시레이트에 맞춰 채굴 난이도를 자동 조절하는 것처럼, 온체인 게임도 침체 방지용 조정 매커니즘을 내부에 가질 수도 있을 것입니다. 이는 온체인 게임에만 국한된 얘기는 아닙니다. 중앙화된 게임들은 이걸 더 강력하게 적용할 수 있습니다. 하지만 온체인 게임은 이것이 “필요하기 때문에” 혁신을 만들어낼 수 있을 것입니다.&lt;/li>
&lt;li>&lt;strong>독창적인 거버넌스 매커니즘&lt;/strong>: 저희는 기본적으로 &lt;a href="https://fehrsam.xyz/blog/governance-minimization">거버넌스 미니멀리스트&lt;/a>입니다만, 토큰 기반이 아닌 시스템에서 탐색해볼만한 흥미로운 지점이 있을 수 있다고 생각합니다. 새로운 규칙을 만드는 능력 자체를 게임의 핵심 루프 안에 넣을 수도 있을 것입니다 (예: &lt;a href="https://en.wikipedia.org/wiki/Mao_(card_game)">Mao&lt;/a>). 이미 시도된 케이스도 존재합니다. 예를 들면, Topology는 &lt;a href="https://topology.substack.com/p/topology-presents-isaac">특화된 거버넌스 시스템을 온체인 게임 Isaac에 타이트하게 통합시켰습니다.&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="게임은-완전히-온체인이어야-하는가">게임은 완전히 온체인이어야 하는가&lt;/h1>
&lt;p>허가 없이 조합 가능한 특성을 우아하게 레버리지한, 쉽게 접근할 수 있는 온체인 게임 디자인이 있을지도 모릅니다. 이런 세계는 오픈된 경제적인 인센티브가 새로운 컨텐츠의 끊임없는 생산을 유도함으로써 성장하고, 검열 당하지 않으며 검증 가능하게 중립적인 블록체인 위에 영원히 존재할 수 있겠지요.&lt;/p>
&lt;p>하지만 어쩌면 앞서 언급한 (사소하지 않은) 미해결 과제들을 해결하려는 행위를 정당화할 만큼의 실현 가능성은 없을지도 모릅니다. 또한, 기존 금융과는 다르게, 게임은 언제나 매우 실험적이었습니다. 따라서 일반적인 온체인 게임이 그 존재가치를 증명하기 위해 달성해야 하는 목표는 아이러니하게도 디파이보다 높아 보입니다. 디파이는 기존에 닫혀있던 시장을 다룬 것이기 때문이죠.&lt;/p>
&lt;p>만약 완전 온체인 게임이 어렵다면, 온체인 게임을 기대해야 하는 이유들을 좀 “덜 온체인스런” 방법으로 설명할 수도 있을 것입니다. 그런 게임들은 스마트 컨트랙트를 최소한으로 사용하거나, 아예 사용하지 않을 수도 있습니다. 오프체인 게임 인프라를 사용한 NFT 자산들과, 디파이와의 상호운용성이 적절한 현실적인 지점일지도 모릅니다. 특히 만약 오프체인 게임의 요소들이 온체인 자산들에 의해 제어된다면, 그 자산에 대한 스마트 컨트랙트 기반의 관리 시스템 만으로도 충분히 강력할 것입니다.&lt;/p>
&lt;p>마지막으로, 게임이 완전 온체인이 되건 되지 않건, 그 과정에서 탐색하는 패턴들 - 특히 조합 가능한 모딩 - 은 기존 게임 디자인 측면에서도 혁신을 만들어낼 수 있을 것입니다. 기존 스튜디오들이 가능성을 보고 유의미한 자원을 투자해 모드의 조합이 가능하도록 오프체인 엔진을 수정할지도 모르는 일입니다. 온체인 게임과 잠재적으로 함께 존재하거나, 능가하거나, 그 정신을 계승한 형태로요.&lt;/p>
&lt;h1 id="결론">결론&lt;/h1>
&lt;p>많은 난관이 있다는 것을 알고 있지만, 저희는 온체인 게임이 블록체인을 레버리지 함으로써 이상하고 독창적인 결과물을 만들어 낼 것이라고 직감하고 있습니다.&lt;/p>
&lt;p>저희는 다른 빌더들과 크립토 네이티브 게임의 모든 최전선을 함께 탐색하기를 기대합니다. 또한 인프라보다는 게임 자체를 만드는 것에 관심이 더 많습니다. 우리가 직접 즐길 수 있는 게임을요.&lt;/p>
&lt;p>이런 이야기에 흥미가 있으시다면, 여기로 연락주시기 바랍니다: {charlie,doug}@paradigm.xyz&lt;/p>
&lt;h1 id="감사의-말">감사의 말&lt;/h1>
&lt;p>이 글을 작성하기 위해 여러 시간을 기여해 준 동료 &lt;a href="https://twitter.com/transmissions11">t11s&lt;/a>에 감사 드리며, 함께 논의하고 리뷰 해 준 &lt;a href="https://twitter.com/matthuang">Matt Huang&lt;/a>, &lt;a href="https://twitter.com/danrobinson">Dan Robinson&lt;/a>, &lt;a href="https://twitter.com/_Dave__White_">Dave White&lt;/a>, &lt;a href="https://twitter.com/FrankieIsLost">Frankie&lt;/a>에게도 감사 드립니다.&lt;/p>
&lt;p>피드백을 준 &lt;a href="https://twitter.com/DangerWillRobin">Will Robinson&lt;/a>, &lt;a href="https://twitter.com/guiltygyoza">GuiltyGyzoa&lt;/a>, &lt;a href="https://twitter.com/nagual_ape">Rafael Morado&lt;/a>, &lt;a href="https://twitter.com/smsunarto">Scott Sunarto&lt;/a>, &lt;a href="https://twitter.com/bertcmiller">Robert Miller&lt;/a>, &lt;a href="https://twitter.com/0xhank">0xhank&lt;/a> 에게 감사드리며, 함께 논의 한 &lt;a href="https://twitter.com/l_udens">Ludens&lt;/a>, &lt;a href="https://twitter.com/phildaian">Phil Daian&lt;/a>, &lt;a href="https://twitter.com/jtguibas">John Guibas&lt;/a>, &lt;a href="https://twitter.com/ArthurRoingBaer">Arthur Roeing Bear&lt;/a>, &lt;a href="https://twitter.com/hilmarveigar">Hilmar Veigar Pétursson&lt;/a> 에게도 감사의 말을 전합니다.&lt;/p></content><author><name>이로운</name><uri>https://github.com/lounlee</uri><email>loun@planetariumhq.com</email></author></entry><entry><title>Libplanet PBFT 전환 제 0화 - 왜 PBFT로 전환을 시작했나요?</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2023/04/pbft-0/" title="Libplanet PBFT 전환 제 0화 - 왜 PBFT로 전환을 시작했나요?"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2023/04/pbft-0/" hreflang="en" title="Libplanet PBFT Transitioner Episode 0 - Why did you switch to PBFT?"/><link rel="alternate" href="https://snack.planetarium.dev/1/01/pbft-0/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2023/04/pbft-0/</id><published>2023-04-24T00:00:00+00:00</published><updated>2023-04-24T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. Planetarium 에서 블록체인 디비전의 Libplanet 팀으로 근무하고 있는 이수호라고 합니다. 오늘은 Libplanet이 PBFT로 전환하게 된 계기와 그 과정에 대해 설명하는 글의 첫 번째 에피소드를 이야기하고자 합니다. 이 블로그 글에서는 Libplanet 블록체인의 합의 변경 과정, 변경 이유, 구체적인 변경 내용 및 새로운 합의 알고리즘의 이점에 대해 논의하겠습니다.&lt;/p>
&lt;h2 id="소개">소개&lt;/h2>
&lt;p>블록체인 기술은 혁신을 이루고 있으며, Libplanet은 주요 블록체인 엔진 중 하나입니다. &lt;code>Libplanet&lt;/code>은 .NET 플랫폼으로 구축된 고도로 확장 가능하고 탈중앙화된 오픈소스 플랫폼입니다. 이 플랫폼은 독특한 합의 알고리즘을 사용하여 네트워크 무결성을 보장하며, 높은 효율성과 안정성을 갖추고 있습니다.&lt;/p>
&lt;h2 id="nine-chronicles에-대해-이야기해-보겠습니다">Nine Chronicles에 대해 이야기해 보겠습니다.&lt;/h2>
&lt;p>2020년 이후 Nine Chronicles의 블록 생성 진화에 대한 이야기를 먼저 해 보고자 합니다. 처음에는 참여자들이 문제를 해결하는 &amp;ldquo;작업 증명(PoW)&amp;rdquo; 방법을 사용했었는데, 해결한 문제가 가장 어려우면서 짧은 시간 내에 해결한 블록이 선택되는 방식이었습니다. 그러나 이 방식에는 두 가지 큰 문제점이 있었습니다.&lt;/p>
&lt;ol>
&lt;li>가장 어려운 문제를 해결한 개인이 전체 커뮤니티에 이익이 되는 결정을 내릴 것임을 보장할 수 없었습니다. 경우에 따라 데이터가 포함되지 않은 블록이 생성되었으며, 문제가 더 어려울 경우 그것을 수용해야 했습니다.&lt;/li>
&lt;li>더 어려운 문제가 해결되고 총 난이도가 높은 블록이 생성되면, 이전 데이터가 변경될 수 있으므로 이상적이지 않았습니다.&lt;/li>
&lt;/ol>
&lt;p>이러한 문제로 인해 블록에 데이터가 없는 경우와 게임 진행의 롤백 등 게임 경험에 부정적인 영향을 미쳤습니다. 이에 따라, 2021년에는 Planetarium에서 Nine Chronicles의 Canonical chain 이 되기 위한 블록으로써 우리 자신이 만든 블록만 인정하기로 결정했습니다.&lt;/p>
&lt;p>그러나 우리는 Nine Chronicles에서 블록을 결정하는 유일한 권한을 가지고 싶지는 않았습니다. 우리의 초기 제안인 &lt;a href="https://docs.google.com/document/d/1ErZ5JQia03KqXRG6IRZ7SORfnxMLZfJg4patVKFGX5Y/edit#heading=h.sx6b2al62sji_">NCIP-10&lt;/a>은 여러 가지 이유로 결코 실현되지 않았습니다. 하지만 우리는 포기하지 않고 &lt;a href="https://docs.google.com/document/d/1L8d3KyO_Z6_BYcmDeMs-yv_SBYiEHiq_4kT0CjBmlFY">NCIP-13&lt;/a>을 제시하고 이를 확립했습니다. 2023년부터 PBFT 및 미래의 개발은 NCIP-13에 기반하여 이루어지며, 블록 생성 및 관리에 대한 더 강력하고 효과적인 접근 방식을 보장합니다.&lt;/p>
&lt;h2 id="블록체인-게임에서-작업-증명의-문제점">블록체인 게임에서 작업 증명의 문제점&lt;/h2>
&lt;p>Libplanet 팀으로서, 블록체인 게임에서 네트워크 보안과 효율성을 보장하는 것이 중요하다는 것을 이해하고 있습니다. PoW를 합의 알고리즘으로 계속 사용하는 것이 최종성 및 체인 전환과 관련된 문제로 인해 내 외부에서 많은 걱정을 만들어 왔다는 것을 알고 있습니다.&lt;/p>
&lt;p>PoW의 종국성(Finality) 부족은 네트워크에서 거래가 즉시 확인되지 않을 수 있으며, 포크 가능성이 항상 존재하므로 체인 재구성(Re-organization)이 발생할 수 있습니다. 이로 인해 이전에 확인된 거래가 확인되지 않게 되어 체인을 보는 다양한 서비스에 문제가 발생할 수 있습니다.&lt;/p>
&lt;p>특히 작은 체인에서 체인 전환은 PoW의 또 다른 중요한 문제입니다. 작은 체인에서는 손쉽게 더 어려운 문제를 풀어 체인을 원하는 대로 재구성 할 수 있었으며 이는 게임 플레이의 지연 및 사용자 경험에 부정적인 영향을 미칠 수 있습니다.&lt;/p>
&lt;p>Libplanet 팀에서는 이러한 우려를 심각하게 받아들이고 있으며, 더 나은 사용자 경험을 제공하기 위해 보다 효율적이고 안전한 합의 알고리즘, 특히 위임형 작업 증명(DPoS) 합의 알고리즘으로 전환하는 작업을 진행하고 있습니다.&lt;/p>
&lt;p>DPoS를 채택함으로써 우리는 더 나은 최종성 보장을 제공하고 체인 전환 관련 문제를 피할 수 있습니다. DPoS는 이해관계자들이 대리인을 선출하여 그들을 대신해 거래를 검증하는 합의 알고리즘입니다. 이 시스템은 PoW보다 효율적이며, 채굴자가 복잡한 수학적 문제를 해결해야 하거나 여러 노드가 동일한 거래를 검증해야 하는 필요성을 피합니다. 대신 이해관계자들은 대리인을 선출하여 그들이 거래를 검증할 책임을 지게 됩니다.&lt;/p>
&lt;p>하지만 바로 DPoS로 전환하는 것은 많은 수고가 듭니다. 단순히 합의 알고리즘만을 변경하는 것이 아니라, PoW에서는 신경쓰지 않아도 되었던 요금 징수 체계나 위임자 분배 알고리즘 등을 구현해야 하기 때문입니다.&lt;/p>
&lt;p>따라서 저희는, Practical Byzantine Fault Tolerance (PBFT)를 거쳐 DPoS로 전환하기로 결정하였습니다.&lt;/p>
&lt;h2 id="실용적인-비잔틴-장애-허용practical-byzantine-fault-tolerance-pbft">실용적인 비잔틴 장애 허용(Practical Byzantine Fault Tolerance, PBFT)&lt;/h2>
&lt;p>PBFT는 일부 노드가 실패하거나 악의적으로 동작하는 경우에도 네트워크가 합의에 도달할 수 있는 비잔틴 장애 허용 합의 알고리즘입니다. PoW와는 다르게, Validator를 선정하고 그들 사이에서 블록 생성과 투표 과정을 거쳐 체인이 진행됩니다.&lt;/p>
&lt;p>하지만, PBFT만을 가지고는 퍼블릭 블록체인을 달성할 수는 없습니다. 이 Validator 들을 관리할 수 있는 개인 혹은 단체가 존재해야 하고, 이는 곧 체인의 중앙화로 이어지기 때문입니다.&lt;/p>
&lt;p>따라서 이 Validator 를 규칙에 맞게 선출하고, 더 많은 기여를 한 개인 혹은 단체가 체인 합의에 더 많은 영향을 끼칠 수 있는 알고리즘이 바로 Delegated Proof of Stake(DPoS) 입니다.&lt;/p>
&lt;h2 id="위임형-작업-증명delegated-proof-of-stake-dpos">위임형 작업 증명(Delegated Proof of Stake, DPoS)&lt;/h2>
&lt;p>위임형 작업 증명(DPoS) 합의 알고리즘은 체인에 참여하는 사용자들이 대리인(Delegator)을 선출하여 그들을 대신해 거래를 검증하고, 대리인은 그 보상을 받아가는 방식으로, PBFT가 가진 중앙화 문제를 피할 수 있습니다.&lt;/p>
&lt;p>이를 달성하게 되면 Libplanet 블록체인의 합의 변경 과정은 민주적이며, 커뮤니티가 합의 알고리즘 선택 과정에 참여할 수 있도록 보장합니다. 이것은 네트워크가 계속 발전하도록 보장하기 위해 플랫폼을 지속적으로 개선함으로써 더욱 더 미래 지향적이게 만듭니다.&lt;/p>
&lt;h2 id="libplanet-블록체인-합의-변경-과정의-이점">Libplanet 블록체인 합의 변경 과정의 이점&lt;/h2>
&lt;p>Libplanet 블록체인 합의 변경 과정에는 여러 가지 이점이 있습니다.&lt;/p>
&lt;p>첫째, 네트워크 보안과 효율성을 보장합니다. 더 효율적이고 안전한 합의 알고리즘으로 전환함으로써 Libplanet 팀은 네트워크가 더 많은 거래를 처리하고 안전하게 유지될 수 있도록 보장합니다.&lt;/p>
&lt;p>둘째, 민주적입니다. 커뮤니티는 합의 알고리즘 선택 과정에 참여할 수 있으며, DPoS를 채택함으로써 네트워크는 사용하는 사람들에 의해 통치됩니다. 중앙 집중적인 권위가 아니라 사용자들이 통치하는 시스템입니다.&lt;/p>
&lt;p>마지막으로, 합의 변경 과정은 Libplanet 블록체인이 계속해서 관련성을 유지할 수 있도록 보장합니다. 플랫폼을 지속적으로 개선함으로써 Libplanet 팀은 계속 변화하는 블록체인 환경에서 경쟁력을 유지합니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>Libplanet 팀은 모든 사용자들에게 더 나은 블록체인 게임 경험을 제공하기 위해 노력하고 있습니다. Delegated Proof of Stake (DPoS) 합의 알고리즘으로 전환함으로써 더 나은 최종성 보장을 제공하고 체인 전환 관련 문제를 피할 수 있습니다. DPoS는 이해관계자들이 검증 과정에 참여할 수 있도록 하여 PoW나 Practical Byzantine Fault Tolerance (PBFT)보다 더 민주적인 시스템입니다. 하지만 바로 DPoS로 합의 알고리즘을 변경하기에는 여러 고려할 점이 많으므로 PBFT로의 전환을 우선하기로 결정하였습니다.&lt;/p>
&lt;h2 id="다음-이야기">다음 이야기&lt;/h2>
&lt;p>PoW -&amp;gt; PBFT를 전환하면서 고려해야 했던 것들에 대해 이야기하도록 하겠습니다.&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>페타바이트 트래픽 원인 분석기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2023/03/cloudwatch/" title="페타바이트 트래픽 원인 분석기"/><link rel="alternate" href="https://snack.planetarium.dev/1/01/cloudwatch/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2023/03/cloudwatch/</id><published>2023-03-15T00:00:00+00:00</published><updated>2023-03-15T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요, Nine Corparation, 게임 디비전에서 DX Engineer로 근무하고 있는 moreal입니다. 이 글에서는 작년 이맘때 회사에서 발견한 문제를 디버깅한 경험을 공유하려고 합니다.&lt;/p>
&lt;h2 id="대시보드에-보이는-이상한-단위">대시보드에 보이는 이상한 단위&lt;/h2>
&lt;p>회사에서는 운영하는 서비스의 상태를 확인하고 주의 사항을 공유하기 위한 주간 미팅을 진행합니다. 서비스는 EKS를 사용하고 있으며, 상태 확인을 위해 AWS CloudWatch Container Insights를 활용하고 있습니다. 그런데 어느 날 대시보드를 확인하다 이상한 수치들을 발견했습니다.&lt;/p>
&lt;p>&lt;img src="https://velog.velcdn.com/images/moreal/post/3165dcad-605a-4e2d-8ad0-fd083993608d/image.png">&lt;/p>
&lt;p>Y축의 단위를 보니 1.67 페타바이트가 표시되어 있었습니다.&lt;/p>
&lt;p>&lt;img src="https://velog.velcdn.com/images/moreal/post/47432dd2-f78e-4724-8608-7721c09ad165/image.png">&lt;/p>
&lt;p>최대 값은 400 페타바이트에 이르렀습니다. 🙀&lt;/p>
&lt;p>여러 가지 추측을 해봤지만, 원인을 찾기 위해 CloudWatch가 어떻게 메트릭을 수집하는지 알아보기로 했습니다.&lt;/p>
&lt;h2 id="cloudwatch가-메트릭을-수집하는-방법">CloudWatch가 메트릭을 수집하는 방법&lt;/h2>
&lt;p>CloudWatch 메트릭 수집 방법을 알아보기 위해, 오픈소스로 공개된 &lt;a href="https://github.com/aws/amazon-cloudwatch-agent">aws/amazon-cloudwatch-agent&lt;/a> 저장소를 참조했습니다.&lt;/p>
&lt;p>&lt;code>amazon-cloudwatch-agent&lt;/code>는 Kubernetes에서 사용하는 cAdvisor를 활용합니다. cAdvisor는 컨테이너에서 사용하는 리소스와 퍼포먼스 메트릭을 제공합니다. 이 값들을 활용하여 메트릭 값을 계산합니다.&lt;/p>
&lt;p>계산 로직은 아래와 같습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>netIfceMetric[NetRxBytes] = &lt;span style="color:#038">float64&lt;/span>(cur.RxBytes-pre.RxBytes) / &lt;span style="color:#038">float64&lt;/span>(deltaCTimeInNano) * &lt;span style="color:#038">float64&lt;/span>(time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>netIfceMetric[NetTxBytes] = &lt;span style="color:#038">float64&lt;/span>(cur.TxBytes-pre.TxBytes) / &lt;span style="color:#038">float64&lt;/span>(deltaCTimeInNano) * &lt;span style="color:#038">float64&lt;/span>(time.Second)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/google/cadvisor/blob/648b12f8db47171ebd0fc45c67d53574ddb017fe/info/v1/container.go#L418-L437">&lt;code>cur.RxBytes&lt;/code>&lt;/a>의 데이터 타입이 &lt;code>uint64&lt;/code>여서 언더플로우가 발생할 가능성이 있었습니다. 과도한 트래픽이 발생하는 경우를 확인하기 위해 로그를 출력하는 부분이 있었고, 실제 값도 확인할 수 있었습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">if&lt;/span> netIfceMetric[NetRxBytes] &amp;gt; oneTerabytes || netIfceMetric[NetTxBytes] &amp;gt; oneTerabytes {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#06b;font-weight:bold">Printf&lt;/span>(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;I! Too Big value for network RX/TX bytes, final Rx:%v, final Tx:%v, curRx:%v, preRx:%v, curTx:%v, preTx:%v, deltaCTimeInNano:%v&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> netIfceMetric[NetRxBytes], netIfceMetric[NetTxBytes],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur.RxBytes, pre.RxBytes,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur.TxBytes, pre.TxBytes,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deltaCTimeInNano)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>2022-04-08T08:18:17Z I! Too Big value for network RX/TX bytes, final Rx:3.1837731352719405e+17, final Tx:3.183773135286772e+17, curRx:692608, preRx:317669466, curTx:11946450, preTx:242992298, deltaCTimeInNano:57939882302
&lt;/code>&lt;/pre>&lt;p>Go Playground에서 코드를 실행하면 아래와 같은 결과가 나옵니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// https://play.golang.com/p/KppWhxtTtad
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">func&lt;/span> &lt;span style="color:#06b;font-weight:bold">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> curRxBytes &lt;span style="color:#888;font-weight:bold">uint64&lt;/span> = &lt;span style="color:#00d;font-weight:bold">692608&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> preRxBytes &lt;span style="color:#888;font-weight:bold">uint64&lt;/span> = &lt;span style="color:#00d;font-weight:bold">317669466&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> deltaCTimeInNano &lt;span style="color:#888;font-weight:bold">int64&lt;/span> = &lt;span style="color:#00d;font-weight:bold">57939882302&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> rxBytes = &lt;span style="color:#038">float64&lt;/span>(curRxBytes-preRxBytes) / &lt;span style="color:#038">float64&lt;/span>(deltaCTimeInNano) * &lt;span style="color:#038">float64&lt;/span>(time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06b;font-weight:bold">Printf&lt;/span>(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;%v&amp;#34;&lt;/span>, rxBytes)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#888">// output = 3.1837731352719405e+17
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>3.1837731352719405e+17&lt;/code> 와 같은 값을 얻을 수 있고, 이 값을 Python에서 확인하면 원래 CloudWatch Container Insight에서 본 페타바이트 값이 나옵니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#038">int&lt;/span>(&lt;span style="color:#00d;font-weight:bold">3.1837731352719405e+17&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00d;font-weight:bold">318377313527194048&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#038">int&lt;/span>(&lt;span style="color:#00d;font-weight:bold">3.1837731352719405e+17&lt;/span>) // (&lt;span style="color:#00d;font-weight:bold">1024&lt;/span> ** &lt;span style="color:#00d;font-weight:bold">5&lt;/span>) &lt;span style="color:#888"># KB MB GB TB PB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00d;font-weight:bold">282&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>cAdvisor는 &lt;code>/proc/&amp;lt;pid&amp;gt;/net/dev&lt;/code>에서 프로세스의 네트워크 관련 메트릭들을 가져오는데, 프로세스가 실행되면서 값이 누적되고, 재시작하면 다시 0부터 시작합니다. 그래서 Pod를 내리고 다시 올릴 때, 같은 컨테이너 이름의 경우 이전 값보다 현재 값이 더 작아지면서 언더플로우 버그가 발생한 것으로 이해할 수 있었습니다.&lt;/p>
&lt;p>이 문제와 관련하여 Helm이나 다른 예제에서 Pod 이름이 항상 다른 것과 관련이 있는지는 아직 확실하지 않습니다. 🤔&lt;/p>
&lt;h4 id="여담">여담&lt;/h4>
&lt;ul>
&lt;li>다행히 요금에 큰 문제가 발생하는 문제는 아니었습니다 💭&lt;/li>
&lt;li>아직도 발생하는 문제입니다. 🙀&lt;/li>
&lt;li>ChatGPT에게 한 번 정리해달라고 해봤는데 괜찮은 것 같습니다. 👀&lt;/li>
&lt;/ul></content><author><name>이도건</name><uri>https://github.com/moreal</uri><email>dogeon@planetariumhq.com</email></author></entry><entry><title>Serilog를 통해 애플리케이션 데이터를 수집하고 분석하자</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2023/03/serilog/" title="Serilog를 통해 애플리케이션 데이터를 수집하고 분석하자"/><link rel="alternate" href="https://snack.planetarium.dev/1/01/serilog/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2023/03/serilog/</id><published>2023-03-03T00:00:00+00:00</published><updated>2023-03-03T00:00:00+00:00</updated><content type="html">&lt;h1 id="들어가며">들어가며&lt;/h1>
&lt;p>분산 네트워크나 마이크로서비스 아키텍처 상에서는 각 어플리케이션 간의 로그를 수집하고, 어플리케이션 간의 로그를 짝 맞춰야 할 일이 종종 있습니다.
이 글에서는 Serilog 와 S3를 이용하여 로그를 수집하고, 이를 Athena나 다른 로그 서치 엔진에 응용할 수 있는 방법을 안내하고자 합니다.&lt;/p>
&lt;h1 id="구조화-된-로그structured-log">구조화 된 로그(Structured Log)&lt;/h1>
&lt;p>프로그래밍 경험이 좀 되신 분들이라면 &lt;a href="https://cloud.google.com/logging/docs/structured-logging?hl=ko">구조화 된 로그&lt;/a>에 대해 들어보셨을 것입니다.
구조화 된 로그는, 어떤 로그의 내용이 어떤 의미를 가지는지를 명확하게 표현하는 것을 말합니다.
예를 들어, 다음과 같은 로그가 있다고 가정해봅시다.&lt;/p>
&lt;pre tabindex="0">&lt;code>2023-03-03 12:00:00.0000000 [INFO] [User] [suho.lee] [Login] [Success]
&lt;/code>&lt;/pre>&lt;p>이 로그를 보면, 2021년 3월 3일 12시에 suho.lee라는 사용자가 로그인에 성공했다는 것을 알 수 있습니다.
하지만, 이 로그는 어떤 로그인인지, 어떤 서비스에서 로그인을 시도했는지, 로그인에 성공했는지 실패했는지 등의 정보를 알 수 없습니다.
이러한 로그는, 로그를 분석하거나, 로그를 수집하여 다른 시스템에 전달할 때, 어떤 로그인지, 어떤 서비스에서 로그인을 시도했는지 등의 정보를 알 수 없기 때문에, 의미가 없습니다.&lt;/p>
&lt;p>때문에 로그를 구조화 된 로그로 작성하는 것이 중요합니다.
구조화 된 로그의 예시는 다음과 같습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2023-03-03 12:00:00.0000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;level&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;INFO&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;service&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;User&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;user&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;suho.lee&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;action&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Login&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;result&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Success&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Serilog는 이런 형태의 구조화 된 로그를 쉽게 작성할 수 있도록 도와주는 라이브러리입니다.&lt;/p>
&lt;h1 id="serilog">Serilog&lt;/h1>
&lt;p>다른 언어와 마찬가지로, C#에서도 로그를 작성하는 라이브러리가 많이 있습니다.
Serilog는 이 중 하나입니다.
Serilog는 다음과 같은 특징을 가지고 있습니다.&lt;/p>
&lt;ul>
&lt;li>Sink를 통해 다양한 로그 저장소에 로그를 저장할 수 있습니다.&lt;/li>
&lt;li>한 가지 로그에 대해 여러 표현법을 지원합니다.&lt;/li>
&lt;li>로그를 작성하는 코드에 영향을 주지 않고, 로그를 수집하는 코드를 변경할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;h1 id="serilog를-이용한-로그-작성">Serilog를 이용한 로그 작성&lt;/h1>
&lt;p>Serilog를 이용하여 로그를 작성하는 방법은 다음과 같습니다.&lt;/p>
&lt;ol>
&lt;li>Serilog 패키지를 설치합니다.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>dotnet add package Serilog
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>Serilog를 초기화합니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888;font-weight:bold">var&lt;/span> logger = &lt;span style="color:#080;font-weight:bold">new&lt;/span> LoggerConfiguration()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WriteTo.Console()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .CreateLogger();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>로그를 작성합니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>logger.Information(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, Serilog!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>로그를 수집합니다.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>2023-03-03 12:00:00.0000000 [INF] Hello, Serilog!
&lt;/code>&lt;/pre>&lt;p>이렇게 Serilog를 이용하여 로그를 작성할 수 있습니다.&lt;/p>
&lt;p>또한 이렇게 작성 된 로그를 구조화 된 로그로 작성할 수 있습니다.&lt;/p>
&lt;ol>
&lt;li>로그를 구조화 된 로그로 변경합니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>logger.Information(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, {name}!&amp;#34;&lt;/span>, &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Serilog&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>로그를 수집합니다.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>2023-03-03 12:00:00.0000000 [INF] Hello, Serilog!
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>로그를 구조화 된 표현법으로 변경하면 다음과 같습니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2023-03-03 12:00:00.0000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;level&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;INFO&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;messageTemplate&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, {name}!&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Serilog&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>또한 Deconstruct를 이용하여 데이터를 펼쳐 볼 수 있습니다.
다음과 같은 좌표를 나타내는 클래스가 있다고 가정해봅시다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Coordinate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#888;font-weight:bold">double&lt;/span> Latitude { &lt;span style="color:#080;font-weight:bold">get&lt;/span>; &lt;span style="color:#080;font-weight:bold">set&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#888;font-weight:bold">double&lt;/span> Longitude { &lt;span style="color:#080;font-weight:bold">get&lt;/span>; &lt;span style="color:#080;font-weight:bold">set&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 클래스를 다음과 같이 로그에 작성할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888;font-weight:bold">var&lt;/span> coordinate = &lt;span style="color:#080;font-weight:bold">new&lt;/span> Coordinate { Latitude = &lt;span style="color:#00d;font-weight:bold">37.566535&lt;/span>, Longitude = &lt;span style="color:#00d;font-weight:bold">126.9779692&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>logger.Information(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, {@coordinate}!&amp;#34;&lt;/span>, coordinate);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 작성된 로그를 수집하면 다음과 같이 나옵니다.&lt;/p>
&lt;pre tabindex="0">&lt;code>2023-03-03 12:00:00.0000000 [INF] Hello, { Latitude: 37.566535, Longitude: 126.9779692 }!
&lt;/code>&lt;/pre>&lt;p>구조화 된 표현법으론 다음과 같이 나옵니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2023-03-03 12:00:00.0000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;level&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;INFO&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;messageTemplate&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, {@coordinate}!&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;coordinate&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Latitude&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">37.566535&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Longitude&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">126.9779692&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="serilog를-이용한-로그-수집serilogsinks">Serilog를 이용한 로그 수집(Serilog.Sinks)&lt;/h1>
&lt;p>Serilog는 다양한 로그 저장소에 로그를 저장할 수 있도록 다양한 &lt;a href="https://github.com/serilog/serilog/wiki/Provided-Sinks">Sink&lt;/a>를 제공합니다.
이 글에서는 &lt;a href="https://github.com/serilog-contrib/Serilog.Sinks.AmazonS3">Serilog.Sinks.AmazonS3&lt;/a>를 사용하여 S3에 로그를 저장해 보겠습니다.&lt;/p>
&lt;ol>
&lt;li>Serilog.Sinks.AmazonS3 패키지를 설치합니다.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>dotnet add package Serilog.Sinks.AmazonS3
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>Serilog를 appsettings.json을 이용해 초기화합니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Serilog&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;MinimumLevel&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Information&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;WriteTo&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Name&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;AmazonS3&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Args&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Path&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;log.json&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;BucketName&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;bucket-name&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;RollingInterval&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Day&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;ServiceUrl&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;https://s3.ap-northeast-2.amazonaws.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>권한 등 잘 설정이 되었다면 지정한 버킷에 로그가 저장됩니다.&lt;/p>
&lt;h1 id="amazon-glue를-이용한-로그-크롤링">Amazon Glue를 이용한 로그 크롤링&lt;/h1>
&lt;p>Amazon S3에 저장된 로그를 Amazon Athena를 이용하여 분석할 수 있습니다.
하지만 Amazon Athena는 JSON 형식의 로그를 분석하기에는 한계가 있습니다.
그래서 Amazon Athena를 이용하여 로그를 분석하기 위해서는 로그를 Amazon Glue를 이용하여 크롤링해야 합니다.&lt;/p>
&lt;p>Glue를 이용하여 데이터 카탈로그에 크롤링을 하는 방법은 다음 글을 참고하시면 됩니다.
&lt;a href="https://docs.aws.amazon.com/ko_kr/athena/latest/ug/data-sources-glue.html">https://docs.aws.amazon.com/ko_kr/athena/latest/ug/data-sources-glue.html&lt;/a>&lt;/p>
&lt;h1 id="amazon-athena를-이용한-로그-분석">Amazon Athena를 이용한 로그 분석&lt;/h1>
&lt;p>Amazon Athena는 여러 빅데이터 분석 툴과 마찬가지로 SQL을 이용하여 데이터를 분석할 수 있습니다.
다음과 같이 Amazon Athena를 이용하여 로그를 분석할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">SELECT&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">level&lt;/span>,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>messageTemplate,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>properties.coordinate.Latitude,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>properties.coordinate.Longitude&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">FROM&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;database-name&amp;#34;&lt;/span>.&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;table-name&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">WHERE&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">BETWEEN&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 00:00:00&amp;#39;&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 23:59:59&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이를 이용하여 여러 분산 네트워크 상의 노드들의 로그를 분석할 수 있습니다.
예시로, 두 노드 간에 통신이 이루어지는 시간을 분석해 보겠습니다.
table1은 노드1의 로그를, table2는 노드2의 로그를 나타냅니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">SELECT&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_timestamp,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.&lt;span style="color:#080;font-weight:bold">level&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_level,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.messageTemplate&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_messageTemplate,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.properties.coordinate.Latitude&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_latitude,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.properties.coordinate.Longitude&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_longitude,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_timestamp,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.&lt;span style="color:#080;font-weight:bold">level&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_level,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.messageTemplate&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_messageTemplate,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.properties.coordinate.Latitude&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_latitude,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.properties.coordinate.Longitude&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_longitude&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">FROM&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;database-name&amp;#34;&lt;/span>.&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;table1&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">JOIN&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;database-name&amp;#34;&lt;/span>.&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;table2&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">ON&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.properties.coordinate.Latitude&lt;span style="color:#bbb"> &lt;/span>=&lt;span style="color:#bbb"> &lt;/span>table2.properties.coordinate.Latitude&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>table1.properties.coordinate.Longitude&lt;span style="color:#bbb"> &lt;/span>=&lt;span style="color:#bbb"> &lt;/span>table2.properties.coordinate.Longitude&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">WHERE&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">BETWEEN&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 00:00:00&amp;#39;&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 23:59:59&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>table2.&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">BETWEEN&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 00:00:00&amp;#39;&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 23:59:59&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이런 식으로 로그를 분석하면 두 노드 사이의 통신 시간을 알 수 있습니다.&lt;/p>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>이 글에서는 Serilog를 이용하여 로그를 수집하고 Amazon Athena를 이용하여 로그를 분석하는 방법을 소개했습니다.
오늘 소개한 방법을 응용하면 다양한 분산 네트워크 상의 노드들의 로그를 분석할 수 있을 것으로 기대합니다.
또한 이 글에서는 성능이나 여러 가지 제약 사항들을 고려하지 않았습니다.
이 글에서 소개한 방법을 실제로 사용할 때는 성능과 여러 제약 사항들을 고려해야 합니다.&lt;/p>
&lt;hr>
&lt;p>(이 글은 &lt;a href="https://www.dotnetconf.kr/2023">.NET Conf 2023 x Seoul&lt;/a>에 올해 2월 &lt;a href="https://www.dotnetconf.kr/f2ea6fa1-f802-4dba-be87-539d32d3584b">발표한 내용&lt;/a>을 각색한 것입니다.)&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>신뢰하지 않을 자유</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/12/about-trustless/" title="신뢰하지 않을 자유"/><link rel="alternate" href="https://snack.planetarium.dev/1/01/about-trustless/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2022/12/about-trustless/</id><published>2022-12-30T00:00:00+00:00</published><updated>2022-12-30T00:00:00+00:00</updated><content type="html">&lt;h1 id="목적">목적&lt;/h1>
&lt;p>이 글에서는 무신뢰성(Trustless), 그리고 무신뢰성에 기반한 시스템(Trustleses System)에 대해서 소개하고, 무신뢰성이 탈중앙 애플리케이션/네트워크를 만들때 어떤 역할을 한다고 알려져있는지 보편적인 이해에 대해 기술합니다. 또한 이러한 이해를 바탕으로, &lt;a href="https://nine-chronicles.com">나인 크로니클&lt;/a>이나 &lt;a href="https://libplanet.io">Libplanet&lt;/a>과 같은, &lt;a href="https://planetariumhq.com">플라네타리움&lt;/a>이 만드는 탈중앙 소프트웨어들에서 어떤 관점으로 수용해야 할지 제 나름의 의견도 남깁니다.&lt;/p>
&lt;h1 id="사이퍼펑크cypherpunk">사이퍼펑크(Cypherpunk)&lt;/h1>
&lt;p>무신뢰성에 대한 다양한 견해를 언급할 때에, 가장 먼저 설명해야만 하는 개념이 바로 &lt;a href="https://en.wikipedia.org/wiki/Cypherpunk">사이퍼펑크(Cypherpunk)&lt;/a>입니다. 브루스 베스키의 단편 소설 제목이자 이후 유사한 SF 소설이나 영화 장르로도 알려진 &lt;a href="https://en.wikipedia.org/wiki/Cyberpunk">사이버펑크(Cyberpunk)&lt;/a>와, 암호(Cipher)에서 유래한 이 장난기 어린 단어는, 1992년 &lt;a href="https://en.wikipedia.org/wiki/Jude_Milhon">주드 밀론(Jude Milhon)&lt;/a>이 처음 쓰기 시작했다고 합니다. 이들의 주된 관심사는 프라이버시(Pricvacy)였는데, 이는 &lt;a href="https://en.wikipedia.org/wiki/Eric_Hughes_(cypherpunk)">에릭 휴즈(Eric Huhhes)&lt;/a>가 1993년 발표한 &lt;a href="https://www.activism.net/cypherpunk/manifesto.html">〈사이퍼펑크 선언〉(&amp;ldquo;A Cypherpunk&amp;rsquo;s Manifesto&amp;rdquo;)&lt;/a>에서 엿볼 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>Privacy is necessary for an open society in the electronic age. Privacy is not secrecy. A private matter is something one doesn&amp;rsquo;t want the whole world to know, but a secret matter is something one doesn&amp;rsquo;t want anybody to know. Privacy is the power to selectively reveal oneself to the world.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>프라이버시는 전자 시대의 열린 사회를 위해 필수적입니다. 프라이버시는 세상 모든 사람들이 그것에 대해 알게 되는 것을 원하지 않는 것이며, 비밀은 전세계 모든 사람이 몰랐으면 하길 바라는 것이기에 그 둘은 서로 다릅니다. 즉 프라이버시는 자신에 대해 선택적으로 세상에 드러낼 수 있는 힘(권한)입니다.&lt;/p>
&lt;/blockquote>
&lt;p>단순히 &amp;ldquo;내가 누구인지 밝히고 싶지 않다.&amp;rdquo; 라는 것을 넘어서 신원의 주권에 대한 이야기를 하고 있는 그들로서는, (설령 그것이 쓰기가 더 불편해지더라도) 자신의 주권을 자신의 허락을 받지 않고 공개하는 것에 매우 비판적일 수 밖에 없었습니다. 개인의 정보는 개인이 스스로 지켜야, 그리고 지킬 수 있게 해야 한다는 것이었죠.&lt;/p>
&lt;blockquote>
&lt;p>We cannot expect governments, corporations, or other large, faceless organizations to grant us privacy out of their beneficence.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>우리는 정부, 기업 혹은 큰 익명의 조직들이 우리의 프라이버시를 그들의 선의로 지켜줄 것이라곤 기대할 수 없다.&lt;/p>
&lt;/blockquote>
&lt;p>그들은 개인이 이러한 조직/단체, 기업 그리고 국가에 저항하는 수단으로서 암호 기술에 주목했습니다. &lt;a href="https://en.wikipedia.org/wiki/Electronic_signature">전자서명(Electronic Signature)&lt;/a>을 사용하여, 중앙화된 데이터베이스에 의존하지 않고도 신원 증명을 하길 원했으며, 자금 추적과 검열을 피하려고 독자적인 송금 시스템을 만들었습니다. 그리고 그러한 부산물 중 하나가 그 유명한 &lt;a href="https://bitcoin.org">비트코인(Bitcoin)&lt;/a>이었죠.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>아마도 짐작하셨겠지만, 제가 강조하고 싶은 것은 그들이 암호학 기술들을 활용해 비트코인을 만들었다는 것이 아닙니다. 그들은 자신의 프라이버시를 다른 누군가가 관리하는 것을 극도로 꺼렸고, 그를 피하기 위한 방법이 암호학 기술이었다는 것입니다.&lt;/p>
&lt;h1 id="web3">Web3&lt;/h1>
&lt;p>(이제는 많은 분들이 아실만한 주제지만) 이런 사이퍼펑크들이 &lt;a href="https://en.wikipedia.org/wiki/Web3">Web3&lt;/a>로 대표되는 탈중앙 네트워크/애플리케이션을 만들자는 주장에 항상 긍정적인 것만은 아닙니다. 이들은 현재의 Web3가 주장하거나 지향하는 것이, 이미 너무 타협을 한 나머지 (적어도 본인들이 주장하던 것보다는) 훨씬 더 중앙화 되었다고 비판하죠.&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>하지만 이런 비판을 받는 Web3조차도 표현이나 중점을 두는 방향을 변주되었을 지언정, 비슷한 문제의식에 착안한 부분이 있다는 점은 재밌는 지점입니다. 가령 이더리움 재단에서 밝힌&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> &lt;a href="https://ethereum.org/en/web3/#core-ideas">Web3의 핵심 아이디어&lt;/a>에는 다음과 같은 언급이 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>Web3 is trustless: it operates using incentives and economic mechanisms instead of relying on trusted third-parties.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Web3는 무신뢰형입니다: 어떤 신뢰하는 제 3자에 의존하는 대신, 인센티브와 경제적 메커니즘을 사용하여 운영합니다.&lt;/p>
&lt;/blockquote>
&lt;p>프라이버시에 대한 언급은 없지만, 여전히 누군가를 믿을 수 없다는 태도는 유지하고 있는 것처럼도 보입니다. 저는 이게 신뢰(Trust)가 특정한 주체에 대한 힘의 근간이 되는 현상을 여전히 견제하고 있기 때문이라고 생각합니다. &lt;a href="https://en.wikipedia.org/wiki/Gavin_Wood">개빈 우드(Gavin Wood)&lt;/a>가 Web3를 창안하게 된 계기 또한 이러한 문제의식에서 출발했다고 알려져 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>The premise of &amp;lsquo;Web 3.0&amp;rsquo; was coined by Ethereum co-founder Gavin Wood shortly after Ethereum launched in 2014. Gavin put into words a solution for a problem that many early crypto adopters felt: the Web required too much trust. That is, most of the Web that people know and use today relies on trusting a handful of private companies to act in the public&amp;rsquo;s best interests.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Web 3.0의 전제는, 2014년 이더리움이 출시된 직후 공동 설립자인 개빈 우드가 만들었습니다. 개빈은 많은 초기 암호화폐 사용자들이 느꼈던 문제에 대한 해결책을 말했습니다. 웹은 너무 많은 신뢰를 요구하고, 오늘날 사람들이 알고 사용하는 대부분의 웹은 소수의 민간 기업이 공익을 위해 행동할 것을 신뢰하는데 의존합니다.&lt;/p>
&lt;/blockquote>
&lt;p>사이퍼펑크들이 프라이버시를 위해 주장한것은, 단순히 비밀을 간직하고 싶었던 것이 아니라, 어떤 것을 공개할지를 스스로 정해야 한다는 일종의 자기 주권 이야기이었습니다. 그리고 그런 맥락에서 Web3의 오너십 역시 크게 다르지 않을 것입니다. 결국 내가 누구를 믿을지 말지조차, 내가 직접 정할 수 있어야 한다는 것이죠.&lt;/p>
&lt;h2 id="합리적-경제인homo-ecnomicus">합리적 경제인(Homo ecnomicus)&lt;/h2>
&lt;p>&amp;ldquo;인센티브와 경제 모델을 누군가의 선의 대신 사용해야 한다.&amp;ldquo;라는 주장은 고전 경제학에서 인용되는 &lt;a href="https://en.wikipedia.org/wiki/Homo_economicus">합리적 경제인(Homo economicus)&lt;/a>을 연상케도 합니다. 합리적인 경제인 모델은 현대에 들어선 &lt;a href="https://en.wikipedia.org/wiki/Behavioral_economics">행동 경제학(Behavioral economics)&lt;/a>에 의해 그 현실성이 많이 부정당하고 있는데&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>, 그렇다 보니 Web3의 무신뢰성이라는 것은 전제부터 불가능한 것 아닌가란 의심도 듭니다.&lt;/p>
&lt;p>하지만 저는 이 비판을 100% 적용하는 것은 어렵다고 봅니다. 행동 경제학의 합리적인 경제인 비판은, 그것이 잘 성립하지 않기에 그에 수반한 고전 경제학의 가정이나 합리성이 깨질 수 있다는 것인데, 무신뢰성이 필요한 이유는 애초에 합리적인 활동이나 그를 통한 효율을 올리는 것이 아니기 때문입니다. 데이터를 클라우드에 저장하면 더 싸고 더 편할 때도 있는데, 굳이 그걸 내 로컬 하드드라이브에 유지하는 것이 반드시 가격이나 시간 효율 때문만은 아니겠죠.&lt;/p>
&lt;h1 id="이념과-효율">이념과 효율&lt;/h1>
&lt;p>효율에 대해서 이야기하기 시작하면 나올 주요 반론(?)중 가장 까다로운 것은 아마 이런 류일 것입니다.&lt;/p>
&lt;p>&amp;ldquo;난 여러분께 제 주권을 돌려달라고 한 적이 없습니다. 제 데이터를 제가 직접 관리하고 싶지도 않구요. 전 그저 서비스를 싸고 쉽고 편하게 쓰고 싶은 것 뿐이에요.&amp;rdquo;&lt;/p>
&lt;p>사실 제 생각엔, 세상의 많은 서비스 사용자들이 이렇지 않나 싶기도 합니다. 아무도 못 믿어서 비 수탁형 지갑(Non-Custodial Wallet)에 꼬박꼬박 보관하다가, 실수로 하드를 포맷하거나 컴퓨터가 고장 나 쓰지 못하는 사람은 생각보다 많습니다. 그리고 대부분의 현대적인 서비스들은 점점 소유권과 그에 대한 책임 비용을 사용자에게서 공급자가 가져오는 형태로 진화했기에, &amp;ldquo;당신의 개인 키가 없어져도 우린 아무 것도 못해드립니다.&amp;rdquo; 라는 이야기가, &amp;ldquo;우린 너희의 개인 키를 정말로 모른다.&amp;ldquo;라는 진실성보다는, 그저 비겁한 책임 회피만으로 들리는 시대이기도 하죠.&lt;/p>
&lt;p>그렇다면 정말로 무신뢰성은 철저히 이념적인 것일 뿐이고, 서비스의 효율에 이바지하는 것이 없을까요?&lt;/p>
&lt;h2 id="metamask의-사례---조금-기술적인-이야기">MetaMask의 사례 - 조금 기술적인 이야기&lt;/h2>
&lt;p>&lt;a href="https://metamask.io">MetaMask&lt;/a>는 &lt;a href="https://ethereum.org">이더리움&lt;/a> 네트워크를 사용할 때 많이 사용되는 암호화폐 지갑입니다. 보다 구체적으로는, 사용자는 MetaMask를 통해 자산을 송금하거나, &lt;a href="https://en.wikipedia.org/wiki/Decentralized_application">탈중앙 애플리케이션(Decentralized Application, dApp)&lt;/a>을 실행할 수 있습니다.&lt;/p>
&lt;p>그런데 많은 사용자가 MetaMask를 사용하다 무심결에 사용하는 PC를 초기화해서 난처해지곤 합니다. 이 고지식한 소프트웨어가 계정 정보를 네트워크 어디에도 따로 저장하지 않기 때문인데요. 사실 MetaMask가 저장하는 계정 정보라는 것은 단순히 좀 긴 숫자&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>인데, MetaMask는 사용자가 입력한 패스워드로 암호화해서 로컬 저장소에 저장할 뿐입니다.&lt;/p>
&lt;p>이런 제약들로 인해, MetaMask는 예전 사이퍼펑크들의 강박증을 계승한 듯한 불편한 소프트웨어처럼 보입니다. 하지만 MetaMask, 더 정확히는 MetaMask와 이더리움의 서명 체계가 가지는 아주 독특한 특징이 있는데, 바로 호환성이 엄청나게 뛰어나다는 점입니다. 이더리움과 그 위에서 동작하는 탈중앙 애플리케이션들은, 기본적으로 아무도 믿지 않기에 외부의 계정 체계에 의존하는 것이 아니라 오로지 사용자가 제출한 서명과 데이터를 통해서만 동작합니다. 그로 인해 복잡한 &lt;a href="https://en.wikipedia.org/wiki/Single_sign-on">통합 인증(SSO)&lt;/a>이나 신원 제공자들과의 협업 없이도, 누구나 같은 서명 체계를 공유하는 네트워크에 호환되는 애플리케이션을 바로 만들 수 있습니다. &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> 이런 특징 덕에 MetaMask는 그야말로 폭발적인 성장을 이룩할 수 있었습니다.&lt;/p>
&lt;p>물론 MetaMask의 이런 성장이 온전히 무신뢰성에 기반한다고 보는 것은 지나친 비약일 수도 있습니다. 소위 DeFi Summer라고 불리는 가상 자산 시장의 호황에 맞춰서 사람들의 관심이 Web3에 몰린 것은 부정할 수 없는 사실이고, MetaMask의 성장에는 지대한 영향을 끼쳤을 것입니다. 하지만 만약 MetaMask를 &lt;a href="https://consensys.net">ConsenSys&lt;/a> &lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>가 Google이나 Facebook과 같이 중앙화된 웹서비스처럼, 완전 수탁형 서비스로 제공한다고 했다고 가정해보죠. (이념적인 부분을 차치하더라도) 이렇게 많은 서비스에서 쉽고 빠르게 수용할 수 있었을까요? Web 2.0시대로부터 OAuth가 제안되어 공급자들이 구현하는 것을 기다리는데에만 수년이 걸렸던 걸 돌이켜보면, 이는 어려운 일이라고 생각합니다. 바꾸어 말하자면 이런 확장성이야말로 &amp;ldquo;Web3스럽다&amp;quot;는 것만으로 치부할 수 없는, 무신뢰성의 가치입니다.&lt;/p>
&lt;h2 id="여전히-안전한-신뢰---조금-철학9적인-이야기">여전히 안전한 &amp;ldquo;신뢰&amp;rdquo; - 조금 철학&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>적인 이야기&lt;/h2>
&lt;p>MetaMask의 사례는 무신뢰형 시스템과 소프트웨어가 항상 비효율적인 것만은 아니라는 점을 시사하지만, 항상 더 효율적이라는 이야기는 역시 아닙니다. 그렇기에 모든 소프트웨어를 효율적으로 만들기 위해 무신뢰성을 확보해야 한다는 것 또한 이상한 이야기겠지요. 효율로 확실한 우위를 가지지 못하는 이상, 이런 반론은 여전히 유효합니다.&lt;/p>
&lt;p>&amp;ldquo;코드와 프로토콜을 믿는 것은 사람들을 믿는 것보다 더 위험하다. (혹은 허황되다)&amp;rdquo;&lt;/p>
&lt;p>&lt;a href="https://p2pfoundation.net">P2P 재단&lt;/a> 위키에 있는 &lt;a href="https://wiki.p2pfoundation.net/Trustless_Systems">무신뢰 시스템(Trustless Systems)&lt;/a> 문서에는 이런 톤의 보다 구체적인 주장들을 찾아볼 수 있는데요.&lt;/p>
&lt;blockquote>
&lt;p>First, you need to trust the protocol of the cryptocurrency and/or DAO. This isn’t as simple as saying ‘I trust the maths’, for some actual human (or humans) wrote the code and hopefully debugged it, and we are at least trusting them to get it right, no?&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>우선, 여러분은 암호화폐 혹은 DAO의 프로토콜을 믿어야 합니다. 그런데 이건 &amp;ldquo;수학을 믿습니다&amp;quot;같이 단순하진 않죠. 실제로는 일부의 사람들이 코드를 작성하고 희망적으로 디버그했으며, 우린 그들이 올바르게 작업했기를 믿는 것이기 때문이죠, 안 그래요?&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Instead of trusting our laws and institutions, we are being asked to trust stakeholders and miners, and programmers, and those who know enough coding to be able to verify the code. We aren’t actually trusting the blockchain technology; we are trusting the people that support the blockchain.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>우리의 법률과 기관을 믿는 대신, 우리는 이해 당사자와 채굴자, 그리고 코드를 검증할 정도로 코딩을 할 줄 아는 사람을 신뢰하라는 요청을 받고있는 겁니다. 우린 실제로 블록체인 기술을 신뢰하는 게 아니에요; 우린 그저 블록체인을 지지하는 사람을 신뢰하고 있을 뿐입니다.&lt;/p>
&lt;/blockquote>
&lt;p>저는 무신뢰성에 대한 이런 비판에 대해서 생각할 부분도 있지만, 소프트웨어 엔지니어로서 전적으로 동감하긴 어렵다고 느낍니다.&lt;/p>
&lt;h3 id="입법-사법-그리고-행정">입법, 사법 그리고 행정&lt;/h3>
&lt;p>어떤 분들은 무신뢰성의 한계에 대해 지적하면서 다음과 같은 대안을 제시하시기도 합니다.&lt;/p>
&lt;blockquote>
&lt;p>Perhaps we ought to reconsider the desire to expunge trust, and instead focus on what should be done to strengthen it. One way to support trust is to hold institutions accountable when they betray it.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>아마도 우리는 신뢰를 제거하려는 생각을 재고하고, 그것을 강화하기 위해 무엇을 해야 하는지 초점을 맞춰야 할 것입니다. 신뢰를 강화하기 위해 할 수 있는 한 가지 방법은, 기관이 신뢰를 배반했을 때 책임을 지도록 하는 것입니다.&lt;/p>
&lt;/blockquote>
&lt;p>저는 이것이 잘못되었거나 무의미한 일이라고 생각하진 않습니다. 하지만 무신뢰성, 그리고 그것에 기반한 블록체인 기술이 특별히 잘할 수 있는 일이 아니라고 생각됩니다. 왜냐하면, 이런 무신뢰성은 보통 행정에 필요한 권한(e.g., 개인 식별)을 개인에게 환원시키고 프로토콜에 의한 자동화를 강조하는데, 그걸 부정하면 딱히 더 잘할 수 있는 부분이 없기 때문입니다.&lt;/p>
&lt;p>어떤 분들은 행정만큼이나, 혹은 그 이상으로 &amp;ldquo;입법&amp;rdquo;, 그리고 &amp;ldquo;사법&amp;quot;이 중요하다고 말합니다. 그리고 저도 거기에 동의합니다. 다만 그건 블록체인 소프트웨어가 잘할 수 있는 일도 아니며, 본래의 가정을 무시하고 무리하게 취사선택(cherry-pick)할 때 오히려 비효율적인 부분이 늘어나기 때문에 어울리지 않는다고도 생각합니다. 대표적인 예로는 &lt;a href="https://en.wikipedia.org/wiki/Decentralized_autonomous_organization">탈중앙 자율 조직(Decentralized autonomous organization)&lt;/a>이 의사 결정 도구로 많이 사용되지만, 정작 투표 과정에서는 이더리움 네트워크를 사용하지 않는 &lt;a href="https://snapshot.org">snapshot&lt;/a>을 들 수 있겠네요. &lt;sup id="fnref:9">&lt;a href="#fn:9" class="footnote-ref" role="doc-noteref">9&lt;/a>&lt;/sup>&lt;/p>
&lt;h3 id="찍먹과-부먹">&amp;ldquo;찍먹&amp;quot;과 &amp;ldquo;부먹&amp;rdquo;&lt;/h3>
&lt;p>한국에서 탕수육, 특히 배달 탕수육을 먹는데 있어 빠질 수 없는 논쟁거리가 소위 &amp;ldquo;부먹&amp;rdquo;(소스를 부어서 먹기)과 &amp;ldquo;찍먹&amp;rdquo;(소스를 찍어서 먹기)입니다. 여기에는 얼핏 우스꽝스럽지만, 꽤 진지한 이론적 배경도 있죠. &lt;sup id="fnref:10">&lt;a href="#fn:10" class="footnote-ref" role="doc-noteref">10&lt;/a>&lt;/sup> &lt;sup id="fnref:11">&lt;a href="#fn:11" class="footnote-ref" role="doc-noteref">11&lt;/a>&lt;/sup>&lt;/p>
&lt;p>어찌 되었거나, 저는 개인적으론 &amp;ldquo;찍먹&amp;quot;을 선호합니다. 정확하게는 &amp;ldquo;찍먹&amp;quot;이나 &amp;ldquo;부먹&amp;quot;이나 맛에 있어선 별 차이를 못 느낍니다. 하지만 &amp;ldquo;부먹&amp;quot;이 가지는 치명적인 단점은 경계하는데 바로 &amp;ldquo;비가역성&amp;quot;입니다. 제가 탕수육을 시켜서 소스를 다 부어버린다면, 이걸 찍어 먹고 싶은 사람은 선택지가 없어집니다.&lt;/p>
&lt;p>무신뢰성을 이야기하다 갑자기 탕수육 이야기를 한 것은, 신뢰 관계라는 것도 비슷한 비가역성을 가지고 있다고 생각하기 때문입니다. 누군가를 믿는 걸로 전제된 시스템에선, 누군가를 임의로 믿지 않을 수 없습니다. 하지만 반대는 여전히 가능하죠. &lt;sup id="fnref:12">&lt;a href="#fn:12" class="footnote-ref" role="doc-noteref">12&lt;/a>&lt;/sup>&lt;/p>
&lt;h3 id="자동화된-행정">자동화된 행정&lt;/h3>
&lt;p>&amp;ldquo;입법&amp;quot;이나 &amp;ldquo;사법&amp;quot;을 다루기에 현재의 블록체인이 적합하지 않다한들, 혹은 신뢰/무신뢰를 나중에라도 선택을 할 수 있다한들 그것들이 무신뢰성에 기반한 &amp;ldquo;행정&amp;quot;을 용인해야 할 면죄부가 되진 않습니다. 기여를 하건 못하건, 위험한 건 여전히 위험한 겁니다. 또한 성립할지 어쩔지도 모르는 개념을 굳이 선택할 수 있게 할 이유도 없습니다. 그런데 다시 생각해보면 무신뢰성이, 사람들에게 누군가를 믿지 않을 권리를 주는 것이, 정말로 위험하거나 허황 된 일일까요?&lt;/p>
&lt;p>앞서 밝혔듯, 저는 모든 경우에 무신뢰형 시스템이 효율적이거나 윤리적이라고 믿진 않습니다. 현재의 정부, 기업, 또는 중앙화된 구조가 특별히 누군가를 착취하고 박해하려고 발전한 것이 아니라, 이러한 문제를 보다 잘 해결하고자 노력하기 위한 결과라고도 생각합니다. 중앙화된 것이 특별히 구식이거나 비효율적이거나, 청산해야 할 적폐라고 생각하지도 않습니다. 그저 중앙화 되어 있을 뿐이죠. &lt;sup id="fnref:13">&lt;a href="#fn:13" class="footnote-ref" role="doc-noteref">13&lt;/a>&lt;/sup>&lt;/p>
&lt;p>탈중앙화라는 관점에서, 무신뢰성에 기반한 &amp;ldquo;행정&amp;quot;은 무신뢰성 자체보단 행정의 자동화와 &amp;ldquo;사법&amp;quot;을 간소화(이하 &amp;ldquo;자동화된 행정&amp;rdquo;)에 더 큰 가치가 있습니다. 이는 사이퍼펑크들과 Web3가 무신뢰성을 통해 소구했던 것이 결국 &amp;ldquo;주권&amp;quot;이었다는 점을 상기해보면 꽤 자연스러운 흐름입니다.&lt;/p>
&lt;p>저는 작금의 블록체인 기술과 그를 통해 사람들이 기대하는 건, 실제 세상의 전제를 아예 뒤집는 수준의 혁신이라 생각합니다. 세상이 진짜 법대로 돌아간다면 경찰이 필요 없겠죠. 그리고 인류는 그런 세상을 지난 수 천년간 경험해 본 적이 없었고, 그런 공백을 메우기 위한 방법이 그 세월 동안 고안되어 왔습니다. 하지만 실체가 없는 소프트웨어를 돈을 주고 사고팔기 시작한 지는 100년이 안 되었고, (메타버스 운운이 호들갑이라 하더라도) 그런 실체 없는, 하지만 사람이 코드로서 제어할 수 있는 가상 세계가 생긴 지는 고작 수 십년에 지나지 않습니다. 이런 상황에서는 기술과 사회에 대한 가정을 그대로 유지하면서, 그것도 저 같은 소프트웨어 엔지니어가 이에 대해 가타부타 논하는 건 그야말로 갓난아이가 공자 앞에서 문자 쓰는 것과 다를 게 없습니다 &lt;sup id="fnref:14">&lt;a href="#fn:14" class="footnote-ref" role="doc-noteref">14&lt;/a>&lt;/sup> 바꾸어 이야기하면, 제가 &amp;ldquo;자동화된 행정&amp;quot;에 거는 기대는, 실체가 있는 현대 사회에서 인류가 몇 천년간 치고 받으면서 쌓아 올린 다양한 의사 결정 체계&lt;sup id="fnref:15">&lt;a href="#fn:15" class="footnote-ref" role="doc-noteref">15&lt;/a>&lt;/sup>들에 대한 제 나름의 존경과 경의이기도 합니다.&lt;/p>
&lt;h1 id="요약">요약&lt;/h1>
&lt;ul>
&lt;li>무신뢰성은 단순히 선의나 신뢰를 부정해야 한다는 이야기가 아니라, 그럴 수 있는 권리를 개개인에게 부여해야 한다는 주장입니다.&lt;/li>
&lt;li>사이퍼펑크, Web3 모두 대상의 차이(프라이버시 vs 서비스)는 있지만, 모두 권리에 관한 이야기를 하고 있기에 무신뢰성을 전제로 합니다.&lt;/li>
&lt;li>무신뢰성은 때때로(혹은 꽤 자주) 효율적이지 못할 수 있지만, 때로는 빠른 확장을 가능케 하기도 합니다.&lt;/li>
&lt;li>무신뢰성을 전제하는 &amp;ldquo;자동화된 행정&amp;quot;은, 무언가를 탈중앙화하는 데에 있어 가장 좋은 방법은 아닐 수 있습니다. 하지만 블록체인이란 기술을 가장 잘 활용할 수 있는 방법입니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>(이 글은 제 &lt;a href="https://gist.github.com/longfin">개인 Gist&lt;/a>에 올해 10월 &lt;a href="https://gist.github.com/longfin/019e0067275d134f4302539d2ddbff06">게시한 글&lt;/a>을 옮긴 것입니다.)&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>사실 비트코인이 이들의 유일한 부산물인 것은 아닙니다. &lt;a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy#Criminal_investigation">미국의 소프트웨어 수출 제재를 피하기 위해 소스 코드를 출력해서 배포한 전설적인 일화&lt;/a>로 유명한 암호 프로그램인 &lt;a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP(Pretty Good Privacy)&lt;/a>는 당대 사이퍼펑크로 유명했던 &lt;a href="https://en.wikipedia.org/wiki/Phil_Zimmermann">필 짐머만(Phil Zimmermann)&lt;/a>의 저작물이며, 넷스케이프(Netscape)의 공동 설립자였던 &lt;a href="https://en.wikipedia.org/wiki/Marc_Andreessen">마크 안데르센(Marc Andreessen)&lt;/a>을 포함한 많은 엔지니어가 &lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#SSL_1.0,_2.0,_and_3.0">Secure Socket Layer(SSL)&lt;/a>과 관련된 소프트웨어들을 만들기도 했죠.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>개인적으로 자유 소프트웨어 진영과 오픈 소스 소프트웨어 진영의 대립을 보는 것 같기도 해서 흥미로운 부분입니다. 하지만 객관적인 비교가 가능할 만큼 충분한 정보가 없다고 생각하여 다루진 못했습니다.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&amp;ldquo;이더리움 재단의 정의가 전체 Web3를 대표할 만큼 대표성이 있는가.&amp;rdquo; 라는 지적이 있을 수 있으며 동의합니다. 이 글이 작성되는 2022년 10월경 제가 접할 수 있는 자료를 기준으로 판단하였으며 이것과 다르면서 더 보편적으로 알려져 있는 정의가 있으면 본 내용은 수정될 수 있습니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Status_quo_bias">현상 유지 편향(Status quo bias)&lt;/a>이나 &lt;a href="https://en.wikipedia.org/wiki/Prospect_theory">전망이론(Prospect theory)&lt;/a> 등이 흔히 일컬어지는 예시입니다.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>정확히는 &lt;a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">타원 곡선 전자 서명(Elliptic Curve Digital Signature Algorithm)&lt;/a>에 사용되는 숫자로, 자세한 사항은 Bitcoin 위키의 &lt;a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1&lt;/a> 문서를 참고하시면 됩니다.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>네트워크가 호환되지 않는 나인 크로니클이 이더리움과 같은 개인키를 사용할때 같은 주소가 나오는 것 또한 이런 까닭입니다.&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7">
&lt;p>MetaMask를 개발한 블록체인 기술 기업입니다. &lt;a href="https://infura.io">Infura&lt;/a>처럼 이더리움 생태계에 필요한 소프트웨어들을 만드는 것으로 유명합니다.&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8">
&lt;p>미리 밑밥(?)을 깔아두자면, 저는 학문으로의 철학을 공부하거나 엄밀하게 사고하도록 훈련한 적이 없는 소프트웨어 엔지니어입니다. 때문에 &amp;ldquo;철학&amp;quot;은 학문을 지칭하기보다 일반어로 이해하여 주시면 감사하겠습니다.&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:9">
&lt;p>주장을 개진하다 보니 단언적으로 이야기했지만, &amp;ldquo;무신뢰를 지향하는 시스템에서 이런 의정 활동이 유효한 부분이 전혀 없는가.&amp;rdquo; 저에게도 답이 있는 문제는 아닙니다. 그렇기에 나인 크로니클 DAO에 대해서도 &amp;ldquo;잘은 모르겠지만, 일단 실험해보자&amp;quot;라는 쪽의 생각에 가깝긴 합니다.&amp;#160;&lt;a href="#fnref:9" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:10">
&lt;p>소스를 부어서 먹는 걸 지지하는 분들은, 본래 탕수육이 원래 소스와 볶아서 먹는 요리였음을 주장하는 전통(?)적인 노선과 찍어 먹는 과정에서 생길 수 있는 여러 위생상의 문제를 걱정하는 실리(?)적인 노선이 있습니다.&amp;#160;&lt;a href="#fnref:10" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:11">
&lt;p>&amp;ldquo;찍먹&amp;quot;을 주장하시는 분들은 주로 식감이나 소스의 배합 자유도를 중요시한다고 알려져 있습니다.&amp;#160;&lt;a href="#fnref:11" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:12">
&lt;p>나인 크로니클의 온보딩포탈이나 플레이어 커뮤니티 등의 사례를 봤을 때, 이것이 실질적으로 가능한 선택인가라는 점은 다소 논쟁적이라고는 봅니다.&amp;#160;&lt;a href="#fnref:12" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:13">
&lt;p>그럼 탈중앙화에 &amp;ldquo;자동화된 행정&amp;quot;이 꼭 필요한 것인가라는 반론이 가능합니다. 그에 대한 생각도 정리해보았는데, 글의 분량 관계상 별도로 내어 적으려고 합니다.&amp;#160;&lt;a href="#fnref:13" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:14">
&lt;p>노파심에 계속 적는 거지만, 저는 이게 가치 없다는 주장을 하는 것이 아닙니다. 단지 제가 블록체인 기술로 잘할 수 없는 일이라는 것입니다.&amp;#160;&lt;a href="#fnref:14" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:15">
&lt;p>지금으로 충분하지 않다. 라는 착안에서 의견이 다른 분도 계시겠지만&amp;hellip; 더 이야기하면 지겨우시겠지만, 그래도 이야기하자면 저는 그 의견에 반대하지 않습니다.&amp;#160;&lt;a href="#fnref:15" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>오픈 소스, 블록체인 그리고 탈중앙 애플리케이션</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/12/oss-blockchain-and-decentralized/" title="오픈 소스, 블록체인 그리고 탈중앙 애플리케이션"/><link rel="alternate" href="https://snack.planetarium.dev/1/01/oss-blockchain-and-decentralized/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2022/12/oss-blockchain-and-decentralized/</id><published>2022-12-07T00:00:00+00:00</published><updated>2022-12-07T00:00:00+00:00</updated><content type="html">&lt;p>이 글에선 &lt;a href="https://ko.wikipedia.org/wiki/%EC%98%A4%ED%94%88_%EC%86%8C%EC%8A%A4">오픈 소스&lt;/a> 운동과 &lt;a href="https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8">블록체인&lt;/a> 기술이 어떤 특성들을 담보하며, 탈중앙 애플리케이션을 만드는데 어떤 역할을 하는지에 대해 저의 이해를 바탕으로 설명합니다. 이 글의 목적은 &amp;ldquo;진정한 탈중앙 애플리케이션을 만들려면 반드시 오픈 소스를 해야 한다.&amp;ldquo;라기보다는&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, 오픈 소스나 블록체인 기술이 차지하고 있는 역할을 공유함으로써, 추후 이러한 이해 상충이 벌어지는 부분들을 보다 명확히 하기 위함입니다.&lt;/p>
&lt;h1 id="오픈-소스">오픈 소스&lt;/h1>
&lt;p>오픈 소스, 혹은 오픈 소스 운동은 다양한 정의를 가지고 있습니다. &lt;a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EC%9C%A0_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4">자유 소프트웨어&lt;/a> 운동을 지지하는 쪽에서는 오픈 소스가 자유 소프트웨어의 부분 집합이라고 주장하지만, 오픈 소스를 지지하는 사람들은 오픈 소스가 자유 소프트웨어를 포함하는 더 넓은 개념이라고 이야기하기도 합니다. 이 둘의 차이나 주장도 흥미로운 부분이 많지만, 이 글에서 제가 밝히고 싶은 제 이해의 관점에선 크게 차이가 나진 않으므로 생략하도록 하겠습니다.&lt;/p>
&lt;p>&lt;a href="https://opensource.org/osd">오픈 소스 이니셔티브의 정의&lt;/a>에 따르면, 오픈 소스는 단순히 코드를 공개하는 것 이상의 기준을 갖추고 있습니다. 가령 파생 제작물(Derived Works)에 대해서도 원본 소프트웨어와 같은 라이선스를 유지해야 한다든지, 개인이나 집단을 차별해서는 안 된다는, 일종의 사회 운동과 같은 성격을 지니고 있기도 합니다.&lt;/p>
&lt;p>그런데 이런 기준들을 만족하는 것보다 더 중요한 것은, 이런 기준들을 요구하게 된 배경과 철학입니다. 왜냐면 구체적인 기준은 시대와 기술이 변화함에 따라 바뀌기도 하기 때문이죠. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 그리고 저는 오픈 소스(그리고 자유 소프트웨어)의 기저에 깔린 배경과 철학이 다음과 같다고 생각합니다.&lt;/p>
&lt;blockquote>
&lt;p>소프트웨어 저작물을 사용하는 모든 사용자에게, 소프트웨어의 구성(i.e., 소스 코드)을 자유롭게 확인하고 수정본과 파생 저작물을 만들어서 배포할 권리를 보장해야 한다. &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;/blockquote>
&lt;p>또한 오픈 소스 운동을 지지하는 많은 사람은, 이런 권리가 보장될 때, 해당 소프트웨어의 생태계가 더욱 풍성해지며 공공의 이익이 촉진된다고 믿습니다. 그렇기 때문에 많은 오픈 소스 프로젝트들이 공개 개발과 협업에 관심을 가지는 것이라 할 수 있죠. &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/p>
&lt;h1 id="블록체인과-포크">블록체인과 포크&lt;/h1>
&lt;p>&lt;a href="https://bitcoin.org/">비트코인&lt;/a>의 세계적인 대히트 이후 블록체인이 (정도나 분야, 전망에 대한 이해는 다를지언정) 우리 사회를 강타했다는 것은 부정하기 어려운 사실입니다. 비트코인을 이야기할 때 빠지지 않는 것이 분산 원장이나 불변성 같은 개념이죠. 이를테면 모든 거래는 하나의 체인에 기록되어 모두의 노드에 저장되므로 누군가가 이를 절대로 위/변조할 수 없다는 그런 구체적인 장점을 들어 이야기하는 경우가 많습니다. 저는 이런 설명이 완전히 틀린 것은 아니지만, 블록체인이 어떤 애플리케이션이나 서비스의 탈중앙화를 하는데 차지하는 역할을 설명하기에는 다소 오해가 생길 수 있는 설명이라는 생각도 합니다. 왜냐면 &amp;ldquo;절대 불변의 분산 장부&amp;quot;라는 매력적인 속성은 블록체인의 기술적인 속성에만 기댄 것이 아니라, 허가형 네트워크에서 오픈 소스 프로젝트로서 취할 수 있는 여러 기법들을 섞어서 만든 비트코인이나 이더리움의 복합적인 성취이기 때문입니다.&lt;/p>
&lt;h2 id="허가비허가형-네트워크">허가/비허가형 네트워크&lt;/h2>
&lt;p>순수하게 기술적인 관점&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>에서 블록체인은 모두가 같은 상태에 대해 합의해야 하는 분산 환경에서, 다른 상태를 계산한 노드를 빠르게 찾기 위한 목적으로 사용됩니다. 그리고 그게 다입니다. 보통 이쯤에서 많은 분들은 이를 배제하는 수단으로써 작업 증명이나 지분 증명 등을 떠올리실 것이고, 또 어떤 분들은 &amp;ldquo;그 또한 블록체인의 일부로 봐야지, 블록체인을 너무 협의로 본 것이 아닌가?&amp;rdquo; 라는 생각이 드실 것입니다. 동의합니다. 하지만 제가 이 글에서 말씀드리고 싶은 것은 이런 구체적인 합의 방법 이전에, 우리가 중요한 결정을 해야 한다는 점입니다. 그것은 바로 네트워크를 허가형으로 운영할 것인지, 아니면 비허가형으로 운영할 것인지입니다.&lt;/p>
&lt;p>우리는 소프트웨어(노드)가 어떠한 주체로부터 허가를 얻어야만 네트워크에 접근할 수 있는지, 아니면 이러한 허가가 없이도 접근할 수 있는지에 따라 이를 허가형(Permissioned), 혹은 비허가형(Permissionless)이라고 지칭합니다. SNS나 멀티플레이어 게임 등이 실행되는 현대의 많은 상업적 네트워크는, 그 서비스/게임의 이용료가 얼마냐와는 무관하게 허가형인 경우가 많은데, 이는 꼭 비용을 요구하지 않더라도 그 네트워크를 이용하기 원하는 소프트웨어의 접근을 특정 주체가 통제할 수 있기 때문입니다. 반대로 이더리움 네트워크는, 트랜잭션을 처리하기 위해 수수료가 발생하는 구조지만, 이러한 수수료만 감당한다면 어떤 주체도 접근을 제한하거나 제어할 수 없기에 비허가형 네트워크로 분류됩니다. &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> 대부분의 탈중앙 네트워크를 지향하는 애플리케이션과 네트워크는 통상적으로 허가형보다는 비허가형으로 설계하여 자유로운 접근을 허용하는 접근을 취합니다.&lt;/p>
&lt;h2 id="프로토콜과-구현">프로토콜과 구현&lt;/h2>
&lt;p>우리가 탈중앙성과 블록체인을 다룰 때 자주 언급하는 것이 프로토콜(Protocol)입니다. 이름에서 알 수 있듯, 탈중앙/비허가 네트워크를 이야기할 때 이 프로토콜은 규칙/규약을 지칭하며, 특정 주체의 판단 대신에 노드가 네트워크를 사용하는 방식을 통제하는 수단입니다.&lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup> 그렇기에 어떤 네트워크가 비허가성, 그리고 그로 인한 탈중앙성을 갖는지 이야기할 때에는 이러한 프로토콜이 얼마나 자세하게 노드의 동작을 규정하는지, 그리고 얼마나 이러한 프로노콜을 잘 유지하는지를 함께 고려하는 경우가 많습니다. 그런데 이런 프로토콜에 대한 고려가 비허가형 네트워크를 만드는데 충분한 조건일까요?&lt;/p>
&lt;p>극단적인 사고 실험을 해보죠. 어떤 노드의 구현이 완벽하게 어떤 네트워크의 프로토콜을 준수하고 호환되며, 심지어 그 네트워크에선 P2P로 모든 노드가 특권 없이 투표를 통해 민주적&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>으로 정해진다고 가정해봅시다. 이 구현을 가지고만 있다면, 누구든지 네트워크에 참여할 수 있다면 이 네트워크는 비허가형일까요? 저는 여기에 대해서 &amp;ldquo;아니오&amp;quot;라고 생각합니다. 왜냐하면, 프로토콜은 규칙을 정해둔 것일뿐, 실제 네트워크에서 동작하는 노드는 소프트웨어이기에 반드시 구현을 필요로 합니다. 즉 사용자들은 어떤 네트워크를 이용할 때에 이러한 구현을 사용합니다. 그런데 이런 구현을 얻는 방법이 제한되어 있다면, 프로토콜의 고려와는 무관하게 탈중앙성도 함께 제한됩니다. 누군가 사용하는 노드의 구현을 바꿔치기하거나, 혹은 구현을 공급하는 주체가 더 이상 공급을 하지 않게 되는 경우 등을 상상해보시면 제 관점의 이해가 수월하시리라 생각됩니다.&lt;/p>
&lt;p>즉 네트워크가 온전히 비허가형이기 위해선 한 가지 속성을 더 만족해야 합니다. 바로 그 노드 구현에 대해서 누구든지 확인할 수 있어야 하며 배포가 독점적인 주체로부터 이뤄지면 안 된다는 것이죠. 이는 오픈 소스가 소프트웨어 저작물에 대해 사용자의 권리로서 보장하는 것과 일치합니다.&lt;/p>
&lt;h2 id="포크">포크&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Fork_(blockchain)">포크(Fork)&lt;/a>는 전통적인 자유 소프트웨어/오픈 소스 개발에서, &lt;a href="https://en.wikipedia.org/wiki/Fork_(software_development)">어떠한 프로젝트를 자신의 입맛에 맞게 개작하여 분화하는 활동을 일컫는 동명의 단어&lt;/a>에서 유래했습니다. 대표적인 리눅스 배포판 중 하나인 우분투는 데비안 리눅스의 포크이며, MySQL을 포크한 MariaDB와 같이 많은 프로젝트가 이러한 포크를 통해 탄생했습니다. 그런데 예전엔 이런 포크에 대해서 부정적인 인식이 있습니다. 주로 프로젝트를 유지 보수하는 메인테이너들 간의 갈등이나 반목으로 인해 싸우고 나간 결과가 포크이기도 했고, 실질적으로 변경 내역을 패치로, 때로는 조정을 통해서 가져와야 하기 때문에 품이 더 드는 비효율적인 일이기 때문이었죠. 더군다나 사람들은 같은 일을 하는 소프트웨어를 2개 이상 쓸 일도 없으니, 사람들의 한정된 관심사란 자원을 나눠먹는 이적 행위이기도 합니다.&lt;/p>
&lt;p>그럼 이렇게 안 좋기만 한 포크를 막으려면 어떻게 해야 할까요? 코드를 숨기고 재배포를 금지하는 거겠지만 이래서야 기껏 오픈 소스로 프로젝트를 하는 의미가 없습니다. 다른 좋은 방법은&amp;hellip; 적어도 저는 아직 발견하지 못했는데, 이는 포크라는 행위가 오픈 소스를 통해 얻고 싶은 가치인 코드의 열람과 개작, 배포의 자유와 깊게 연관되어 있기 때문이라고 생각합니다.&lt;/p>
&lt;p>그렇기에 사람들은 조금 우직하지만 어떻게 보면 정공법을 택했습니다. 보다 좋은 제품을 만들어서 기여자와 사용자들에게 호소하는 것이죠. 캐노니컬이라는 기업을 등에 입은 우분투라는 포크가 있음에도 사람들이 데비안을 사용하는 것은, 우분투에는 없고 데비안에는 있는 데비안 만의 장점이 있기 때문입니다.&lt;sup id="fnref:9">&lt;a href="#fn:9" class="footnote-ref" role="doc-noteref">9&lt;/a>&lt;/sup> 그래서 어쩌면 이는 포크를 막고 독점 소프트웨어로 돌아가느냐 아니면 기여자들과 사용자들이 자신의 프로젝트를 지지할 수 있게끔 개선을 통해 우위를 유지하느냐의 선택이며, 제 이해로는 오픈 소스 신에 남은 많은 사람은 후자를 택했다고 봅니다.&lt;/p>
&lt;p>이는 비허가형 네트워크에도 비슷하게 적용된다고 생각합니다.&lt;sup id="fnref:10">&lt;a href="#fn:10" class="footnote-ref" role="doc-noteref">10&lt;/a>&lt;/sup> 오픈 소스 모델의 선례를 따르는 많은 공개 네트워크들은 포크가 생길 수 있는 위험에도 불구하고 네트워크의 구성을 공개하고 자유로이 포크 된 네트워크를 띄울 수 있도록 합니다. 이는 포크 된 네트워크에 이점이 있다기보다는, 단순히 포크를 제한하면서 동시에 독점성을 없앨 수 있는 방법이 논리적으로 없기 때문이라고 생각합니다.&lt;/p>
&lt;h1 id="탈중앙-애플리케이션">탈중앙 애플리케이션&lt;/h1>
&lt;p>포크에 대한 위의 전망은 전적으로 오픈 소스 모델에서 빌려 온 논리이므로, 현실의 고도화된 의사 결정 체계를 모사하여 해결할 수 있다는 의견이 있을 수 있습니다. 하지만 저는 거기에 대해서는 회의적인데, 왜냐하면 그런 현실의 세련된 의사 결정 체계의 끝에 있는 것이 현존하는 중앙화 된 의사 결정 체제라고 생각하며, 이미 그들은 그들대로 일을 잘하고 있다고 생각하기 때문입니다. &lt;sup id="fnref:11">&lt;a href="#fn:11" class="footnote-ref" role="doc-noteref">11&lt;/a>&lt;/sup>&lt;/p>
&lt;p>저는 탈중앙 애플리케이션의 강점은 단지 조금 다르게 일을 하는 &lt;a href="https://en.wikipedia.org/wiki/Big_Tech#FAANG">FAANG&lt;/a>가 아니라, 그런 주체 없이도 자율적으로 돌아갈 수 있는, 아주 많이 다르게 일을 하는 점에 있다고 생각합니다. 그리고 이런 목표를 달성하기 위해서 현대의 탈중앙 애플리케이션들은 굳이 포크의 위험을 감수하면서도 오픈 소스로 개발되고 있는 것이라고 생각하고요.&lt;/p>
&lt;h2 id="포크를-허용하지-않는-탈중앙-애플리케이션">포크를 허용하지 않는 탈중앙 애플리케이션&lt;/h2>
&lt;p>글을 적다 보니 위의 탈중앙 애플리케이션이 너무 제 시각의, 좁은 버전일 수 있겠다는 생각도 듭니다. 어느 정도 탈중앙화 된, 그렇지만 모두가 내키지 않는 포크는 허용하지 않는 그런 네트워크가 독점성을 띄고 중앙화 되었다고 하는 것이 예단일 수도 있습니다.&lt;/p>
&lt;p>하지만 적어도 현재로서 저는&lt;/p>
&lt;ul>
&lt;li>비허가형 네트워크를 포크를 허용하지 않으면서 구성할 방법에 대한 아이디어가 없으며&lt;/li>
&lt;li>오픈 소스 개발 모델을 벗어난 개발 모델에서 비허가형 네트워크를 구성할 방법에 대한 아이디어도 없으며&lt;/li>
&lt;li>허가형 네트워크에 의존하는 애플리케이션이 탈중앙화 되어 있다고 보기엔 어렵다고 생각합니다.&lt;/li>
&lt;/ul>
&lt;h1 id="요약">요약&lt;/h1>
&lt;ul>
&lt;li>오픈 소스는 소프트웨어 저작물에 대한 사용자의 사용 이상의 권리를 보장하기 위해 창안되었으며, 이는 소프트웨어 개발에 긍정적인 영향을 주고 있다고 평가됩니다.&lt;/li>
&lt;li>현대의 비허가형 네트워크들은, 오픈 소스 운동의 권리 보장을 차용하여 비허가성을 달성하는데, 이와 동시에 포크에 대한 위협에도 같이 노출됩니다.&lt;/li>
&lt;li>오픈 소스와 비허가형 네트워크들은 포크가 유익해서 이를 감내하는 것이 아니라, 비허가성과 이를 통해 담보되는 탈중앙성을 유지하기 위해서 이를 감내합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>(이 글은 제 &lt;a href="https://gist.github.com/longfin">개인 Gist&lt;/a>에 올해 10월 &lt;a href="https://gist.github.com/longfin/0951c39b566e58e4e0a80faf513bb4b1">게시한 글&lt;/a>을 옮긴 것입니다.)&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>물론 저는 이 주장을 지지합니다. 하지만 이 주장을 지지하기에 앞서, 그 까닭을 말씀드리는 것이 먼저라고 생각합니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>실제로 나인 크로니클이 채택하고 있는 라이선스인 &lt;a href="https://www.gnu.org/licenses/agpl-3.0.en.html">AGPL&lt;/a>은 &lt;a href="https://www.gnu.org/licenses/gpl-3.0.html">GPL&lt;/a>의 변형으로, GPL이 가정하던 배포가 바이너리를 직접 제공하는 것 외에도 서버를 통해 서비스를 제공하거나 하는 식으로 바뀐 시대상을 따라가기 위해 제안되었습니다.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&amp;ldquo;이를 촉진하기 위해서 얼마만큼의 제약을 가해야 하는가&amp;quot;가 오픈 소스와 자유 소프트웨어 진영의 가장 큰 논쟁 거리입니다만, 글의 주요한 주제가 아니므로 생략합니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>근래의 많은 오픈 소스 커뮤니티에서 (설사 당장의 기술적인 이득이 생기지 않거나, 혹은 오히려 손해가 발생하더라도) 정치적 올바름과 같은 주제에 대해서 신중하고 포용력 있는 결정을 내리기 위해 고민하는 것은, 이러한 철학이 깔려 있기 때문이라고 생각합니다. 다만 이 또한 글의 주요한 주제가 아니므로 생략합니다.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>보다 구체적으로는, 이더리움 등에서 제안하는 분산 상태 기계로서의 블록체인을 이야기합니다.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>물론 지미 송 같은 비트코인 지지자들은 &lt;a href="https://www.coindeskkorea.com/news/articleView.html?idxno=41885">이더리움이 허가형 네트워크라고 비판하기도 합니다.&lt;/a> 하지만 이는 이더리움이 취하고 있는 접근 방향 자체가 잘못되었다기 보단, 비탈릭을 위시한 이더리움 재단이 &lt;a href="https://www.gemini.com/cryptopedia/the-dao-hack-makerdao">&amp;ldquo;The DAO&amp;rdquo; 사태&lt;/a> 등에서 통제권을 발휘하고 있다는 점의 비판이므로 여기서는 길게 다루지 않겠습니다.&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7">
&lt;p>어떤 네트워크가 비허가형이라고 할 때에는 반드시 어떠한 통제도 없어야 한다는 것을 의미하진 않습니다.&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8">
&lt;p>구성원의 선호를 완벽하게 반영하는 투표가 가능한가에 대한 논의(e.g., &lt;a href="https://ko.wikipedia.org/wiki/%ED%88%AC%ED%91%9C%EC%9D%98_%EC%97%AD%EC%84%A4">콩도르세의 역설&lt;/a>)도 흥미로운 주제이지만, 이 사고 실험의 주된 주제는 아니기에 생략하고, 가능하다고 가정합니다.&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:9">
&lt;p>이 역시도 오픈 소스가 효율성에 대해 많이 비판 받는 지점입니다. 왜냐하면 이러한 장점은 꼭 객관적인 기능의 우열뿐 아니라 개인이 지지하는 가치 등도 포함되기 때문입니다.&amp;#160;&lt;a href="#fnref:9" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:10">
&lt;p>블록체인 포크를 기술적으로 보면 &lt;a href="https://ethereum.org/ko/upgrades/merge/">더 머지(The Merge)&lt;/a>와 같은 체인 호환성이 없는 소프트웨어 업데이트를 일컫는 용어이지만 기술적 논의를 다루는 것이 목표는 아니기에, 여기서는 적대적인 포크로 한정해서 다룹니다.&amp;#160;&lt;a href="#fnref:10" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:11">
&lt;p>어쩌면 이 시각은 독점 소프트웨어를 바라보는 오픈 소스 진영의 논리와 비슷하다는 느낌도 받습니다. 저는 제가 생각하는 탈중앙 애플리케이션이 세상의 모든 애플리케이션을 대체하는 것은 아마도 불가능할 것이라고 생각합니다.&amp;#160;&lt;a href="#fnref:11" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>블록체인? 채굴해서 코인 나오는 건 알겠는데...</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/11/the-simple-of-blockchain/" title="블록체인? 채굴해서 코인 나오는 건 알겠는데..."/><link rel="alternate" href="https://snack.planetarium.dev/1/01/the-simple-of-blockchain/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2022/11/the-simple-of-blockchain/</id><published>2022-11-15T00:00:00+00:00</published><updated>2022-11-15T00:00:00+00:00</updated><content type="html">&lt;h2 id="알림">알림&lt;/h2>
&lt;p>이번 스낵 글은 이전에 개인 &lt;a href="https://www.getrevue.co/profile/bin_bash_shell/issues/issue-1-838950">뉴스레터&lt;/a>에서 발행했던 내용을
필사하여 스낵에 올리는 포스트입니다.&lt;/p>
&lt;h2 id="들어가며">들어가며&lt;/h2>
&lt;p>이번 뉴스레터는 “채굴해서 코인 나오는 건 이제 알겠고, 이게 변조 불가능하다고 하는데 이런 특성이랑 코인이 가치를 가지는 거랑 무슨 상관이야?” 정도로 블록체인을 아시는 분들에 대해 설명하는 내용을 담고 있습니다. 기술적 이해도가 필요한 이야기가 약간은 섞여 있고, 설명의 단순화를 위해 생략하거나 감추는 내용들이 있습니다.&lt;/p>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>블록체인은 “공개 탈 중앙 분산 데이터베이스” 입니다. 채굴같은 일반적인 분산 데이터베이스에는 없는 특성 같은 경우 공개 탈 중앙형 분산 데이터베이스를 만들기 위한 장치입니다.&lt;/p>
&lt;h2 id="데이터베이스">데이터베이스&lt;/h2>
&lt;p>블록체인을 이야기하려면 데이터베이스라는 것을 이야기하지 않을 수가 없습니다. 데이터베이스라는 것은 무엇일까요? 본인이 RDB 등에 익숙하다면 이 단락을 넘기셔도 좋습니다. 이 밑으로는 고전적인 RDB 이야기를 조금 하려고 합니다.&lt;/p>
&lt;figure>
&lt;a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">
&lt;img src="images/database.jpg" alt="하드디스크의 내부, 헤드와 디스크가 보인다."/>
&lt;figcaption>Reference from https://unsplash.com/photos/GNyjCePVRs8&lt;/figcaption>
&lt;/a>
&lt;/figure>
&lt;p>데이터베이스는 쉽게 말해서 일종의 엑셀입니다. 표가 있고. 표에 값을 저장합니다. 이를 쉽고 빠르게 저장하고 가져다 쓰기 위한 여러 장치, 그리고 그 장치를 동작시키기 위한 약간의 규칙 같은 것들이 존재하는 엑셀이죠.
하지만 엑셀과는 다른 특이한 점이 있는데, 바로 값의 변경 (추가, 수정, 삭제)이 트랜잭션(Transaction) 이라는 연산을 통해 이루어진다는 것입니다.
엑셀에 있는 파일을 여러 사람이 동시에 수정한다고 생각해 보겠습니다. 동시에 한 셀을 수정하려고 하면 어떻게 될까요? ‘나중에 엔터를 친 사람 걸 적용한다’ 라는 규칙같은 것들이 떠오른다면 똑똑하신 분일 거고, “나중” 이라는 걸 어떻게 처리할 거냐 같은 것들이 떠오른다면 개발 경력이 좀 되는 분일 것 같습니다.
이걸 트랜잭션 동시성 제어(Concurrency control)라고 합니다. 데이터베이스에 있어서 매우 중요한 부분이자 골치가 아픈 부분이라고 할 수 있습니다. 이 트랜잭션 단위의 변경이라는 특성을 통해 DB는 트랜잭션 순서와 트래픽을 잘 관리하는 것으로 동시성 제어를 할 수 있습니다.&lt;/p>
&lt;h3 id="데이터베이스와-블록체인">데이터베이스와 블록체인&lt;/h3>
&lt;p>앞에서 데이터베이스의 데이터를 변화시키는 방법으로써 트랜잭션을 소개한 이유는 블록체인도 트랜잭션을 통해 모든 분산 노드의 데이터를 변화시키기 때문입니다.
하지만 다른 점이 있다면 보통 일반적인 데이터베이스는 권한을 가진 초월적인 존재인 오라클이 있다면 이 데이터를 마음대로 수정할 수 있고, 블록체인은 민주적인 방법으로 데이터의 수정 시도를 검증합니다.
그럴 일은 0에 수렴하겠지만 -그리고 이렇게 단순하게 진행되진 않겠지만-, 은행 전산망 담당자가 자신의 잔고 뒷자리에 0을 하나 붙여서 데이터베이스에 쓰기만 하면 손쉽게 변조가 가능합니다.
블록체인은 합의에 참여하는 사람들이 모두 자신의 컴퓨터에 데이터베이스를 만들고, 공개 네트워크에 전파 된 트랜잭션을 이용하여 이 데이터베이스에 데이터를 추가하거나 삭제하는 방법을 택함으로써, 앞에서 소개한 내용의 위/변조를 미연에 막을 수 있습니다.&lt;/p>
&lt;h2 id="블록체인">블록체인&lt;/h2>
&lt;h3 id="변조-불가능">변조 불가능&lt;/h3>
&lt;blockquote>
&lt;p>공개 네트워크에 전파 된 트랜잭션을 이용하여 내 로컬 데이터베이스를 수정하는 것과 위/변조를 미연에 막을 수 있는 건 무슨 상관이죠?&lt;/p>
&lt;/blockquote>
&lt;p>은행 전산망 담당자의 이야기로 돌아갑시다. 전산망 담당자 A씨가 이 데이터를 수정할 수 있었던 것은 권한만 존재한다면 쓰는 건 어떤 식으로 수정하더라도 상관이 없기 때문입니다. 잔고 저장 테이블을 수정할 수 있는 코드를 A씨가 몰래 삽입하여 배포한 뒤 이 코드를 실행시키는 방법도 있을 수 있고, 직접 DB에 접근할 수 있었다면 이야기는 더욱 쉬워질 것입니다.
하지만 이 데이터를 수정할 수 있는 방법은 코드를 수정하여 해당 코드를 실행시키는 트랜잭션을 발생시키는 법 단 하나고, 이 코드를 여러 검증인이 검증하여 위/변조하려는 시도를 했을 때 해당 시도를 무시할 수 있다면 어떨까요?
블록체인의 특성이 그렇습니다. 검증에 참여하는 사용자들은 여러 트랜잭션이 위/변조되었는지 검증하고, 검증이 끝난 트랜잭션들을 잘 모아서 다른 검증인들에게 전파합니다. 다른 검증인들은 해당 트랜잭션들이 올바른지 검증한 후 실행시켜 자신의 로컬 데이터베이스를 변화시킵니다.&lt;/p>
&lt;h3 id="블록과-블록체인">블록과 블록체인&lt;/h3>
&lt;p>이 과정에서 코드를 수정하여 트랜잭션을 변조한 뒤 발생시킨다 하더라도, 이런 검증인들에 의하여 받아들여지지 않고 사라집니다. 이 트랜잭션의 묶음을 우리는 “블록” 이라고 부릅니다.
이렇게 트랜잭션이 계속 발생한다면 블록도 계속 만들어 질 것이고, 해당 블록들이 이전 블록의 정보를 담은 상태로 계속 이어진다면 마치 체인과 같은 형태가 될 것입니다. 이걸 우리는 “블록체인” 이라고 부릅니다.&lt;/p>
&lt;figure>
&lt;img src="images/Linkedlist.png" alt="링크드리스트 그림."/>
&lt;figcaption>LinkedList (https://www.geeksforgeeks.org/data-structures/linked-list/)&lt;/figcaption>
&lt;/figure>
&lt;h3 id="검증인">검증인&lt;/h3>
&lt;p>똑똑하신 여러분들은 위화감을 느낄 겁니다&lt;/p>
&lt;blockquote>
&lt;p>“그럼 누가 검증하고 검증인은 어떻게 믿어?”&lt;/p>
&lt;/blockquote>
&lt;p>검증인을 믿기도 어려울 뿐더러, 검증인이 왜 그걸 해야하는지도 의문이 들 겁니다. 누구도 자신의 검증하기 위한 자원을(시간, 전기, 실리콘 성능) 마구 제공하고 싶어하지 않을 거기 때문이죠. 네트워크를 유지하는 데 필요한 검증을 제공해 준 사람들에게 보상을 어떤 방법으로도 해 주어야 합니다. 이 때 등장하는 개념이 “코인” 입니다.&lt;/p>
&lt;h2 id="코인">코인&lt;/h2>
&lt;p>검증에 올바르게 참여 해 준 보상으로, 네트워크는 이 검증인에게 “코인” 을 줍니다. 이 코인에 가치를 만들어서 네트워크에 참여하게 만드는 것은 역설적이게도 이 네트워크에 참여한 사람들입니다.
이런 블록체인의 특성을 이용하여 게임을 만든다던가, 송금 애플리케이션을 만든다던가, 부동산 증서 거래 애플리케이션을 만드는 방식으로 네트워크에 참여하는 사람들이 있고, 이 사람들의 애플리케이션을 이용하기 위해 코인은 가치를 가지며, 이 코인이 가치를 가지기에 검증인은 검증을 하는 동인이 생기게 됩니다.
즉, 진정한 블록체인의 가치와 그에 따라오는 코인의 가치는 커뮤니티가 만들어 나가는 네트워크에 있다고 저는 생각합니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>최대한 풀어 쓰기 위해 복잡한 내용은 많이 덜어내고 최대한 간결하게 설명하려고 노력해 봤는 데 어떨지 모르겠군요. 잘 읽혔으면 좋겠습니다. 다음 호가 나올 진 모르겠지만 나온다면 조금 더 재미있는 내용으로 찾아뵈려 합니다. 감사합니다.&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>오픈 소스인 립플래닛 프로젝트에 기여 하기 전에 알아야 할 파일들</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/09/files-you-would-better-to-know-while-contributing-oss-projects/" title="오픈 소스인 립플래닛 프로젝트에 기여 하기 전에 알아야 할 파일들"/><link rel="alternate" href="https://snack.planetarium.dev/1/01/files-you-would-better-to-know-while-contributing-oss-projects/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2022/09/files-you-would-better-to-know-while-contributing-oss-projects/</id><published>2022-09-14T00:00:00+00:00</published><updated>2022-09-14T00:00:00+00:00</updated><content type="html">&lt;p>개발자 커리어와 오픈 소스는 떼려야 뗄 수 없는 관계입니다. 오픈소스를 통해 얻을 수 있는 것은 경력상의 혜택 뿐 아니라, 안전한 환경에서 새로운 기술을 배우며 효율적이고 효과적으로 의사소통하는 방법과 같은 소프트 스킬을 배울 수 있는 기술적 혜택, 그리고 이와 더불어 인맥적 혜택도 있습니다.&lt;/p>
&lt;p>플라네타리움의 핵심 기술인 립플래닛은 오픈 소스 입니다. 회사 업무를 병행하며 오픈 소스 기여를 하기란 쉽지 않은데, 립플래닛 개발 자체가 오픈 소스 기여가 되는 것이죠.&lt;/p>
&lt;p>그래서 플라네타리움 구성원들 중에서는 오픈 소스 커뮤니티와 개발에 관심이 많았던 분들이 많습니다.&lt;/p>
&lt;p>그럼 립플래닛을 통해 오픈 소스 프로젝트에 기여를 해볼까요? 물론 말처럼 쉽게 시작되진 않습니다. 그리고 시작 전에 알아야 할 몇가지 파일(README, CONTRIBUTING, LICENSE)들이 있습니다. 이 파일들을 통해서 립플래닛에 대해 소개하고 어떤게 립플래닛에 기여할 수 있는지 말씀드리고자 합니다.&lt;/p>
&lt;h2 id="1-readme-파일">1. README 파일&lt;/h2>
&lt;p>&lt;img src="/1/01/files-you-would-better-to-know-while-contributing-oss-projects/images/1.png">&lt;/p>
&lt;p>립플래닛(Libplanet)은 탈중앙 방식으로 멀티플레이 온라인 게임을 만들기 위한 .NET 라이브러리입니다. 이는 전체 게임 플레이가 승인된 중앙 서버가 아닌 동일한 노드 사이의 P2P 네트워크에서 발생하는 것을 의미합니다. 내부적으로 블록체인의 많은 기능(예: 전자 서명, 비잔틴 장애 허용(BFT) 합의, 데이터 복제)을 통합합니다.&lt;/p>
&lt;blockquote>
&lt;p>💡 &lt;strong>립플래닛을 써야하는 3가지 이유&lt;/strong>
&lt;br>&lt;br>
&lt;em>&lt;strong>Embeddable&lt;/strong>&lt;/em>
게임 앱은 실행 중인 다른 프로세스와 통신할 필요가 없으므로 추가 &lt;a href="https://ko.wikipedia.org/wiki/%EB%A7%88%EC%83%AC%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">마샬링&lt;/a> 또는 프로세스 관리가 필요하지 않습니다. Libplanet은 MySQL이나 PostgreSQL보다 &lt;a href="https://ko.wikipedia.org/wiki/SQLite">SQLite&lt;/a>에 더 가깝습니다.
&lt;br>&lt;br>
&lt;em>&lt;strong>Isomorphic&lt;/strong>&lt;/em>
Libplanet은 .NET 라이브러리이므로 모든 게임 로직을 동일한 언어인 C#으로 작성하고 블록체인에서 실행할 수 있습니다. &lt;a href="https://en.wikipedia.org/wiki/Glue_code">글루 코드&lt;/a>나 &amp;ldquo;스마트 계약&amp;quot;이 필요하지 않습니다.
&lt;br>&lt;br>
&lt;em>&lt;strong>Token-independent&lt;/strong>&lt;/em>
거의 모든 블록체인 시스템과 달리 사용자가 또 다른 암호 화폐를 만들고 처리하도록 강요하지 않습니다. 당신의 게임은 무료로 플레이할 수 있으며 일반 게이머가 즐길 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="누겟nuget">누겟(NuGet)&lt;/h3>
&lt;p>모든 안정적인 릴리스에 대해 Libplanet을 .nupkg로 압축하고 NuGet 및 GitHub 릴리스 페이지에 업로드합니다.&lt;/p>
&lt;h3 id="빌드build">빌드(Build)&lt;/h3>
&lt;p>소스 코드에서 Libplanet.dll 및 Libplanet.Stun.dll 어셈블리를 빌드할 수 있습니다.&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet/blob/main/README.md">libplanet/README.md at main · planetarium/libplanet&lt;/a>&lt;/p>
&lt;h2 id="2-contributing-파일">2. CONTRIBUTING 파일&lt;/h2>
&lt;h3 id="기여자-가이드">기여자 가이드&lt;/h3>
&lt;p>참고: 현재 이 문서는 코드 기여자를 위한 것입니다.&lt;/p>
&lt;h3 id="질문-및-온라인-채팅">질문 및 온라인 채팅&lt;/h3>
&lt;p>Libplanet에 대해 논의할 &lt;a href="https://planetarium.dev/discord">Discord 서버&lt;/a>가 있습니다. Libplanet 범주에는 다음과 같은 목적을 위한 몇 가지 채널이 있습니다. 여기 디스코드 내에서는 보통 한국어로 말하지만 자유롭게 영어로 말할 수 있습니다.&lt;/p>
&lt;p>#libplanet-users: Libplanet을 사용하는 게임 프로그래머와 채팅하는 채널
#libplanet-dev: Libplanet을 해킹하고 패치를 만들기 위해 메인테이너 및 기여자에게 질문하고, 채팅하는 채널&lt;/p>
&lt;h3 id="전제-조건">전제 조건&lt;/h3>
&lt;p>최신 C# 컴파일러 및 .NET 런타임을 제공하는 .NET SDK 6.0 이상이 필요합니다. .NET 다운로드 페이지에서 .NET SDK 설치 지침을 읽고 따릅니다.&lt;/p>
&lt;p>선호하는 설정이 없는 경우 Visual Studio Code를 사용하는 것을 추천합니다. .NET을 만든 Microsoft에서 만든 무료 에디터입니다.&lt;/p>
&lt;h3 id="빌드">빌드&lt;/h3>
&lt;p>다음 명령은 종속성(필수 라이브러리 패키지)을 설치하고 전체 Libplanet 솔루션을 빌드합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>dotnet build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SonarAnalyzer를 사용하여 코드 품질을 확인하지만 빌드하는 데 시간이 더 오래 걸립니다. 분석기를 건너뛰려면 다음을 사용할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>dotnet build -p:SkipSonar=&lt;span style="color:#038">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="프로젝트">프로젝트&lt;/h3>
&lt;p>GitHub의 &lt;a href="https://github.com/planetarium/libplanet">planetarium/libplanet&lt;/a> 저장소는 여러 프로젝트로 구성됩니다.&lt;/p>
&lt;ul>
&lt;li>Libplanet: 대부분의 구현 코드를 포함하는 메인 프로젝트. Libplanet이라는 이름의 NuGet 패키지로 배포됩니다.&lt;/li>
&lt;li>&lt;a href="http://libplanet.net/">Libplanet.Net&lt;/a>: Libplanet 위에 구축된 P2P 네트워킹 계층. 이것은 별개의 NuGet 패키지인 Libplanet.Net으로 배포됩니다.&lt;/li>
&lt;li>Libplanet.Node: 고유한 P2P 네트워크를 구축하기 위한 사용자 친화적인 façade API입니다. 이것은 별개의 NuGet 패키지인 Libplanet.Node로 배포됩니다.&lt;/li>
&lt;/ul>
&lt;h3 id="테스트">테스트&lt;/h3>
&lt;p>해당 구현 코드에 가능한 한 완전한 테스트를 작성합니다. 코드 커버리지 100%에 가까워지는 것이 우리의 목표 중 하나입니다.&lt;/p>
&lt;p>&lt;em>Libplanet&lt;/em> 솔루션은 여러 프로젝트로 구성됩니다. &lt;em>.Tests&lt;/em> 접미사가 없는 모든 프로젝트는 실제 구현입니다. 이들은 &lt;em>Libplanet*.dll&lt;/em> 어셈블리에 빌드되고 하나의 NuGet 패키지에 포장됩니다.&lt;/p>
&lt;h3 id="스타일-규칙">스타일 규칙&lt;/h3>
&lt;p>기존 코딩 규칙을 따라주세요. 우리는 이미 여러 정적 분석기를 사용하고 있습니다. &lt;code>msbuild&lt;/code> 와 함께 자동으로 실행되며 스타일 오류가 있으면 경고합니다.&lt;/p>
&lt;p>우리가 일반적으로 사용하는 Git 후크도 등록해야 합니다.&lt;/p>
&lt;p>선호하는 편집기에 EditorConfig 확장을 설치하는 것이 좋습니다.&lt;/p>
&lt;h3 id="벤치마크">벤치마크&lt;/h3>
&lt;p>성능 향상 또는 회귀를 추적하기 위해 일련의 벤치마크를 유지 관리하고 CI에서 지속적으로 측정합니다. 로컬 환경에서도 벤치마크를 실행할 수 있습니다.&lt;/p>
&lt;p>모든 벤치마크 코드는 &lt;a href="https://github.com/planetarium/libplanet/tree/main/Libplanet.Benchmarks">Libplanet.Benchmarks&lt;/a> 프로젝트에 있습니다. 벤치마크는 &lt;a href="https://benchmarkdotnet.org/">BenchmarkDotNet&lt;/a>을 기반으로 하므로 자세한 내용은 공식 문서를 참조하세요.&lt;/p>
&lt;h3 id="새-버전-출시">새 버전 출시&lt;/h3>
&lt;p>이 주제에 관한 릴리스 가이드를 읽어주세요.&lt;/p>
&lt;h2 id="3-license-파일">3. LICENSE 파일&lt;/h2>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet">planetarium/libplanet&lt;/a>은 &lt;strong>GNU Lesser General Public License v2.1&lt;/strong>에 따라 사용이 허가되었습니다.&lt;/p>
&lt;p>&lt;img src="/1/01/files-you-would-better-to-know-while-contributing-oss-projects/images/2.png">&lt;/p>
&lt;blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align: left">라이선스의 특징 및 의무사항&lt;/th>
&lt;th style="text-align: center">GPL 2.0&lt;/th>
&lt;th style="text-align: center">GPL 3.0&lt;/th>
&lt;th style="text-align: center">&lt;strong>LGPL&lt;/strong>&lt;/th>
&lt;th style="text-align: center">AGPL 3.0&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align: left">복제·배포·수정의 권한 부여&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">배포시 라이선스 사본 첨부&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">저작권고지사항 또는 attribution 고지사항 유지&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">배포시 소스코드 제공 의무(reciprocity)와 범위&lt;/td>
&lt;td style="text-align: center">derived work&lt;/td>
&lt;td style="text-align: center">work based on the program&lt;/td>
&lt;td style="text-align: center">&lt;strong>derived work&lt;/strong>&lt;/td>
&lt;td style="text-align: center">derived work&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">조합저작물(larger work) 작성 및 타 라이선스 배포 허용&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">수정시 수정내용 고지&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">명시적 특허라이선스의 부여&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">&lt;strong>​&lt;/strong>&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">라이선시가 특허소송 제기시 라이선스 종료&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">&lt;strong>​&lt;/strong>&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">이름, 상표, 상호에 대한 사용제한&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;td style="text-align: center">&lt;strong>​&lt;/strong>&lt;/td>
&lt;td style="text-align: center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">보증의 부인&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align: left">책임의 제한&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;td style="text-align: center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align: center">◯&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;cite>© 오픈소스 소프트웨어 라이선스 가이드 3.0&lt;/cite>&lt;/p>
&lt;/blockquote>
&lt;h3 id="마무리">마무리&lt;/h3>
&lt;p>위의 3가지 파일 외에도 릴리즈 가이드가 있는 ****&lt;a href="https://github.com/planetarium/libplanet/blob/main/RELEASE.md">RELEASE.md&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet/blob/main/CHANGES.md">CHANGES.md&lt;/a>**들이 있습니다.&lt;/p>
&lt;p>README 파일, CONTRIBUTING 파일, LICENSE 파일을 통해서 오픈 소스 프로젝트인 립플래닛을 소개했습니다. 꼭 립플래닛이 아니어도 좋습니다. 여러분들의 미래를 위해 오픈 소스 프로젝트에 기여하는 것을 추천드립니다. 물론 립플래닛 저장소와 디스코드 서버에서 만나면 더욱 좋고요.&lt;/p>
&lt;p>책 ‘오픈 소스로 미래를 연마하라&amp;rsquo;에 써있는 래블업 CEO 신정규님의 추천사로 글을 마무리할까 합니다.&lt;/p>
&lt;blockquote>
&lt;p>오픈 소스 문화는 사람의 문화입니다. 그래서 코드만큼 빨리 변하지 않습니다. 오픈 소스 소프트웨어의 코드를 만드는 주체는 서로를 잘 모르는 사람들입니다. 서로 모르는 사람들이 프로그램의 기능이라는 목표를 이루기 위해 지켜야할 규칙이 존재하고, 한 명의 머리로 따라가기 힘든 방대한 양의 코드를 관리하기 위한 다양한 기술적, 문화적 장치가 있습니다. 그러한 ‘문화&amp;rsquo;와 ‘방법론&amp;rsquo;에 대해 이해라는 것이 오픈 소스 생태계에 뛰어들기 위해 필요한 일입니다. 하지만 그만큼 복잡하기에 배우기 쉽지 않기도 합니다.&lt;/p>
&lt;/blockquote></content><author><name>황혜경</name><uri>https://github.com/hyekyunghwang</uri><email>hyekyung@planetariumhq.com</email></author></entry><entry><title>세상을 늦게 보기 위해 잃었던 것들</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/03/things-i-lost-to-see-the-world-late/" title="세상을 늦게 보기 위해 잃었던 것들"/><link rel="alternate" href="https://snack.planetarium.dev/1/01/things-i-lost-to-see-the-world-late/" hreflang="" title=""/><id>https://snack.planetarium.dev/kor/2022/03/things-i-lost-to-see-the-world-late/</id><published>2022-03-29T00:00:00+00:00</published><updated>2022-03-29T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 플라네타리움 엔진팀에서 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>을 개발하고 있는 이수호입니다.
오늘은 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>을 개발하면서 생겼던 문제 중 블록체인에서 흔히 말하는 확정(&lt;code>Confirmation&lt;/code>)으로 인해 생긴 문제와
그 문제를 발견하고 해결하는 과정을 이야기하고자 합니다.&lt;/p>
&lt;h2 id="확정confirmation">확정(&lt;code>Confirmation&lt;/code>)&lt;/h2>
&lt;p>블록체인에서의 블록은, 어떠한 사건이라고 볼 수 있고 체인은 사건으로 이루어진 일련의 시간 흐름이라고 볼 수 있습니다.
이전의 시간 흐름과는 맞지 않는 사건이 발생했을 때, 관측자는 이 사건을 올바르지 않은 사건으로 분류하고 거절합니다.
이 &amp;lsquo;올바른 사건&amp;rsquo;이라는 규칙을 대다수가 공유하고 있다면, 사건들만 순서대로 공유했을 때에 모두가 같은 현상을 관측하고 있다고 할 수 있습니다.&lt;/p>
&lt;p>하지만, 이 서로 다른 &amp;lsquo;올바른 사건&amp;rsquo;이 동시다발적으로 제출된다면 어떻게 될까요?
일시적으로 관측자들 사이에 혼란이 생길 것이지만 결과적으로는 올바른 시간대를 바라보게 됩니다.
하지만 이 혼란으로 인해 관측하고 있는 정보를 기반으로 하고 있는 다른 사용자들은 혼란을 겪게 됩니다.&lt;/p>
&lt;p>예를 들면. 방금 전 사건까지만 해도 분명히 100원이 있었는데, 이 사건이 없던 걸로 되어서 0원이 되어 버린다던가 하는 일들이 생길 수 있습니다.&lt;/p>
&lt;p>이를 막기 위해 사용자는 확정(&lt;code>Confirmation&lt;/code>) 이라는 &amp;lsquo;여기서부터는 뒤집히지 않는다&amp;rsquo; 라는 수치를 두고,
이 수치 이전까지는 블록이 들어와도 체인에 받지 않습니다.
세상을 늦게 보고 확실해질 때 까지 기다리는 것이죠.&lt;/p>
&lt;h2 id="libplanet-에서의-확정confirmation과-렌더러renderer">Libplanet 에서의 확정(&lt;code>Confirmation&lt;/code>)과 렌더러(&lt;code>Renderer&lt;/code>)&lt;/h2>
&lt;p>Libplanet 은 이 확정(&lt;code>Confirmation&lt;/code>)을 지원하고 있습니다. 정확히는 렌더링 과정에서 확정(&lt;code>Confirmation&lt;/code>)을 거칩니다.
이 렌더링 역할을 해 주는 렌더러(&lt;a href="https://docs.libplanet.io/0.30.0/api/Libplanet.Blockchain.Renderers.IRenderer-1.html">Renderer&lt;/a>)는 블록체인의 상태를 수신해서 변경이 일어났을 경우
해당 렌더러의 콜백을 블록체인의 이전 상태,현재 상태와 함께 호출해 주는 역할을 가지고 있습니다.&lt;/p>
&lt;p>이 중에서도 지연 렌더러(&lt;a href="https://docs.libplanet.io/0.30.0/api/Libplanet.Blockchain.Renderers.DelayedRenderer-1.html">DelayedRenderer&lt;/a>)는 블록 자체를 늦게 인지하는 것이 아닌 블록을 전부 인지 및 연산한 후에
렌더링 하는 부분만 가지고 있다가 수치가 넘어가면 감싸고 있는 렌더러(&lt;a href="https://docs.libplanet.io/0.30.0/api/Libplanet.Blockchain.Renderers.IRenderer-1.html">Renderer&lt;/a>)에 보내줍니다.&lt;/p>
&lt;p>더 자세한 정보는 &lt;a href="https://docs.libplanet.io/0.30.0/api/Libplanet.Blockchain.Renderers.DelayedRenderer-1.html">DelayedRenderer&lt;/a>에서 확인할 수 있습니다.&lt;/p>
&lt;h2 id="문제-발생">문제 발생&lt;/h2>
&lt;p>어느 순간, 사용자들에게서 메모리 사용량이 급증한다는 제보를 받았습니다. 켜놓은 지 약 1시간이 지나면 메모리 누수가 심각하게 일어나는 것을 확인할 수 있었습니다.
특정하는 것은 어렵지 않았습니다. &lt;a href="https://www.jetbrains.com/ko-kr/dotmemory/">dotMemory&lt;/a>를 사용하니 어떤 클래스에서 메모리를 가장 많이 사용하는지 특정할 수 있었습니다.&lt;/p>
&lt;figure>&lt;img src="/1/01/things-i-lost-to-see-the-world-late/images/dot-memory.png"
alt="DelayedActionRenderer 가 가장 많은 메모리 사용량을 차지하고 있는 dotMemory 분석 결과">&lt;figcaption>
&lt;p>DelayedActionRenderer 가 가장 많은 메모리 사용량을 차지하고 있는 dotMemory 분석 결과&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>문제는 다음입니다. 왜 메모리 누수가 일어났을까? 눈치가 빠르거나 경험이 많으신 분들은 이미 눈치채셨을지도 모르겠습니다.&lt;/p>
&lt;h2 id="원인-및-해결">원인 및 해결&lt;/h2>
&lt;p>앞에서 언급했던 문구를 다시 가져와 보겠습니다&lt;/p>
&lt;blockquote>
&lt;p>이를 막기 위해 사용자는 확정(&lt;code>Confirmation&lt;/code>) 이라는 &amp;lsquo;여기서부터는 뒤집히지 않는다&amp;rsquo; 라는 수치를 두고,
이 수치 이전까지는 블록이 들어와도 체인에 받지 않습니다.
세상을 늦게 보고 확실해질 때 까지 기다리는 것이죠.&lt;/p>
&lt;/blockquote>
&lt;p>힌트는 &lt;em>여기서부터는 뒤집히지 않는다&lt;/em> 입니다.
작업 기반 증명(Proof-Of-Work, PoW)에서는 합의 무결성(Safety)를 보장할 수 없기 때문에, 이것은 그 누구도 보장할 수 없습니다.&lt;/p>
&lt;p>따라서 사용자가 지정한 이 확정(&lt;code>Confirmation&lt;/code>) 을 체인 안쪽까지 끌어와서
블록체인 네트워크 엔지니어가 경계 값(Threshold)을 지정할 수 있게 하는 작업이 필요했습니다.
해당 작업의 결과는 &lt;a href="https://github.com/planetarium/libplanet/pull/1163">#1163&lt;/a> PR에서 보실 수 있습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>일련의 모든 블록체인 합의 과정에서의 설명은 모두 작업 기반 증명(Proof-Of-Work, PoW)을 기반으로 설명되었습니다.
지분 기반 증명(Proof-Of-Stake, PoS)나 다른 합의 알고리즘에서는 필요 없는 이야기일 수도 있습니다.&lt;/p>
&lt;p>설명이 조금 모자라거나 틀린 부분이 있으면 의견 남겨주시면 감사하겠습니다.&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry></feed>