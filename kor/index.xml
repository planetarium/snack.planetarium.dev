<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><title>플라네타리움 엔지니어링 스낵</title><link rel="self" href="https://snack.planetarium.dev/kor/index.xml"/><link rel="alternate" href="https://snack.planetarium.dev/kor/" title="플라네타리움 엔지니어링 스낵"/><link rel="alternate" href="https://snack.planetarium.dev/eng/" hreflang="" title="Planetarium Engineering Snack"/><updated>2024-03-12T00:00:00+00:00</updated><id>https://snack.planetarium.dev/kor/</id><entry><title>Libplanet 4.0 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2024/03/libplanet-4.1.0/" title="Libplanet 4.0 릴리스"/><id>https://snack.planetarium.dev/kor/2024/03/libplanet-4.1.0/</id><published>2024-03-12T00:00:00+00:00</published><updated>2024-03-12T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 네 번째 메이저 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/4.0.0">4.0 버전&lt;/a>이
릴리스되었습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&lt;/p>
&lt;p>이번 버전부터 Libplanet은 상태를 조금 더 효율적으로 다루기 위해, 여러 &lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.State.Account.html">Account&lt;/a>
를 다룰 수 있는 &lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.State.World.html">World&lt;/a> 를 도입하였고, 버전 마이그레이션을 큰 문제 없이 할 수 있도록
여러 API를 제공하고 있습니다.&lt;/p>
&lt;p>이 글에서는 4.0 버전의 주요 변경 사항들에 대해서 다루겠습니다.&lt;/p>
&lt;h2 id="여러-sub-state-를-들-수-있게-된-libplanet">여러 Sub-state 를 들 수 있게 된 Libplanet&lt;/h2>
&lt;p>그동안 Libplanet 은 단 하나의 상태 저장소 만을 가질 수 있었습니다. 이는 초기 개발에는 복잡한
&lt;code>Sub-state&lt;/code> 유도 과정 등을 생략하고, 하나의 공유 데이터를 사용함으로써 많은 이점을 가질 수 있었습니다.&lt;/p>
&lt;p>하지만 게임의 규모가 커짐에 따라, 한 Address 가 여러 상태 모델을 가지고 싶어하는 상황이 생겼습니다.
Libplanet 은 그동안 해당 Address 로부터 유도 된 새로운 Address 에 모델을 저장하는 방식을 채택하였습니다.
그래프로 그리면 다음과 같습니다.&lt;/p>
&lt;pre class="mermaid">flowchart LR
A[User Address] -->|"Derive(User, 'Avatar')"| B[Avatar Address]
A --> |"Get(User Address)"| S[Storage]
B --> |"Get(Avatar Address)"| S
&lt;/pre>
&lt;p>이는 한 스토리지에 여러 데이터를 저장하게 되어 성능이나 권한 문제에서 자유로울 수 없었습니다.&lt;/p>
&lt;p>이런 문제를 해결하기 위해, Libplanet 은 기존의 하나 밖에 없던 &lt;a href="https://docs.libplanet.io/3.6.0/api/Libplanet.Action.State.Account.html">&lt;code>Account&lt;/code>&lt;/a>를
&lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.State.IWorldState.html#Libplanet_Action_State_IWorldState_Legacy">&lt;code>World.Legacy&lt;/code>&lt;/a> 로 만들고, &lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.State.IWorld.html">&lt;code>World&lt;/code>&lt;/a> 밑에 여러 &lt;a href="https://docs.libplanet.io/3.6.0/api/Libplanet.Action.State.Account.html">&lt;code>Account&lt;/code>&lt;/a> 를 가질 수 있게 하였습니다.&lt;/p>
&lt;pre class="mermaid">flowchart LR
A[User Address] --> |"Get(User)"| S1["Avatar Storage"]
A[User Address] --> |"Get(User)"| S2["Agent Storage"]
S1 --> Avatar
S2 --> Agent
&lt;/pre>
&lt;p>이런 문제로, 이전과 같이 직접적으로 &lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.IActionContext.html#Libplanet_Action_IActionContext_PreviousState">&lt;code>IActionContext.PreviousState&lt;/code>&lt;/a> 혹은
&lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.IActionEvaluation.html#Libplanet_Action_IActionEvaluation_OutputState">&lt;code>IActionEvaluation.OutputState&lt;/code>&lt;/a>로부터 데이터를 읽어 올 수는 없습니다. 따라서
&lt;a href="https://docs.libplanet.io/4.1.0/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Execute_Libplanet_Action_IActionContext_">&lt;code>IAction.Execute()&lt;/code>&lt;/a>안에서의 API 는 다음과 같이 변경됩니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>IWorld world = context.PreviousState
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IAccount avatarAccount = world.GetAccount(&lt;span style="color:#080;font-weight:bold">new&lt;/span> Address(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;0x0000000000000000&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IValue avatarList = avatarAccount.GetState(context.Signer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IAccount agentAccount = world.GetAccount(&lt;span style="color:#080;font-weight:bold">new&lt;/span> Address(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;0x0000000000000001&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IValue agent = agentAccount.GetState(context.Signer)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>각 도메인에 맞는 &lt;code>Account&lt;/code> 를 가져오는 점에 주의하십시오.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 외에도 여러 성능 개선이나 자잘한 마이너 패치가 있었습니다. 자세한 내용은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/4.0.0">전체 변경 내용&lt;/a> 에서 확인해 주세요.&lt;/p>
&lt;p>질문이나 관심이 있으신 분들은 또한 저희 &lt;a href="https://discord.gg/YaHPjcrdrw">Discord&lt;/a> 채널에 놀러와 주세요!&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>온체인 게임의 미해결 과제 (번역)</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2023/08/paradigm-onchain-game-kr-translation/" title="온체인 게임의 미해결 과제 (번역)"/><id>https://snack.planetarium.dev/kor/2023/08/paradigm-onchain-game-kr-translation/</id><published>2023-08-24T00:00:00+00:00</published><updated>2023-08-24T00:00:00+00:00</updated><content type="html">&lt;p>크립토 업계의 대표 벤처캐피탈 &lt;a href="https://paradigm.xyz">패러다임(Paradigm)&lt;/a>이 지난 8월 14일에 공유한, 온체인 게임이 나아갈 방향과 그 과정에서 고민할만한 점을 다룬 글이 공감되어 한국어로 번역해보았습니다.&lt;/p>
&lt;p>원문: &lt;a href="https://www.paradigm.xyz/2023/08/onchain-games">The Open Problems of Onchain Games&lt;/a>&lt;/p>
&lt;p>저자: &lt;a href="https://www.paradigm.xyz/team/charlienoyes">Charlie Noyes (General Partner)&lt;/a>, &lt;a href="https://www.paradigm.xyz/team/dougfeagin">Doug Feagin (Investment Partner)&lt;/a>&lt;/p>
&lt;h1 id="목차">목차&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#창발emergence을-이끌어내기-위한-설계">창발을 이끌어내기 위한 설계&lt;/a>
&lt;ul>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#모드mods">모드&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#개방된-경제-구조">개방된 경제 구조&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#온체인-게임">온체인 게임&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#미해결-과제">미해결 과제&lt;/a>
&lt;ul>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#기술적-제약들이-게임-디자인을-제한한다">기술적 제약들이 게임 디자인을 제한한다.&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#조합-가능성은-태생적으로-금융화로-이어진다">조합 가능성은 태생적으로 금융화로 이어진다.&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#메타게임은-침체-되기-마련이다">메타게임은 침체 되기 마련이다.&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#게임은-완전히-온체인이어야-하는가">게임은 완전히 온체인이어야 하는가&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#결론">결론&lt;/a>&lt;/li>
&lt;li>&lt;a href="/kor/2023/08/paradigm-onchain-game-kr-translation/#감사의-말">감사의 말&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>게임과 크립토가 교차하는 지점엔 가능성이 많아 보입니다. 비탈릭이 월드 오브 워크래프트에서 흑마법사를 플레이 하던 중 &lt;a href="https://about.me/vitalikbuterin">너프를 먹고 이더리움을 만들기로 마음 먹었다&lt;/a>는 건 유명한 일화이죠. 와우는 핵심 인프라는 아니었지만, 가상 세계가 앞으로 대규모의 자산을 저장하고 일자리를 제공하는 핵심 인프라가 될 것이라는 예상은 많은 사람들이 하고 있습니다. 그런 세계가 몇몇 중앙화된 플랫폼에 의해 지배될 것이라는 건 상상하기 어렵습니다.&lt;/p>
&lt;p>물론, 탈중앙화 어플리케이션은 이론 상 훌륭하게 들립니다. 그 중 가장 매력적인 부분은 크립토이기 때문에 가능해지는 것들이죠. 바로 온체인에서만 생겨날 수 있는 어플리케이션들 말입니다. 하지만 그동안 여러 내러티브가 등장하고 사라졌음에도 불구하고, 오직 온체인 게임만이 할 수 있는게 무엇인지 정확히 파악하기는 어려운 상황입니다.&lt;/p>
&lt;p>&lt;em>도대체 왜 게임을 블록체인에 올리나요?&lt;/em>&lt;/p>
&lt;p>이 질문에 대한 저희의 생각을 이 포스팅에 정리해보았습니다.&lt;/p>
&lt;h1 id="창발emergence을-이끌어내기-위한-설계">창발(emergence)을 이끌어내기 위한 설계&lt;/h1>
&lt;p>몇몇 게임은 창의적인 플레이어들이 새로운 컨텐츠(“UGC”)를 직접 만들 수 있는 툴을 제공함으로써 플레이어들이 더 오래 게임에 머물게 만들었습니다. UGC의 가장 큰 원천인 모드와 개방된 경제 구조는 온체인 게임이 앞서 나갈 가능성이 있는 “공격 벡터”입니다.&lt;/p>
&lt;h2 id="모드mods">모드(Mods)&lt;/h2>
&lt;p>모드란 서드 파티 개발자들이 게임의 원작자가 의도한 범위를 넘어서는 컨텐츠를 만들 수 있게 해주는 것을 말합니다. 새로운 장르를 개척한 게임 중 여럿(예: 도타, 롤, 펍지)이 다른 게임의 모딩된 버전에서 시작되었습니다. 로블록스 같은 게임들은 게임 자체를 모드 개발자 플랫폼으로 바꿔버리기도 했습니다. 게임 스튜디오들은 완성품의 가치(품질)을 중시하지만, 활발한 모더 커뮤니티는 다양성과 참신함을 중시하죠. 넷플릭스와 유튜브처럼요.&lt;/p>
&lt;p>마인크래프트는 아주 좋은 예시입니다. 게임 메카닉이 단순해 이것저것 만들어보기 좋죠. 그 메카닉을 확장하는 모드들은 서로 합쳐져서 새로운 경험을 만들어내기도 합니다. 탈옥이나 배틀로얄 같은 유명한 마인크래프트 서버들은 오리지널 마인크래프트랑은 완전히 다르죠.&lt;/p>
&lt;p>그러나 그런 마인크래프트도 한계를 갖고 있습니다. 이미 존재하는 서버에는 플레이어들이 모드를 추가할 수 없다는 점입니다. 무언가 변경하려면 서버를 새로 만들어야 합니다. 그 결과, 마인크래프트 “유니버스”는 수많은 병렬적인, 교류가 없는(non-interacting) 프라이빗 서버들로 쪼개져 있습니다.&lt;/p>
&lt;p>많은 게임들이 모딩을 구현할 때 이미 존재하는 시스템의 스크립트를 수정하는 방식이 아니라 마인크래프트처럼 새 서버를 띄우는 방식(instancing)으로 하는 데에는 여러 그럴만한 이유가 있습니다. 플레이어들이 추가한 코드가 게임의 기본 규칙들과 잘 호환되도록 하는 건 어려운 일입니다. 그게 취약점을 공격하는 코드라면 특히 문제이죠. 기본 규칙을 업데이트 하는 경우엔 이미 올라와 있는 모드들을 고장 낼 수도 있구요. 한정된 연산 자원도 똑똑하게 배분되어야 합니다.&lt;/p>
&lt;p>하지만 서버를 새로 띄우는 방식은 파편화로 이어집니다. 새 서버로 띄워진 모드들은 플레이어들의 관심을 받기 위해 다른 모든 서버들과 경쟁을 하게 됩니다. 모더들은 단순히 어떤걸 추가하면 재밌을지 고민하는 대신, 변경 사항이 새 서버를 만들만큼 가치가 있는지를 고민해야 하죠.&lt;/p>
&lt;p>많은 모드 아이디어들이 이미 존재하는 세계에 무언가를 추가한다는 &lt;em>컨텍스트 안에서만&lt;/em> 말이 된다는 점을 생각해보세요. 당신이 어떤 마인크래프트 서버에서 식당을 운영 중인데 새 메뉴를 추가하고 싶다고 가정해보죠. 이런 상황에서 새 서버를 띄운다는 건 말이 안됩니다. 손님들이 새 서버로 옮겨오도록 설득해야 하는데, 그 손님들도 이미 이 서버에 시간과 돈을 투자해 확보한 자산과 고객들이 있으니 옮기지 않을 것이기 때문이죠.&lt;/p>
&lt;p>게임 세계가 파편화되면, 확장을 점진적으로 할 수 있는 능력을 잃어버립니다.&lt;/p>
&lt;h2 id="개방된-경제-구조">개방된 경제 구조&lt;/h2>
&lt;p>게임 내 경제는 플레이어의 창의력 측면에서 거의 무한한 잠재력을 가진 또다른 차원입니다. 여기선 최초로 전업 경제학자를 직원으로 채용했던 최초의 게임인 이브 온라인을 가지고 설명해보겠습니다.&lt;/p>
&lt;p>이브 온라인 플레이어들은 게임 내 시스템과 외부 인프라를 비공식적으로 조합하여 물건을 생산하고 거래하고, 영역을 획득하고 빌려주고 소유권 경쟁을 벌이며, 산업 공동체부터 전쟁광 집단까지 다양한 조직을 만듭니다. 자원 운송 같이 단순한 임무들은 해당 임무 수행을 위해 만들어져 &lt;a href="http://www.pushx.net/">플레이어들에 의해 운영되는 기업&lt;/a>들이 있는데, 그 기업들은 고객 응대, 서비스 사용 계약, 피고용인을 위한 복리후생제도까지 완벽히 갖춰져 있습니다.&lt;/p>
&lt;p>플레이어들은 개발사로부터 제공되는 새로운 컨텐츠 때문이 아니라, 또다른 플레이어들에 의해 수많은 사건이 벌어지는 사회 경제적 세계 때문에 20년 넘게 이브온라인을 플레이하고 있습니다.&lt;/p>
&lt;p>그러나 이런 이브 온라인의 경제 시스템조차도 큰 한계를 갖고 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>한정된 게임 내 기초 요소&lt;/strong>: 개발사에 의해 정의된 기초 요소의 범위를 벗어나는 거래(예: 대여 계약)는 비공식적인, 강제 집행이 불가능한 신뢰 기반 네트워크에 의존해야 합니다. 그런 신뢰는 창발적인 경제 구조의 복잡성과 규모를 제한합니다.&lt;/li>
&lt;li>&lt;strong>규제 측면의 제약&lt;/strong>: 규제 관련 고민을 피하기 위해, 이브 온라인을 포함한 대부분의 게임들이 게임 내 재화나 서비스를 현금(fiat)으로 교환하는 것을 금지합니다. 이를 허용하는 게임들은 부담스런 조건에 동의하는 경우에만 현금 거래를 허용하며, 이를 위해 대규모의 준법 부서를 운영해야 합니다.&lt;/li>
&lt;/ul>
&lt;h1 id="온체인-게임">온체인 게임&lt;/h1>
&lt;p>크립토 네이티브 게임은 여러가지 형태를 가질 수 있습니다. 저희는 가장 크립토 네이티브한, 스펙트럼의 끝 부분에 있는 &lt;em>완전 온체인 게임(fully onchain game)&lt;/em> 에 관심을 갖고 있습니다. 오픈된 스마트 컨트랙트 플랫폼에 상태값과 로직이 전부 올라가 있는 형태 말이죠.&lt;/p>
&lt;p>온체인 게임 모드들이 자체 컨트랙트의 형태로 특별한 허가 없이 기본 게임 로직들과 함께 배포될 수 있는 것도 중요합니다. 사용자가 자신의 클라이언트에서 실행할 모드를 선택할 수 있는 것(관리자가 모드를 정하는게 아니라)도 중요합니다.&lt;/p>
&lt;p>그래서, &lt;em>왜 게임을 블록체인에 올리죠?&lt;/em> 저희는 다음의 두가지 포인트가 핵심이라고 생각합니다.&lt;/p>
&lt;ol>
&lt;li>&lt;strong>조합 가능한 모딩(composable modding)&lt;/strong>: 플레이어는 온체인 게임에 허가를 받거나 상태값을 파편화시키는 일 없이 모드를 추가할 수 있습니다. 온체인 인프라와 스마트 컨트랙트 개발자들은 누구나 허가 없이 코드를 업로드 할 수 있게 하기 위한 것들에 이미 익숙합니다. 보안 감사, 권한 관리, 자원 미터링 같은 것들이죠. 기존 게임들은 이런 환경이 도입되어있지 않고, 그들이 조합 가능한 모딩을 지원하기 위해 스스로 구조를 재편할 것 같진 않습니다.&lt;/li>
&lt;li>&lt;strong>무허가형 개방 경제(permissionless open economies)&lt;/strong>: 게임 개발자가 정의한 게임 내 기초 요소에 의해 제한되거나, 비공식적이고 강제 집행이 불가능한 계약에 의존하는 대신, 플레이어들은 게임 경제를 만들기 위해 스마트 컨트랙트를 사용할 수 있습니다. 게다가 게임 자산을 플레이어가 스스로 수탁하는 구조는 규제 준수 관련 부담을 없애주죠.&lt;/li>
&lt;/ol>
&lt;p>어쩌면 조합 가능한 모딩은 온체인 게임에 의해 가능한 “고유 특성”이라기보다, 경로 의존적인 혁신일지도 모릅니다. 기존 게임들은 조합 가능한 모딩을 지금도 지원할 수 있음에도 현재 지원하고 있지 않으며, 딱히 그걸 바꿀만한 인센티브도 없습니다. 이 모델은 그럴 필요가 있을 때에만 연구 될 것입니다 (즉, 크립토에서 말이죠).&lt;/p>
&lt;p>조합 가능한 모딩과 무허가형 경제의 조합이야말로 대규모의 창발적인 온체인 게임 세계를 만들어낼 수 있습니다. 모더들은 단순한 기본 규칙 조합들을 가져다 새로운 모드 컨텐츠로 확장합니다. 그들은 현금 거래 시장에 대한 접근성, 디파이 시장과의 가까운 거리, 실험할 수 있는 자유를 얻을 것입니다. 그 결과로 나타나는 경제는 매우 복잡할 것이며, 축적되는 컨텐츠를 생성하도록 반사적으로 인센티브를 부여할 것입니다. 실제로 거기서 돈이 벌린다는게 명확해지는 순간, 다른 크립토 어플리케이션 생태계를 탄생시켰던것과 동일한 투기-실험 사이클(speculation-experimentation cycle)을 거치며 활동이 폭발적으로 증가할 것입니다.&lt;/p>
&lt;p>대부분의 온체인 게임 논의는 그런 희망찬 미래를 상세히 그리곤 합니다. 저희는 그 곳까지 도달하는 과정에 어떤 것들이 있을지에 더 관심이 많습니다. 대규모 게임 세계가 등장할만한 상황이 되기 위해 먼저 해결되어야 하는 과제들 말이죠.&lt;/p>
&lt;h1 id="미해결-과제">미해결 과제&lt;/h1>
&lt;h2 id="기술적-제약들이-게임-디자인을-제한한다">기술적 제약들이 게임 디자인을 제한한다.&lt;/h2>
&lt;p>온체인 게임이 아직 성공하지 못한 이유에 대한 일반적인 추측은, 기술 인프라가 아직 갖춰지지 않았기 때문에 대부분의 게임이 개념 증명(proof-of-concept) 단계를 벗어나지 못했다는 것입니다. 그렇기 때문에 게임 플레이는 단순하고, 클라이언트는 버그가 많으며, 게이머들과 모드 개발자들의 참여도는 지지부진한 상태를 유지하고 있다는 것이죠.&lt;/p>
&lt;p>현재의 인프라와 개발 툴들은 한계가 있습니다. 특히 EVM은 느리고 낡았고, 현재의 솔리디티 데이터 모델은 복잡한 게임 개발에 적합하지 않으며, 어느 메인넷 체인도 게임을 배포하기에는 적합하지 않습니다 (높은 비용과 낮은 성능을 고려하면요).&lt;/p>
&lt;p>다행히도, 이 문제들의 대부분이 해결되어가는 모습이 보이고 있습니다. 크립토 커뮤니티는 롤업의 확장 가능성과 비용 감소 추세를 이미 분명히 느끼고 있습니다. 게임에 특화된 인프라를 만드는 팀도 다수 존재합니다. 예를들면, &lt;a href="https://lattice.xyz/">Lattice&lt;/a>는 EVM 게임 개발을 단순화 하는, 솔리디티 프레임워크와 호환 가능한 툴링 (인덱싱, 상태 동기화 등)을 개발하고 있습니다. &lt;a href="https://www.dojoengine.org/">Dojo&lt;/a>, &lt;a href="https://argus.gg/">Argus&lt;/a>, &lt;a href="https://github.com/curio-research/keystone">Curio&lt;/a> 등도 인프라 플랫폼을 개발 중입니다.&lt;/p>
&lt;p>어쩌면 온체인 게임의 본질적인 측면에서는 다른 문제들이 더 중요하다고 느껴질지도 모르겠습니다. 특히, 무허가형 블록체인의 특정 요소들은 핵심적인 게임 디자인 메카닉과 배치되기도 합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;strong>불완전한 정보&lt;/strong>: 불완전한 정보는 많은 게임에서 핵심적인 메카닉입니다. 현존하는 블록체인 상에서의 해법들은 수용하기 어려운 단점들을 가지고 있습니다 (예: 다크포레스트의 &lt;a href="https://dev-guides.zkga.me/mining/what-is-mining">암호학적 전장의 안개&lt;/a>는 하드웨어 채굴 경쟁으로 귀결됩니다)&lt;/li>
&lt;li>&lt;strong>자동화 &amp;amp; 담합&lt;/strong>: 근본적으로 막을 수 없습니다. 봇은 실제 플레이어와 구분이 불가능하며, 각 플레이어가 고유하다는 것을 보장할 수 없습니다(역자주: 한 명이 여러 캐릭터를 플레이 할 수 있습니다). 게임 개발자는 봇 메타나 시빌 담합(역자주: 한 명이 플레이하는 여러 캐릭터가 담합하는 행위)에도 무너지지 않는 게임을 만들어야만 합니다.&lt;/li>
&lt;li>&lt;strong>틱 시스템&lt;/strong>: 블록체인은 비동기적인 트랜잭션으로 운영됩니다. 대부분의 게임들은 플레이어의 행동과 무관하게 돌아가는 게임 내부의 틱 기반 루프에 따라 동작합니다.&lt;/li>
&lt;/ul>
&lt;p>이 세가지 제약들로 인해 오히려 창의력이 발휘되어 그동안 없던 새로운 형태의 게임 종류가 등장할 수도 있습니다. 기존 금융의 형태를 흉내내지 않고 디파이에서 독자적으로 등장한 MakerDAO나 Uniswap처럼 말이죠. 하지만 게임은 기술적인 측면과 규제적인 측면에서 겪어왔던 제약사항이 금융 대비 적기 때문에 이미 금융보다 더 넓은 영역을 탐색해보았고, 따라서 완전히 새로운 온체인 게임이 등장할 가능성은 낮아 보입니다. 저희는 온체인 게임이 크게 성공할 가능성을 확보하기 위해서는 이러한 제약사항들로부터 발전이 필요할 것이라고 생각합니다.&lt;/p>
&lt;h3 id="연구-방향">연구 방향&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>TEE&lt;/strong>: 목적 대비 과분한 것일 수 있지만, 신뢰 실행 환경(Trusted Execution Environment, TEE)은 퍼블릭 블록체인에서 무허가 형태로 비공개 연산을 수행하기 위한 유일한 현실적인 선택지입니다.&lt;/li>
&lt;li>&lt;strong>MACI&lt;/strong>: &lt;a href="https://ethresear.ch/t/minimal-anti-collusion-infrastructure/5413">당초 온체인 투표 시스템에서의 담합 방지를 위해 비탈릭 부테린에 의해 제안된 매커니즘(Minimal Anti-collusion Infrastructure)&lt;/a>인 MACI는 온체인 게임에 적용될 수 있을 것이며 적합한 게임 시스템이 있다면 긴밀하게 통합되어 개선될 가능성도 있습니다.&lt;/li>
&lt;li>&lt;strong>커스텀 롤업&lt;/strong>: 상태 전환 함수의 일부로 글로벌 틱이 포함되도록 롤업을 변경함으로써 기존 게임의 틱 루프를 (가스비 없이) 온체인에서 구현하는 것도 가능해 보입니다. 이런 식으로 각 게임의 요건에 맞게 변경이 진행되는 것도 흥미로울 것 같습니다.&lt;/li>
&lt;/ul>
&lt;p>비공개 상태값을 위해 영지식증명을 활용하는 것도 또다른 연구 방향입니다. 하지만 저희는 영지식증명으로 수행할 수 있는 프로그래밍 불가능한 비공개성(non-programmable privacy)이 유의미한 게임 메카닉을 구현하기 충분할지에 대해 회의적입니다. 현재 기준으로 회로 작성이 어렵다는 점 역시 사용을 어렵게 만드는 부분이구요.&lt;/p>
&lt;h2 id="조합-가능성은-태생적으로-금융화로-이어진다">조합 가능성은 태생적으로 금융화로 이어진다.&lt;/h2>
&lt;blockquote>
&lt;p>완전히 외부에 공개되어 있어 누구나 사용할 수 있는 시스템이라면, 인센티브는 단순히 “제안”이 아닙니다. 인센티브는 중력이나 엔트로피같은 물리 법칙에 더 가깝죠. 만약 시스템에 인센티브와 맞지 않는 부분이 있다면, 공격 당하는 것은 시간 문제입니다. (&lt;em>Nikolai Mushegian, &lt;a href="https://bank.dev/principles">bank.dev/principles&lt;/a>&lt;/em>)&lt;/p>
&lt;/blockquote>
&lt;p>스마트 컨트랙트 블록체인은 매우 적대적이며 모든 것을 금융화하는 환경입니다. 이 특성은 디젠(degen) 문화로 인해 경로 의존적으로 나타난 것이 아닙니다. 허가 없이 조합할 수 있다는 특성으로 인해 나타난 기계적인 결과이죠. 어플리케이션들이 조합 가능성을 전제로 하는 한, 온체인 게임은 이런 인센티브에 기초 요소 수준부터 노출될 수 밖에 없습니다.&lt;/p>
&lt;p>모드의 영향력 같은 것을 고려하기 전의 “진공 상태”에서부터, 온체인 게임 개발자들은 현금 거래 시장, MEV(프론트러닝 인센티브), 경제적 공격(착취)을 피할 수 없다는 사실과 씨름해야 할 것입니다. 인센티브를 안전하게 적용할 수 있는 온체인 게임을 만들기 위해 넘어야 하는 장벽은 꽤나 높을 것입니다. 안전한 디파이 프로덕트를 개발하는 것만큼이나요.&lt;/p>
&lt;p>2차적으로 발생하는 문제는 더욱 까다롭습니다. 온체인 게임은 모딩 되도록 설계되고, 모드들은 자체적인 인센티브 구조를 가질 것입니다. 게임의 핵심 인센티브를 관리하는데 능숙한 개발자 조차도 그 게임 위에 어떤 모드가 만들어질지, 어떤 인센티브 구조가 추가될지 알 수 없는 것입니다. (이런 예측 불가능한 창발성을 이끌어내는 것이 원래 그들의 목표이지만요)&lt;/p>
&lt;p>또다른 디파이 비유를 해보죠. 어떤 오라클을 하나 생각해봅시다. 이 오라클은 외부와 차단된 진공 상태에서는 (오라클을 조작 하더라도 이익이 나지 않는) 안전한 경제 구조를 가질지도 모릅니다. 하지만 어떤 어플리케이션이 오라클을 연동하고 사용할지는 예상할 수 없습니다. 만약 대출 프로토콜이 청산을 호출하기 위해 오라클을 사용하는 경우, 오라클을 조작할 인센티브가 생기게 됩니다. 자주, 심각하게요. 비슷한 예로, 어떤 마인크래프트 모드가 블록을 먼저 채굴하기 위해 MEV 인센티브를 도입하면, 이는 모든 플레이어들의 게임 플레이에 영향을 줄 것입니다. 심지어 그 모드를 적용하지 않은 클라이언트도 영향을 받겠지요.&lt;/p>
&lt;p>이는 고치기 어려운 문제입니다. 특정 개발자들만 모드를 개발할 수 있도록 허가하고 나머지는 제한하려는 시도는 창발성을 최대한 끌어내려는 노력과 직접적으로 배치되는 일입니다. 그게 바로 온체인 게임을 만드는 가장 큰 이유인데 말이죠.&lt;/p>
&lt;p>저희는 온체인 게임 디자인에 있어, 인센티브 구조를 자유롭게 붙일 수 있도록 만드는 것이 가장 큰 난관이 될 것이라고 생각합니다. 몇몇 게임들은 규제 준수에 따른 부담 때문에 현금 거래 시장을 피합니다. 한편 더 많은 다른 게임들은, 그냥 현금 거래 시장과 연동하는게 재미 없다고 생각해서 하지 않습니다. 온체인 게임은 금융화 압박에 소비되어버리지 않으면서 금융화 압박을 레버리지 할 수 있는 방법을 찾아야 할 것입니다.&lt;/p>
&lt;h3 id="연구-방향-1">연구 방향&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>부서지지 않는 게임 디자인&lt;/strong>: 핵심 게임 메카닉은 그 위에 어떤 모드가 생길지를 결정하는 게 아니라, 영향을 줄 수 있습니다. 시스템에 도움이 되는 모드들이 생기도록 하려면 어떤 온체인 게임이어야 하는지는 아직 확인되지 않았습니다. 어떤 종류의 게임 시스템이 N차 인센티브에 의한 오염으로부터 안전한지도 마찬가지이죠.&lt;/li>
&lt;li>&lt;strong>허가&lt;/strong>: 금융화를 직접적으로 저해하는 방법은 누가 온체인 게임을 플레이 할 수 있는지, 누가 새 코드를 덧붙일 수 있는지를 제한하는 것입니다. 창발성과는 명백한 트레이드 오프가 존재하지만, 거친 무허가 세계에 게임을 내보내기 전에 울타리 안에서 테스트를 해보는 것이 필요할지도 모릅니다. 그러면서 (단순한 화이트리스팅 이상으로) 어떻게 허가를 부여하면 좋을지도 배울 수 있을 것입니다.&lt;/li>
&lt;li>&lt;strong>오더 플로우 경매&lt;/strong>: 창발적인 인센티브를 막으려고 노력하는 대신 이를 활용하는 방법도 있습니다. 예를 들면, 모든 게임 트랜잭션이 오더 플로우 경매(order flow auction)를 거치게 하고, 그 수익금을 게임의 경제 수도꼭지으로 보내는 것이죠. 모드에 의해 만들어진 모든 가치들은 게임의 경제로 다시 돌아갈 것입니다 (예: 희귀한 물품을 재구매함으로써). 하지만 그러한 근본적인 동작들은 여전히 게임 플레이를 저해할 수도 있을 것입니다 (즉, 플레이어들은 태양을 운영하기 위한 석탄 탄광이 되는 셈입니다). (역자주: &lt;a href="https://writings.flashbots.net/order-flow-auctions-and-centralisation">오더 플로우 및 경매에 대한 플래시봇 팀의 글&lt;/a>)&lt;/li>
&lt;/ul>
&lt;h2 id="메타게임은-침체-되기-마련이다">메타게임은 침체 되기 마련이다.&lt;/h2>
&lt;p>온체인 게임은 필연적으로 기존 게임보다 더 긴 릴리즈 사이클을 가질 것입니다. 창발성을 최대화 하고 싶은데, 잦은 브레이킹 업데이트(역자주: 기존 프로그램들과 충돌이 날 수 있는 변경)는 창작자들이 그 세계에 기여하고 투자하려는 의욕을 꺾기 때문입니다. 업데이트를 하려면 보안 감사도 다시 받아야 합니다. 또한 많은 온체인 게임 개발자들은 무허가적인 “자치성(autonomy)” - 어드민 키와 업데이트가 없고 영원히 존재하는 구조 - 을 목표로 하기도 합니다.&lt;/p>
&lt;p>따라서 기술적인, 철학적인 이유로 온체인 게임은 자치성의 스펙트럼에서 “영원히 업데이트 없음” 과 “종종 업데이트 함” 의 사이 어딘가에 있을 것입니다.&lt;/p>
&lt;p>극단적으로 자치적인 온체인 게임의 가장 잘 된 케이스는 적절한 기본 규칙들이 적극적인 모더 커뮤니티와 끊임없는 창발적인 경험을 이끌어내는 형태일 것입니다. 어쩌면 수십년 동안 사람의 손이 닿지 않아야 가능해지는 경험들이 만들어질 수도 있을 것입니다.&lt;/p>
&lt;p>하지만 대부분의 게임들은 메타게임의 침체를 막기 위해 관리 운영되곤 합니다. 플레이어들은 기존 게임들에서 최적의 전략을 매우 잘 찾아 왔습니다. 게다가 MEV는 이에 대해 추가적인, 명시적인 인센티브를 제공하게 됩니다. 이런 최적 전략들은 게임을 정적으로 만들고, 재미 없게 만드는 경향이 있습니다. 정말 자치적인 세계는 메타게임을 제어하는 능력을 잃게 됩니다 - 비탈릭은 어쩌면 그의 (너프먹은) 흑마법사 캐릭터에 대해 잘못된 걱정을 했을지도 모르는 거죠.&lt;/p>
&lt;p>저희는 가장 중요한 질문은 내부적인 디자인 목표와 관련된게 아니라 이것이라고 생각합니다: 성공적인 온체인 게임은 어느 정도까지 자치적일 수 있는가?&lt;/p>
&lt;h3 id="연구-방향-2">연구 방향&lt;/h3>
&lt;ul>
&lt;li>&lt;strong>계절성(seasonality)&lt;/strong>: 많은 기존 게임들은 수개월에서 수년(와우 확장팩 같은) 주기로 업데이트를 진행합니다. 업데이트 주기는 창작자들이 향후에 동작하지 않을 수도 있는 복잡한 모드를 만들 의욕을 꺾을 수 있다는 점과 트레이드오프가 존재합니다. 저희는 이런 방식이 반복 실험 측면에서 더 가능성 있는 방법이 될 수 있다고 생각합니다(역자주: 온체인 게임에 맞는 업데이트 주기를 찾아야 한다는 의미로 보입니다).&lt;/li>
&lt;li>&lt;strong>자동 피드백 시스템&lt;/strong>: 비트코인이 해시레이트에 맞춰 채굴 난이도를 자동 조절하는 것처럼, 온체인 게임도 침체 방지용 조정 매커니즘을 내부에 가질 수도 있을 것입니다. 이는 온체인 게임에만 국한된 얘기는 아닙니다. 중앙화된 게임들은 이걸 더 강력하게 적용할 수 있습니다. 하지만 온체인 게임은 이것이 “필요하기 때문에” 혁신을 만들어낼 수 있을 것입니다.&lt;/li>
&lt;li>&lt;strong>독창적인 거버넌스 매커니즘&lt;/strong>: 저희는 기본적으로 &lt;a href="https://fehrsam.xyz/blog/governance-minimization">거버넌스 미니멀리스트&lt;/a>입니다만, 토큰 기반이 아닌 시스템에서 탐색해볼만한 흥미로운 지점이 있을 수 있다고 생각합니다. 새로운 규칙을 만드는 능력 자체를 게임의 핵심 루프 안에 넣을 수도 있을 것입니다 (예: &lt;a href="https://en.wikipedia.org/wiki/Mao_(card_game)">Mao&lt;/a>). 이미 시도된 케이스도 존재합니다. 예를 들면, Topology는 &lt;a href="https://topology.substack.com/p/topology-presents-isaac">특화된 거버넌스 시스템을 온체인 게임 Isaac에 타이트하게 통합시켰습니다.&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="게임은-완전히-온체인이어야-하는가">게임은 완전히 온체인이어야 하는가&lt;/h1>
&lt;p>허가 없이 조합 가능한 특성을 우아하게 레버리지한, 쉽게 접근할 수 있는 온체인 게임 디자인이 있을지도 모릅니다. 이런 세계는 오픈된 경제적인 인센티브가 새로운 컨텐츠의 끊임없는 생산을 유도함으로써 성장하고, 검열 당하지 않으며 검증 가능하게 중립적인 블록체인 위에 영원히 존재할 수 있겠지요.&lt;/p>
&lt;p>하지만 어쩌면 앞서 언급한 (사소하지 않은) 미해결 과제들을 해결하려는 행위를 정당화할 만큼의 실현 가능성은 없을지도 모릅니다. 또한, 기존 금융과는 다르게, 게임은 언제나 매우 실험적이었습니다. 따라서 일반적인 온체인 게임이 그 존재가치를 증명하기 위해 달성해야 하는 목표는 아이러니하게도 디파이보다 높아 보입니다. 디파이는 기존에 닫혀있던 시장을 다룬 것이기 때문이죠.&lt;/p>
&lt;p>만약 완전 온체인 게임이 어렵다면, 온체인 게임을 기대해야 하는 이유들을 좀 “덜 온체인스런” 방법으로 설명할 수도 있을 것입니다. 그런 게임들은 스마트 컨트랙트를 최소한으로 사용하거나, 아예 사용하지 않을 수도 있습니다. 오프체인 게임 인프라를 사용한 NFT 자산들과, 디파이와의 상호운용성이 적절한 현실적인 지점일지도 모릅니다. 특히 만약 오프체인 게임의 요소들이 온체인 자산들에 의해 제어된다면, 그 자산에 대한 스마트 컨트랙트 기반의 관리 시스템 만으로도 충분히 강력할 것입니다.&lt;/p>
&lt;p>마지막으로, 게임이 완전 온체인이 되건 되지 않건, 그 과정에서 탐색하는 패턴들 - 특히 조합 가능한 모딩 - 은 기존 게임 디자인 측면에서도 혁신을 만들어낼 수 있을 것입니다. 기존 스튜디오들이 가능성을 보고 유의미한 자원을 투자해 모드의 조합이 가능하도록 오프체인 엔진을 수정할지도 모르는 일입니다. 온체인 게임과 잠재적으로 함께 존재하거나, 능가하거나, 그 정신을 계승한 형태로요.&lt;/p>
&lt;h1 id="결론">결론&lt;/h1>
&lt;p>많은 난관이 있다는 것을 알고 있지만, 저희는 온체인 게임이 블록체인을 레버리지 함으로써 이상하고 독창적인 결과물을 만들어 낼 것이라고 직감하고 있습니다.&lt;/p>
&lt;p>저희는 다른 빌더들과 크립토 네이티브 게임의 모든 최전선을 함께 탐색하기를 기대합니다. 또한 인프라보다는 게임 자체를 만드는 것에 관심이 더 많습니다. 우리가 직접 즐길 수 있는 게임을요.&lt;/p>
&lt;p>이런 이야기에 흥미가 있으시다면, 여기로 연락주시기 바랍니다: {charlie,doug}@paradigm.xyz&lt;/p>
&lt;h1 id="감사의-말">감사의 말&lt;/h1>
&lt;p>이 글을 작성하기 위해 여러 시간을 기여해 준 동료 &lt;a href="https://twitter.com/transmissions11">t11s&lt;/a>에 감사 드리며, 함께 논의하고 리뷰 해 준 &lt;a href="https://twitter.com/matthuang">Matt Huang&lt;/a>, &lt;a href="https://twitter.com/danrobinson">Dan Robinson&lt;/a>, &lt;a href="https://twitter.com/_Dave__White_">Dave White&lt;/a>, &lt;a href="https://twitter.com/FrankieIsLost">Frankie&lt;/a>에게도 감사 드립니다.&lt;/p>
&lt;p>피드백을 준 &lt;a href="https://twitter.com/DangerWillRobin">Will Robinson&lt;/a>, &lt;a href="https://twitter.com/guiltygyoza">GuiltyGyzoa&lt;/a>, &lt;a href="https://twitter.com/nagual_ape">Rafael Morado&lt;/a>, &lt;a href="https://twitter.com/smsunarto">Scott Sunarto&lt;/a>, &lt;a href="https://twitter.com/bertcmiller">Robert Miller&lt;/a>, &lt;a href="https://twitter.com/0xhank">0xhank&lt;/a> 에게 감사드리며, 함께 논의 한 &lt;a href="https://twitter.com/l_udens">Ludens&lt;/a>, &lt;a href="https://twitter.com/phildaian">Phil Daian&lt;/a>, &lt;a href="https://twitter.com/jtguibas">John Guibas&lt;/a>, &lt;a href="https://twitter.com/ArthurRoingBaer">Arthur Roeing Bear&lt;/a>, &lt;a href="https://twitter.com/hilmarveigar">Hilmar Veigar Pétursson&lt;/a> 에게도 감사의 말을 전합니다.&lt;/p></content><author><name>이로운</name><uri>https://github.com/lounlee</uri><email>loun@planetariumhq.com</email></author></entry><entry><title>Libplanet PBFT 전환 제 0화 - 왜 PBFT로 전환을 시작했나요?</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2023/04/pbft-0/" title="Libplanet PBFT 전환 제 0화 - 왜 PBFT로 전환을 시작했나요?"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2023/04/pbft-0/" hreflang="" title="Libplanet PBFT Transitioner Episode 0 - Why did you switch to PBFT?"/><id>https://snack.planetarium.dev/kor/2023/04/pbft-0/</id><published>2023-04-24T00:00:00+00:00</published><updated>2023-04-24T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. Planetarium 에서 블록체인 디비전의 Libplanet 팀으로 근무하고 있는 이수호라고 합니다. 오늘은 Libplanet이 PBFT로 전환하게 된 계기와 그 과정에 대해 설명하는 글의 첫 번째 에피소드를 이야기하고자 합니다. 이 블로그 글에서는 Libplanet 블록체인의 합의 변경 과정, 변경 이유, 구체적인 변경 내용 및 새로운 합의 알고리즘의 이점에 대해 논의하겠습니다.&lt;/p>
&lt;h2 id="소개">소개&lt;/h2>
&lt;p>블록체인 기술은 혁신을 이루고 있으며, Libplanet은 주요 블록체인 엔진 중 하나입니다. &lt;code>Libplanet&lt;/code>은 .NET 플랫폼으로 구축된 고도로 확장 가능하고 탈중앙화된 오픈소스 플랫폼입니다. 이 플랫폼은 독특한 합의 알고리즘을 사용하여 네트워크 무결성을 보장하며, 높은 효율성과 안정성을 갖추고 있습니다.&lt;/p>
&lt;h2 id="nine-chronicles에-대해-이야기해-보겠습니다">Nine Chronicles에 대해 이야기해 보겠습니다.&lt;/h2>
&lt;p>2020년 이후 Nine Chronicles의 블록 생성 진화에 대한 이야기를 먼저 해 보고자 합니다. 처음에는 참여자들이 문제를 해결하는 &amp;ldquo;작업 증명(PoW)&amp;rdquo; 방법을 사용했었는데, 해결한 문제가 가장 어려우면서 짧은 시간 내에 해결한 블록이 선택되는 방식이었습니다. 그러나 이 방식에는 두 가지 큰 문제점이 있었습니다.&lt;/p>
&lt;ol>
&lt;li>가장 어려운 문제를 해결한 개인이 전체 커뮤니티에 이익이 되는 결정을 내릴 것임을 보장할 수 없었습니다. 경우에 따라 데이터가 포함되지 않은 블록이 생성되었으며, 문제가 더 어려울 경우 그것을 수용해야 했습니다.&lt;/li>
&lt;li>더 어려운 문제가 해결되고 총 난이도가 높은 블록이 생성되면, 이전 데이터가 변경될 수 있으므로 이상적이지 않았습니다.&lt;/li>
&lt;/ol>
&lt;p>이러한 문제로 인해 블록에 데이터가 없는 경우와 게임 진행의 롤백 등 게임 경험에 부정적인 영향을 미쳤습니다. 이에 따라, 2021년에는 Planetarium에서 Nine Chronicles의 Canonical chain 이 되기 위한 블록으로써 우리 자신이 만든 블록만 인정하기로 결정했습니다.&lt;/p>
&lt;p>그러나 우리는 Nine Chronicles에서 블록을 결정하는 유일한 권한을 가지고 싶지는 않았습니다. 우리의 초기 제안인 &lt;a href="https://docs.google.com/document/d/1ErZ5JQia03KqXRG6IRZ7SORfnxMLZfJg4patVKFGX5Y/edit#heading=h.sx6b2al62sji_">NCIP-10&lt;/a>은 여러 가지 이유로 결코 실현되지 않았습니다. 하지만 우리는 포기하지 않고 &lt;a href="https://docs.google.com/document/d/1L8d3KyO_Z6_BYcmDeMs-yv_SBYiEHiq_4kT0CjBmlFY">NCIP-13&lt;/a>을 제시하고 이를 확립했습니다. 2023년부터 PBFT 및 미래의 개발은 NCIP-13에 기반하여 이루어지며, 블록 생성 및 관리에 대한 더 강력하고 효과적인 접근 방식을 보장합니다.&lt;/p>
&lt;h2 id="블록체인-게임에서-작업-증명의-문제점">블록체인 게임에서 작업 증명의 문제점&lt;/h2>
&lt;p>Libplanet 팀으로서, 블록체인 게임에서 네트워크 보안과 효율성을 보장하는 것이 중요하다는 것을 이해하고 있습니다. PoW를 합의 알고리즘으로 계속 사용하는 것이 최종성 및 체인 전환과 관련된 문제로 인해 내 외부에서 많은 걱정을 만들어 왔다는 것을 알고 있습니다.&lt;/p>
&lt;p>PoW의 종국성(Finality) 부족은 네트워크에서 거래가 즉시 확인되지 않을 수 있으며, 포크 가능성이 항상 존재하므로 체인 재구성(Re-organization)이 발생할 수 있습니다. 이로 인해 이전에 확인된 거래가 확인되지 않게 되어 체인을 보는 다양한 서비스에 문제가 발생할 수 있습니다.&lt;/p>
&lt;p>특히 작은 체인에서 체인 전환은 PoW의 또 다른 중요한 문제입니다. 작은 체인에서는 손쉽게 더 어려운 문제를 풀어 체인을 원하는 대로 재구성 할 수 있었으며 이는 게임 플레이의 지연 및 사용자 경험에 부정적인 영향을 미칠 수 있습니다.&lt;/p>
&lt;p>Libplanet 팀에서는 이러한 우려를 심각하게 받아들이고 있으며, 더 나은 사용자 경험을 제공하기 위해 보다 효율적이고 안전한 합의 알고리즘, 특히 위임형 작업 증명(DPoS) 합의 알고리즘으로 전환하는 작업을 진행하고 있습니다.&lt;/p>
&lt;p>DPoS를 채택함으로써 우리는 더 나은 최종성 보장을 제공하고 체인 전환 관련 문제를 피할 수 있습니다. DPoS는 이해관계자들이 대리인을 선출하여 그들을 대신해 거래를 검증하는 합의 알고리즘입니다. 이 시스템은 PoW보다 효율적이며, 채굴자가 복잡한 수학적 문제를 해결해야 하거나 여러 노드가 동일한 거래를 검증해야 하는 필요성을 피합니다. 대신 이해관계자들은 대리인을 선출하여 그들이 거래를 검증할 책임을 지게 됩니다.&lt;/p>
&lt;p>하지만 바로 DPoS로 전환하는 것은 많은 수고가 듭니다. 단순히 합의 알고리즘만을 변경하는 것이 아니라, PoW에서는 신경쓰지 않아도 되었던 요금 징수 체계나 위임자 분배 알고리즘 등을 구현해야 하기 때문입니다.&lt;/p>
&lt;p>따라서 저희는, Practical Byzantine Fault Tolerance (PBFT)를 거쳐 DPoS로 전환하기로 결정하였습니다.&lt;/p>
&lt;h2 id="실용적인-비잔틴-장애-허용practical-byzantine-fault-tolerance-pbft">실용적인 비잔틴 장애 허용(Practical Byzantine Fault Tolerance, PBFT)&lt;/h2>
&lt;p>PBFT는 일부 노드가 실패하거나 악의적으로 동작하는 경우에도 네트워크가 합의에 도달할 수 있는 비잔틴 장애 허용 합의 알고리즘입니다. PoW와는 다르게, Validator를 선정하고 그들 사이에서 블록 생성과 투표 과정을 거쳐 체인이 진행됩니다.&lt;/p>
&lt;p>하지만, PBFT만을 가지고는 퍼블릭 블록체인을 달성할 수는 없습니다. 이 Validator 들을 관리할 수 있는 개인 혹은 단체가 존재해야 하고, 이는 곧 체인의 중앙화로 이어지기 때문입니다.&lt;/p>
&lt;p>따라서 이 Validator 를 규칙에 맞게 선출하고, 더 많은 기여를 한 개인 혹은 단체가 체인 합의에 더 많은 영향을 끼칠 수 있는 알고리즘이 바로 Delegated Proof of Stake(DPoS) 입니다.&lt;/p>
&lt;h2 id="위임형-작업-증명delegated-proof-of-stake-dpos">위임형 작업 증명(Delegated Proof of Stake, DPoS)&lt;/h2>
&lt;p>위임형 작업 증명(DPoS) 합의 알고리즘은 체인에 참여하는 사용자들이 대리인(Delegator)을 선출하여 그들을 대신해 거래를 검증하고, 대리인은 그 보상을 받아가는 방식으로, PBFT가 가진 중앙화 문제를 피할 수 있습니다.&lt;/p>
&lt;p>이를 달성하게 되면 Libplanet 블록체인의 합의 변경 과정은 민주적이며, 커뮤니티가 합의 알고리즘 선택 과정에 참여할 수 있도록 보장합니다. 이것은 네트워크가 계속 발전하도록 보장하기 위해 플랫폼을 지속적으로 개선함으로써 더욱 더 미래 지향적이게 만듭니다.&lt;/p>
&lt;h2 id="libplanet-블록체인-합의-변경-과정의-이점">Libplanet 블록체인 합의 변경 과정의 이점&lt;/h2>
&lt;p>Libplanet 블록체인 합의 변경 과정에는 여러 가지 이점이 있습니다.&lt;/p>
&lt;p>첫째, 네트워크 보안과 효율성을 보장합니다. 더 효율적이고 안전한 합의 알고리즘으로 전환함으로써 Libplanet 팀은 네트워크가 더 많은 거래를 처리하고 안전하게 유지될 수 있도록 보장합니다.&lt;/p>
&lt;p>둘째, 민주적입니다. 커뮤니티는 합의 알고리즘 선택 과정에 참여할 수 있으며, DPoS를 채택함으로써 네트워크는 사용하는 사람들에 의해 통치됩니다. 중앙 집중적인 권위가 아니라 사용자들이 통치하는 시스템입니다.&lt;/p>
&lt;p>마지막으로, 합의 변경 과정은 Libplanet 블록체인이 계속해서 관련성을 유지할 수 있도록 보장합니다. 플랫폼을 지속적으로 개선함으로써 Libplanet 팀은 계속 변화하는 블록체인 환경에서 경쟁력을 유지합니다.&lt;/p>
&lt;h2 id="결론">결론&lt;/h2>
&lt;p>Libplanet 팀은 모든 사용자들에게 더 나은 블록체인 게임 경험을 제공하기 위해 노력하고 있습니다. Delegated Proof of Stake (DPoS) 합의 알고리즘으로 전환함으로써 더 나은 최종성 보장을 제공하고 체인 전환 관련 문제를 피할 수 있습니다. DPoS는 이해관계자들이 검증 과정에 참여할 수 있도록 하여 PoW나 Practical Byzantine Fault Tolerance (PBFT)보다 더 민주적인 시스템입니다. 하지만 바로 DPoS로 합의 알고리즘을 변경하기에는 여러 고려할 점이 많으므로 PBFT로의 전환을 우선하기로 결정하였습니다.&lt;/p>
&lt;h2 id="다음-이야기">다음 이야기&lt;/h2>
&lt;p>PoW -&amp;gt; PBFT를 전환하면서 고려해야 했던 것들에 대해 이야기하도록 하겠습니다.&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>페타바이트 트래픽 원인 분석기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2023/03/cloudwatch/" title="페타바이트 트래픽 원인 분석기"/><id>https://snack.planetarium.dev/kor/2023/03/cloudwatch/</id><published>2023-03-15T00:00:00+00:00</published><updated>2023-03-15T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요, Nine Corparation, 게임 디비전에서 DX Engineer로 근무하고 있는 moreal입니다. 이 글에서는 작년 이맘때 회사에서 발견한 문제를 디버깅한 경험을 공유하려고 합니다.&lt;/p>
&lt;h2 id="대시보드에-보이는-이상한-단위">대시보드에 보이는 이상한 단위&lt;/h2>
&lt;p>회사에서는 운영하는 서비스의 상태를 확인하고 주의 사항을 공유하기 위한 주간 미팅을 진행합니다. 서비스는 EKS를 사용하고 있으며, 상태 확인을 위해 AWS CloudWatch Container Insights를 활용하고 있습니다. 그런데 어느 날 대시보드를 확인하다 이상한 수치들을 발견했습니다.&lt;/p>
&lt;p>&lt;img src="https://velog.velcdn.com/images/moreal/post/3165dcad-605a-4e2d-8ad0-fd083993608d/image.png">&lt;/p>
&lt;p>Y축의 단위를 보니 1.67 페타바이트가 표시되어 있었습니다.&lt;/p>
&lt;p>&lt;img src="https://velog.velcdn.com/images/moreal/post/47432dd2-f78e-4724-8608-7721c09ad165/image.png">&lt;/p>
&lt;p>최대 값은 400 페타바이트에 이르렀습니다. 🙀&lt;/p>
&lt;p>여러 가지 추측을 해봤지만, 원인을 찾기 위해 CloudWatch가 어떻게 메트릭을 수집하는지 알아보기로 했습니다.&lt;/p>
&lt;h2 id="cloudwatch가-메트릭을-수집하는-방법">CloudWatch가 메트릭을 수집하는 방법&lt;/h2>
&lt;p>CloudWatch 메트릭 수집 방법을 알아보기 위해, 오픈소스로 공개된 &lt;a href="https://github.com/aws/amazon-cloudwatch-agent">aws/amazon-cloudwatch-agent&lt;/a> 저장소를 참조했습니다.&lt;/p>
&lt;p>&lt;code>amazon-cloudwatch-agent&lt;/code>는 Kubernetes에서 사용하는 cAdvisor를 활용합니다. cAdvisor는 컨테이너에서 사용하는 리소스와 퍼포먼스 메트릭을 제공합니다. 이 값들을 활용하여 메트릭 값을 계산합니다.&lt;/p>
&lt;p>계산 로직은 아래와 같습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>netIfceMetric[NetRxBytes] = &lt;span style="color:#038">float64&lt;/span>(cur.RxBytes-pre.RxBytes) / &lt;span style="color:#038">float64&lt;/span>(deltaCTimeInNano) * &lt;span style="color:#038">float64&lt;/span>(time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>netIfceMetric[NetTxBytes] = &lt;span style="color:#038">float64&lt;/span>(cur.TxBytes-pre.TxBytes) / &lt;span style="color:#038">float64&lt;/span>(deltaCTimeInNano) * &lt;span style="color:#038">float64&lt;/span>(time.Second)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/google/cadvisor/blob/648b12f8db47171ebd0fc45c67d53574ddb017fe/info/v1/container.go#L418-L437">&lt;code>cur.RxBytes&lt;/code>&lt;/a>의 데이터 타입이 &lt;code>uint64&lt;/code>여서 언더플로우가 발생할 가능성이 있었습니다. 과도한 트래픽이 발생하는 경우를 확인하기 위해 로그를 출력하는 부분이 있었고, 실제 값도 확인할 수 있었습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">if&lt;/span> netIfceMetric[NetRxBytes] &amp;gt; oneTerabytes || netIfceMetric[NetTxBytes] &amp;gt; oneTerabytes {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log.&lt;span style="color:#06b;font-weight:bold">Printf&lt;/span>(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;I! Too Big value for network RX/TX bytes, final Rx:%v, final Tx:%v, curRx:%v, preRx:%v, curTx:%v, preTx:%v, deltaCTimeInNano:%v&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> netIfceMetric[NetRxBytes], netIfceMetric[NetTxBytes],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur.RxBytes, pre.RxBytes,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur.TxBytes, pre.TxBytes,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deltaCTimeInNano)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>2022-04-08T08:18:17Z I! Too Big value for network RX/TX bytes, final Rx:3.1837731352719405e+17, final Tx:3.183773135286772e+17, curRx:692608, preRx:317669466, curTx:11946450, preTx:242992298, deltaCTimeInNano:57939882302
&lt;/code>&lt;/pre>&lt;p>Go Playground에서 코드를 실행하면 아래와 같은 결과가 나옵니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">// https://play.golang.com/p/KppWhxtTtad
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#080;font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;time&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">func&lt;/span> &lt;span style="color:#06b;font-weight:bold">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> curRxBytes &lt;span style="color:#888;font-weight:bold">uint64&lt;/span> = &lt;span style="color:#00d;font-weight:bold">692608&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> preRxBytes &lt;span style="color:#888;font-weight:bold">uint64&lt;/span> = &lt;span style="color:#00d;font-weight:bold">317669466&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> deltaCTimeInNano &lt;span style="color:#888;font-weight:bold">int64&lt;/span> = &lt;span style="color:#00d;font-weight:bold">57939882302&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">var&lt;/span> rxBytes = &lt;span style="color:#038">float64&lt;/span>(curRxBytes-preRxBytes) / &lt;span style="color:#038">float64&lt;/span>(deltaCTimeInNano) * &lt;span style="color:#038">float64&lt;/span>(time.Second)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.&lt;span style="color:#06b;font-weight:bold">Printf&lt;/span>(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;%v&amp;#34;&lt;/span>, rxBytes)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#888">// output = 3.1837731352719405e+17
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>3.1837731352719405e+17&lt;/code> 와 같은 값을 얻을 수 있고, 이 값을 Python에서 확인하면 원래 CloudWatch Container Insight에서 본 페타바이트 값이 나옵니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#038">int&lt;/span>(&lt;span style="color:#00d;font-weight:bold">3.1837731352719405e+17&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00d;font-weight:bold">318377313527194048&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;gt;&amp;gt;&amp;gt; &lt;span style="color:#038">int&lt;/span>(&lt;span style="color:#00d;font-weight:bold">3.1837731352719405e+17&lt;/span>) // (&lt;span style="color:#00d;font-weight:bold">1024&lt;/span> ** &lt;span style="color:#00d;font-weight:bold">5&lt;/span>) &lt;span style="color:#888"># KB MB GB TB PB&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00d;font-weight:bold">282&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>cAdvisor는 &lt;code>/proc/&amp;lt;pid&amp;gt;/net/dev&lt;/code>에서 프로세스의 네트워크 관련 메트릭들을 가져오는데, 프로세스가 실행되면서 값이 누적되고, 재시작하면 다시 0부터 시작합니다. 그래서 Pod를 내리고 다시 올릴 때, 같은 컨테이너 이름의 경우 이전 값보다 현재 값이 더 작아지면서 언더플로우 버그가 발생한 것으로 이해할 수 있었습니다.&lt;/p>
&lt;p>이 문제와 관련하여 Helm이나 다른 예제에서 Pod 이름이 항상 다른 것과 관련이 있는지는 아직 확실하지 않습니다. 🤔&lt;/p>
&lt;h4 id="여담">여담&lt;/h4>
&lt;ul>
&lt;li>다행히 요금에 큰 문제가 발생하는 문제는 아니었습니다 💭&lt;/li>
&lt;li>아직도 발생하는 문제입니다. 🙀&lt;/li>
&lt;li>ChatGPT에게 한 번 정리해달라고 해봤는데 괜찮은 것 같습니다. 👀&lt;/li>
&lt;/ul></content><author><name>이도건</name><uri>https://github.com/moreal</uri><email>dogeon@planetariumhq.com</email></author></entry><entry><title>Serilog를 통해 애플리케이션 데이터를 수집하고 분석하자</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2023/03/serilog/" title="Serilog를 통해 애플리케이션 데이터를 수집하고 분석하자"/><id>https://snack.planetarium.dev/kor/2023/03/serilog/</id><published>2023-03-03T00:00:00+00:00</published><updated>2023-03-03T00:00:00+00:00</updated><content type="html">&lt;h1 id="들어가며">들어가며&lt;/h1>
&lt;p>분산 네트워크나 마이크로서비스 아키텍처 상에서는 각 어플리케이션 간의 로그를 수집하고, 어플리케이션 간의 로그를 짝 맞춰야 할 일이 종종 있습니다.
이 글에서는 Serilog 와 S3를 이용하여 로그를 수집하고, 이를 Athena나 다른 로그 서치 엔진에 응용할 수 있는 방법을 안내하고자 합니다.&lt;/p>
&lt;h1 id="구조화-된-로그structured-log">구조화 된 로그(Structured Log)&lt;/h1>
&lt;p>프로그래밍 경험이 좀 되신 분들이라면 &lt;a href="https://cloud.google.com/logging/docs/structured-logging?hl=ko">구조화 된 로그&lt;/a>에 대해 들어보셨을 것입니다.
구조화 된 로그는, 어떤 로그의 내용이 어떤 의미를 가지는지를 명확하게 표현하는 것을 말합니다.
예를 들어, 다음과 같은 로그가 있다고 가정해봅시다.&lt;/p>
&lt;pre tabindex="0">&lt;code>2023-03-03 12:00:00.0000000 [INFO] [User] [suho.lee] [Login] [Success]
&lt;/code>&lt;/pre>&lt;p>이 로그를 보면, 2021년 3월 3일 12시에 suho.lee라는 사용자가 로그인에 성공했다는 것을 알 수 있습니다.
하지만, 이 로그는 어떤 로그인인지, 어떤 서비스에서 로그인을 시도했는지, 로그인에 성공했는지 실패했는지 등의 정보를 알 수 없습니다.
이러한 로그는, 로그를 분석하거나, 로그를 수집하여 다른 시스템에 전달할 때, 어떤 로그인지, 어떤 서비스에서 로그인을 시도했는지 등의 정보를 알 수 없기 때문에, 의미가 없습니다.&lt;/p>
&lt;p>때문에 로그를 구조화 된 로그로 작성하는 것이 중요합니다.
구조화 된 로그의 예시는 다음과 같습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2023-03-03 12:00:00.0000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;level&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;INFO&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;service&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;User&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;user&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;suho.lee&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;action&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Login&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;result&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Success&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Serilog는 이런 형태의 구조화 된 로그를 쉽게 작성할 수 있도록 도와주는 라이브러리입니다.&lt;/p>
&lt;h1 id="serilog">Serilog&lt;/h1>
&lt;p>다른 언어와 마찬가지로, C#에서도 로그를 작성하는 라이브러리가 많이 있습니다.
Serilog는 이 중 하나입니다.
Serilog는 다음과 같은 특징을 가지고 있습니다.&lt;/p>
&lt;ul>
&lt;li>Sink를 통해 다양한 로그 저장소에 로그를 저장할 수 있습니다.&lt;/li>
&lt;li>한 가지 로그에 대해 여러 표현법을 지원합니다.&lt;/li>
&lt;li>로그를 작성하는 코드에 영향을 주지 않고, 로그를 수집하는 코드를 변경할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;h1 id="serilog를-이용한-로그-작성">Serilog를 이용한 로그 작성&lt;/h1>
&lt;p>Serilog를 이용하여 로그를 작성하는 방법은 다음과 같습니다.&lt;/p>
&lt;ol>
&lt;li>Serilog 패키지를 설치합니다.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>dotnet add package Serilog
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>Serilog를 초기화합니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888;font-weight:bold">var&lt;/span> logger = &lt;span style="color:#080;font-weight:bold">new&lt;/span> LoggerConfiguration()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .WriteTo.Console()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> .CreateLogger();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>로그를 작성합니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>logger.Information(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, Serilog!&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>로그를 수집합니다.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>2023-03-03 12:00:00.0000000 [INF] Hello, Serilog!
&lt;/code>&lt;/pre>&lt;p>이렇게 Serilog를 이용하여 로그를 작성할 수 있습니다.&lt;/p>
&lt;p>또한 이렇게 작성 된 로그를 구조화 된 로그로 작성할 수 있습니다.&lt;/p>
&lt;ol>
&lt;li>로그를 구조화 된 로그로 변경합니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>logger.Information(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, {name}!&amp;#34;&lt;/span>, &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Serilog&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>로그를 수집합니다.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>2023-03-03 12:00:00.0000000 [INF] Hello, Serilog!
&lt;/code>&lt;/pre>&lt;ol start="3">
&lt;li>로그를 구조화 된 표현법으로 변경하면 다음과 같습니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2023-03-03 12:00:00.0000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;level&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;INFO&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;messageTemplate&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, {name}!&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Serilog&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>또한 Deconstruct를 이용하여 데이터를 펼쳐 볼 수 있습니다.
다음과 같은 좌표를 나타내는 클래스가 있다고 가정해봅시다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">Coordinate&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#888;font-weight:bold">double&lt;/span> Latitude { &lt;span style="color:#080;font-weight:bold">get&lt;/span>; &lt;span style="color:#080;font-weight:bold">set&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#888;font-weight:bold">double&lt;/span> Longitude { &lt;span style="color:#080;font-weight:bold">get&lt;/span>; &lt;span style="color:#080;font-weight:bold">set&lt;/span>; }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 클래스를 다음과 같이 로그에 작성할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#888;font-weight:bold">var&lt;/span> coordinate = &lt;span style="color:#080;font-weight:bold">new&lt;/span> Coordinate { Latitude = &lt;span style="color:#00d;font-weight:bold">37.566535&lt;/span>, Longitude = &lt;span style="color:#00d;font-weight:bold">126.9779692&lt;/span> };
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>logger.Information(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, {@coordinate}!&amp;#34;&lt;/span>, coordinate);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 작성된 로그를 수집하면 다음과 같이 나옵니다.&lt;/p>
&lt;pre tabindex="0">&lt;code>2023-03-03 12:00:00.0000000 [INF] Hello, { Latitude: 37.566535, Longitude: 126.9779692 }!
&lt;/code>&lt;/pre>&lt;p>구조화 된 표현법으론 다음과 같이 나옵니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;timestamp&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2023-03-03 12:00:00.0000000&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;level&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;INFO&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;messageTemplate&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Hello, {@coordinate}!&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;properties&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;coordinate&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Latitude&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">37.566535&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Longitude&amp;#34;&lt;/span>: &lt;span style="color:#00d;font-weight:bold">126.9779692&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="serilog를-이용한-로그-수집serilogsinks">Serilog를 이용한 로그 수집(Serilog.Sinks)&lt;/h1>
&lt;p>Serilog는 다양한 로그 저장소에 로그를 저장할 수 있도록 다양한 &lt;a href="https://github.com/serilog/serilog/wiki/Provided-Sinks">Sink&lt;/a>를 제공합니다.
이 글에서는 &lt;a href="https://github.com/serilog-contrib/Serilog.Sinks.AmazonS3">Serilog.Sinks.AmazonS3&lt;/a>를 사용하여 S3에 로그를 저장해 보겠습니다.&lt;/p>
&lt;ol>
&lt;li>Serilog.Sinks.AmazonS3 패키지를 설치합니다.&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code>dotnet add package Serilog.Sinks.AmazonS3
&lt;/code>&lt;/pre>&lt;ol start="2">
&lt;li>Serilog를 appsettings.json을 이용해 초기화합니다.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Serilog&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;MinimumLevel&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Information&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;WriteTo&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Name&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;AmazonS3&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Args&amp;#34;&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;Path&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;log.json&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;BucketName&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;bucket-name&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;RollingInterval&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;Day&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;ServiceUrl&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;https://s3.ap-northeast-2.amazonaws.com&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>권한 등 잘 설정이 되었다면 지정한 버킷에 로그가 저장됩니다.&lt;/p>
&lt;h1 id="amazon-glue를-이용한-로그-크롤링">Amazon Glue를 이용한 로그 크롤링&lt;/h1>
&lt;p>Amazon S3에 저장된 로그를 Amazon Athena를 이용하여 분석할 수 있습니다.
하지만 Amazon Athena는 JSON 형식의 로그를 분석하기에는 한계가 있습니다.
그래서 Amazon Athena를 이용하여 로그를 분석하기 위해서는 로그를 Amazon Glue를 이용하여 크롤링해야 합니다.&lt;/p>
&lt;p>Glue를 이용하여 데이터 카탈로그에 크롤링을 하는 방법은 다음 글을 참고하시면 됩니다.
&lt;a href="https://docs.aws.amazon.com/ko_kr/athena/latest/ug/data-sources-glue.html">https://docs.aws.amazon.com/ko_kr/athena/latest/ug/data-sources-glue.html&lt;/a>&lt;/p>
&lt;h1 id="amazon-athena를-이용한-로그-분석">Amazon Athena를 이용한 로그 분석&lt;/h1>
&lt;p>Amazon Athena는 여러 빅데이터 분석 툴과 마찬가지로 SQL을 이용하여 데이터를 분석할 수 있습니다.
다음과 같이 Amazon Athena를 이용하여 로그를 분석할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">SELECT&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">level&lt;/span>,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>messageTemplate,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>properties.coordinate.Latitude,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>properties.coordinate.Longitude&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">FROM&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;database-name&amp;#34;&lt;/span>.&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;table-name&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">WHERE&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">BETWEEN&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 00:00:00&amp;#39;&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 23:59:59&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이를 이용하여 여러 분산 네트워크 상의 노드들의 로그를 분석할 수 있습니다.
예시로, 두 노드 간에 통신이 이루어지는 시간을 분석해 보겠습니다.
table1은 노드1의 로그를, table2는 노드2의 로그를 나타냅니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#080;font-weight:bold">SELECT&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_timestamp,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.&lt;span style="color:#080;font-weight:bold">level&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_level,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.messageTemplate&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_messageTemplate,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.properties.coordinate.Latitude&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_latitude,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.properties.coordinate.Longitude&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node1_longitude,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_timestamp,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.&lt;span style="color:#080;font-weight:bold">level&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_level,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.messageTemplate&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_messageTemplate,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.properties.coordinate.Latitude&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_latitude,&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table2.properties.coordinate.Longitude&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AS&lt;/span>&lt;span style="color:#bbb"> &lt;/span>node2_longitude&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">FROM&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;database-name&amp;#34;&lt;/span>.&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;table1&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">JOIN&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;database-name&amp;#34;&lt;/span>.&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;table2&amp;#34;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">ON&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.properties.coordinate.Latitude&lt;span style="color:#bbb"> &lt;/span>=&lt;span style="color:#bbb"> &lt;/span>table2.properties.coordinate.Latitude&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>table1.properties.coordinate.Longitude&lt;span style="color:#bbb"> &lt;/span>=&lt;span style="color:#bbb"> &lt;/span>table2.properties.coordinate.Longitude&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb">&lt;/span>&lt;span style="color:#080;font-weight:bold">WHERE&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>table1.&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">BETWEEN&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 00:00:00&amp;#39;&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 23:59:59&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>table2.&lt;span style="color:#080;font-weight:bold">timestamp&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">BETWEEN&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 00:00:00&amp;#39;&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#080;font-weight:bold">AND&lt;/span>&lt;span style="color:#bbb"> &lt;/span>&lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;2023-03-03 23:59:59&amp;#39;&lt;/span>&lt;span style="color:#bbb">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이런 식으로 로그를 분석하면 두 노드 사이의 통신 시간을 알 수 있습니다.&lt;/p>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>이 글에서는 Serilog를 이용하여 로그를 수집하고 Amazon Athena를 이용하여 로그를 분석하는 방법을 소개했습니다.
오늘 소개한 방법을 응용하면 다양한 분산 네트워크 상의 노드들의 로그를 분석할 수 있을 것으로 기대합니다.
또한 이 글에서는 성능이나 여러 가지 제약 사항들을 고려하지 않았습니다.
이 글에서 소개한 방법을 실제로 사용할 때는 성능과 여러 제약 사항들을 고려해야 합니다.&lt;/p>
&lt;hr>
&lt;p>(이 글은 &lt;a href="https://www.dotnetconf.kr/2023">.NET Conf 2023 x Seoul&lt;/a>에 올해 2월 &lt;a href="https://www.dotnetconf.kr/f2ea6fa1-f802-4dba-be87-539d32d3584b">발표한 내용&lt;/a>을 각색한 것입니다.)&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>신뢰하지 않을 자유</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/12/about-trustless/" title="신뢰하지 않을 자유"/><id>https://snack.planetarium.dev/kor/2022/12/about-trustless/</id><published>2022-12-30T00:00:00+00:00</published><updated>2022-12-30T00:00:00+00:00</updated><content type="html">&lt;h1 id="목적">목적&lt;/h1>
&lt;p>이 글에서는 무신뢰성(Trustless), 그리고 무신뢰성에 기반한 시스템(Trustleses System)에 대해서 소개하고, 무신뢰성이 탈중앙 애플리케이션/네트워크를 만들때 어떤 역할을 한다고 알려져있는지 보편적인 이해에 대해 기술합니다. 또한 이러한 이해를 바탕으로, &lt;a href="https://nine-chronicles.com">나인 크로니클&lt;/a>이나 &lt;a href="https://libplanet.io">Libplanet&lt;/a>과 같은, &lt;a href="https://planetariumhq.com">플라네타리움&lt;/a>이 만드는 탈중앙 소프트웨어들에서 어떤 관점으로 수용해야 할지 제 나름의 의견도 남깁니다.&lt;/p>
&lt;h1 id="사이퍼펑크cypherpunk">사이퍼펑크(Cypherpunk)&lt;/h1>
&lt;p>무신뢰성에 대한 다양한 견해를 언급할 때에, 가장 먼저 설명해야만 하는 개념이 바로 &lt;a href="https://en.wikipedia.org/wiki/Cypherpunk">사이퍼펑크(Cypherpunk)&lt;/a>입니다. 브루스 베스키의 단편 소설 제목이자 이후 유사한 SF 소설이나 영화 장르로도 알려진 &lt;a href="https://en.wikipedia.org/wiki/Cyberpunk">사이버펑크(Cyberpunk)&lt;/a>와, 암호(Cipher)에서 유래한 이 장난기 어린 단어는, 1992년 &lt;a href="https://en.wikipedia.org/wiki/Jude_Milhon">주드 밀론(Jude Milhon)&lt;/a>이 처음 쓰기 시작했다고 합니다. 이들의 주된 관심사는 프라이버시(Pricvacy)였는데, 이는 &lt;a href="https://en.wikipedia.org/wiki/Eric_Hughes_(cypherpunk)">에릭 휴즈(Eric Huhhes)&lt;/a>가 1993년 발표한 &lt;a href="https://www.activism.net/cypherpunk/manifesto.html">〈사이퍼펑크 선언〉(&amp;ldquo;A Cypherpunk&amp;rsquo;s Manifesto&amp;rdquo;)&lt;/a>에서 엿볼 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>Privacy is necessary for an open society in the electronic age. Privacy is not secrecy. A private matter is something one doesn&amp;rsquo;t want the whole world to know, but a secret matter is something one doesn&amp;rsquo;t want anybody to know. Privacy is the power to selectively reveal oneself to the world.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>프라이버시는 전자 시대의 열린 사회를 위해 필수적입니다. 프라이버시는 세상 모든 사람들이 그것에 대해 알게 되는 것을 원하지 않는 것이며, 비밀은 전세계 모든 사람이 몰랐으면 하길 바라는 것이기에 그 둘은 서로 다릅니다. 즉 프라이버시는 자신에 대해 선택적으로 세상에 드러낼 수 있는 힘(권한)입니다.&lt;/p>
&lt;/blockquote>
&lt;p>단순히 &amp;ldquo;내가 누구인지 밝히고 싶지 않다.&amp;rdquo; 라는 것을 넘어서 신원의 주권에 대한 이야기를 하고 있는 그들로서는, (설령 그것이 쓰기가 더 불편해지더라도) 자신의 주권을 자신의 허락을 받지 않고 공개하는 것에 매우 비판적일 수 밖에 없었습니다. 개인의 정보는 개인이 스스로 지켜야, 그리고 지킬 수 있게 해야 한다는 것이었죠.&lt;/p>
&lt;blockquote>
&lt;p>We cannot expect governments, corporations, or other large, faceless organizations to grant us privacy out of their beneficence.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>우리는 정부, 기업 혹은 큰 익명의 조직들이 우리의 프라이버시를 그들의 선의로 지켜줄 것이라곤 기대할 수 없다.&lt;/p>
&lt;/blockquote>
&lt;p>그들은 개인이 이러한 조직/단체, 기업 그리고 국가에 저항하는 수단으로서 암호 기술에 주목했습니다. &lt;a href="https://en.wikipedia.org/wiki/Electronic_signature">전자서명(Electronic Signature)&lt;/a>을 사용하여, 중앙화된 데이터베이스에 의존하지 않고도 신원 증명을 하길 원했으며, 자금 추적과 검열을 피하려고 독자적인 송금 시스템을 만들었습니다. 그리고 그러한 부산물 중 하나가 그 유명한 &lt;a href="https://bitcoin.org">비트코인(Bitcoin)&lt;/a>이었죠.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;p>아마도 짐작하셨겠지만, 제가 강조하고 싶은 것은 그들이 암호학 기술들을 활용해 비트코인을 만들었다는 것이 아닙니다. 그들은 자신의 프라이버시를 다른 누군가가 관리하는 것을 극도로 꺼렸고, 그를 피하기 위한 방법이 암호학 기술이었다는 것입니다.&lt;/p>
&lt;h1 id="web3">Web3&lt;/h1>
&lt;p>(이제는 많은 분들이 아실만한 주제지만) 이런 사이퍼펑크들이 &lt;a href="https://en.wikipedia.org/wiki/Web3">Web3&lt;/a>로 대표되는 탈중앙 네트워크/애플리케이션을 만들자는 주장에 항상 긍정적인 것만은 아닙니다. 이들은 현재의 Web3가 주장하거나 지향하는 것이, 이미 너무 타협을 한 나머지 (적어도 본인들이 주장하던 것보다는) 훨씬 더 중앙화 되었다고 비판하죠.&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>하지만 이런 비판을 받는 Web3조차도 표현이나 중점을 두는 방향을 변주되었을 지언정, 비슷한 문제의식에 착안한 부분이 있다는 점은 재밌는 지점입니다. 가령 이더리움 재단에서 밝힌&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> &lt;a href="https://ethereum.org/en/web3/#core-ideas">Web3의 핵심 아이디어&lt;/a>에는 다음과 같은 언급이 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>Web3 is trustless: it operates using incentives and economic mechanisms instead of relying on trusted third-parties.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Web3는 무신뢰형입니다: 어떤 신뢰하는 제 3자에 의존하는 대신, 인센티브와 경제적 메커니즘을 사용하여 운영합니다.&lt;/p>
&lt;/blockquote>
&lt;p>프라이버시에 대한 언급은 없지만, 여전히 누군가를 믿을 수 없다는 태도는 유지하고 있는 것처럼도 보입니다. 저는 이게 신뢰(Trust)가 특정한 주체에 대한 힘의 근간이 되는 현상을 여전히 견제하고 있기 때문이라고 생각합니다. &lt;a href="https://en.wikipedia.org/wiki/Gavin_Wood">개빈 우드(Gavin Wood)&lt;/a>가 Web3를 창안하게 된 계기 또한 이러한 문제의식에서 출발했다고 알려져 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>The premise of &amp;lsquo;Web 3.0&amp;rsquo; was coined by Ethereum co-founder Gavin Wood shortly after Ethereum launched in 2014. Gavin put into words a solution for a problem that many early crypto adopters felt: the Web required too much trust. That is, most of the Web that people know and use today relies on trusting a handful of private companies to act in the public&amp;rsquo;s best interests.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Web 3.0의 전제는, 2014년 이더리움이 출시된 직후 공동 설립자인 개빈 우드가 만들었습니다. 개빈은 많은 초기 암호화폐 사용자들이 느꼈던 문제에 대한 해결책을 말했습니다. 웹은 너무 많은 신뢰를 요구하고, 오늘날 사람들이 알고 사용하는 대부분의 웹은 소수의 민간 기업이 공익을 위해 행동할 것을 신뢰하는데 의존합니다.&lt;/p>
&lt;/blockquote>
&lt;p>사이퍼펑크들이 프라이버시를 위해 주장한것은, 단순히 비밀을 간직하고 싶었던 것이 아니라, 어떤 것을 공개할지를 스스로 정해야 한다는 일종의 자기 주권 이야기이었습니다. 그리고 그런 맥락에서 Web3의 오너십 역시 크게 다르지 않을 것입니다. 결국 내가 누구를 믿을지 말지조차, 내가 직접 정할 수 있어야 한다는 것이죠.&lt;/p>
&lt;h2 id="합리적-경제인homo-ecnomicus">합리적 경제인(Homo ecnomicus)&lt;/h2>
&lt;p>&amp;ldquo;인센티브와 경제 모델을 누군가의 선의 대신 사용해야 한다.&amp;ldquo;라는 주장은 고전 경제학에서 인용되는 &lt;a href="https://en.wikipedia.org/wiki/Homo_economicus">합리적 경제인(Homo economicus)&lt;/a>을 연상케도 합니다. 합리적인 경제인 모델은 현대에 들어선 &lt;a href="https://en.wikipedia.org/wiki/Behavioral_economics">행동 경제학(Behavioral economics)&lt;/a>에 의해 그 현실성이 많이 부정당하고 있는데&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>, 그렇다 보니 Web3의 무신뢰성이라는 것은 전제부터 불가능한 것 아닌가란 의심도 듭니다.&lt;/p>
&lt;p>하지만 저는 이 비판을 100% 적용하는 것은 어렵다고 봅니다. 행동 경제학의 합리적인 경제인 비판은, 그것이 잘 성립하지 않기에 그에 수반한 고전 경제학의 가정이나 합리성이 깨질 수 있다는 것인데, 무신뢰성이 필요한 이유는 애초에 합리적인 활동이나 그를 통한 효율을 올리는 것이 아니기 때문입니다. 데이터를 클라우드에 저장하면 더 싸고 더 편할 때도 있는데, 굳이 그걸 내 로컬 하드드라이브에 유지하는 것이 반드시 가격이나 시간 효율 때문만은 아니겠죠.&lt;/p>
&lt;h1 id="이념과-효율">이념과 효율&lt;/h1>
&lt;p>효율에 대해서 이야기하기 시작하면 나올 주요 반론(?)중 가장 까다로운 것은 아마 이런 류일 것입니다.&lt;/p>
&lt;p>&amp;ldquo;난 여러분께 제 주권을 돌려달라고 한 적이 없습니다. 제 데이터를 제가 직접 관리하고 싶지도 않구요. 전 그저 서비스를 싸고 쉽고 편하게 쓰고 싶은 것 뿐이에요.&amp;rdquo;&lt;/p>
&lt;p>사실 제 생각엔, 세상의 많은 서비스 사용자들이 이렇지 않나 싶기도 합니다. 아무도 못 믿어서 비 수탁형 지갑(Non-Custodial Wallet)에 꼬박꼬박 보관하다가, 실수로 하드를 포맷하거나 컴퓨터가 고장 나 쓰지 못하는 사람은 생각보다 많습니다. 그리고 대부분의 현대적인 서비스들은 점점 소유권과 그에 대한 책임 비용을 사용자에게서 공급자가 가져오는 형태로 진화했기에, &amp;ldquo;당신의 개인 키가 없어져도 우린 아무 것도 못해드립니다.&amp;rdquo; 라는 이야기가, &amp;ldquo;우린 너희의 개인 키를 정말로 모른다.&amp;ldquo;라는 진실성보다는, 그저 비겁한 책임 회피만으로 들리는 시대이기도 하죠.&lt;/p>
&lt;p>그렇다면 정말로 무신뢰성은 철저히 이념적인 것일 뿐이고, 서비스의 효율에 이바지하는 것이 없을까요?&lt;/p>
&lt;h2 id="metamask의-사례---조금-기술적인-이야기">MetaMask의 사례 - 조금 기술적인 이야기&lt;/h2>
&lt;p>&lt;a href="https://metamask.io">MetaMask&lt;/a>는 &lt;a href="https://ethereum.org">이더리움&lt;/a> 네트워크를 사용할 때 많이 사용되는 암호화폐 지갑입니다. 보다 구체적으로는, 사용자는 MetaMask를 통해 자산을 송금하거나, &lt;a href="https://en.wikipedia.org/wiki/Decentralized_application">탈중앙 애플리케이션(Decentralized Application, dApp)&lt;/a>을 실행할 수 있습니다.&lt;/p>
&lt;p>그런데 많은 사용자가 MetaMask를 사용하다 무심결에 사용하는 PC를 초기화해서 난처해지곤 합니다. 이 고지식한 소프트웨어가 계정 정보를 네트워크 어디에도 따로 저장하지 않기 때문인데요. 사실 MetaMask가 저장하는 계정 정보라는 것은 단순히 좀 긴 숫자&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>인데, MetaMask는 사용자가 입력한 패스워드로 암호화해서 로컬 저장소에 저장할 뿐입니다.&lt;/p>
&lt;p>이런 제약들로 인해, MetaMask는 예전 사이퍼펑크들의 강박증을 계승한 듯한 불편한 소프트웨어처럼 보입니다. 하지만 MetaMask, 더 정확히는 MetaMask와 이더리움의 서명 체계가 가지는 아주 독특한 특징이 있는데, 바로 호환성이 엄청나게 뛰어나다는 점입니다. 이더리움과 그 위에서 동작하는 탈중앙 애플리케이션들은, 기본적으로 아무도 믿지 않기에 외부의 계정 체계에 의존하는 것이 아니라 오로지 사용자가 제출한 서명과 데이터를 통해서만 동작합니다. 그로 인해 복잡한 &lt;a href="https://en.wikipedia.org/wiki/Single_sign-on">통합 인증(SSO)&lt;/a>이나 신원 제공자들과의 협업 없이도, 누구나 같은 서명 체계를 공유하는 네트워크에 호환되는 애플리케이션을 바로 만들 수 있습니다. &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> 이런 특징 덕에 MetaMask는 그야말로 폭발적인 성장을 이룩할 수 있었습니다.&lt;/p>
&lt;p>물론 MetaMask의 이런 성장이 온전히 무신뢰성에 기반한다고 보는 것은 지나친 비약일 수도 있습니다. 소위 DeFi Summer라고 불리는 가상 자산 시장의 호황에 맞춰서 사람들의 관심이 Web3에 몰린 것은 부정할 수 없는 사실이고, MetaMask의 성장에는 지대한 영향을 끼쳤을 것입니다. 하지만 만약 MetaMask를 &lt;a href="https://consensys.net">ConsenSys&lt;/a> &lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>가 Google이나 Facebook과 같이 중앙화된 웹서비스처럼, 완전 수탁형 서비스로 제공한다고 했다고 가정해보죠. (이념적인 부분을 차치하더라도) 이렇게 많은 서비스에서 쉽고 빠르게 수용할 수 있었을까요? Web 2.0시대로부터 OAuth가 제안되어 공급자들이 구현하는 것을 기다리는데에만 수년이 걸렸던 걸 돌이켜보면, 이는 어려운 일이라고 생각합니다. 바꾸어 말하자면 이런 확장성이야말로 &amp;ldquo;Web3스럽다&amp;quot;는 것만으로 치부할 수 없는, 무신뢰성의 가치입니다.&lt;/p>
&lt;h2 id="여전히-안전한-신뢰---조금-철학9적인-이야기">여전히 안전한 &amp;ldquo;신뢰&amp;rdquo; - 조금 철학&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>적인 이야기&lt;/h2>
&lt;p>MetaMask의 사례는 무신뢰형 시스템과 소프트웨어가 항상 비효율적인 것만은 아니라는 점을 시사하지만, 항상 더 효율적이라는 이야기는 역시 아닙니다. 그렇기에 모든 소프트웨어를 효율적으로 만들기 위해 무신뢰성을 확보해야 한다는 것 또한 이상한 이야기겠지요. 효율로 확실한 우위를 가지지 못하는 이상, 이런 반론은 여전히 유효합니다.&lt;/p>
&lt;p>&amp;ldquo;코드와 프로토콜을 믿는 것은 사람들을 믿는 것보다 더 위험하다. (혹은 허황되다)&amp;rdquo;&lt;/p>
&lt;p>&lt;a href="https://p2pfoundation.net">P2P 재단&lt;/a> 위키에 있는 &lt;a href="https://wiki.p2pfoundation.net/Trustless_Systems">무신뢰 시스템(Trustless Systems)&lt;/a> 문서에는 이런 톤의 보다 구체적인 주장들을 찾아볼 수 있는데요.&lt;/p>
&lt;blockquote>
&lt;p>First, you need to trust the protocol of the cryptocurrency and/or DAO. This isn’t as simple as saying ‘I trust the maths’, for some actual human (or humans) wrote the code and hopefully debugged it, and we are at least trusting them to get it right, no?&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>우선, 여러분은 암호화폐 혹은 DAO의 프로토콜을 믿어야 합니다. 그런데 이건 &amp;ldquo;수학을 믿습니다&amp;quot;같이 단순하진 않죠. 실제로는 일부의 사람들이 코드를 작성하고 희망적으로 디버그했으며, 우린 그들이 올바르게 작업했기를 믿는 것이기 때문이죠, 안 그래요?&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>Instead of trusting our laws and institutions, we are being asked to trust stakeholders and miners, and programmers, and those who know enough coding to be able to verify the code. We aren’t actually trusting the blockchain technology; we are trusting the people that support the blockchain.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>우리의 법률과 기관을 믿는 대신, 우리는 이해 당사자와 채굴자, 그리고 코드를 검증할 정도로 코딩을 할 줄 아는 사람을 신뢰하라는 요청을 받고있는 겁니다. 우린 실제로 블록체인 기술을 신뢰하는 게 아니에요; 우린 그저 블록체인을 지지하는 사람을 신뢰하고 있을 뿐입니다.&lt;/p>
&lt;/blockquote>
&lt;p>저는 무신뢰성에 대한 이런 비판에 대해서 생각할 부분도 있지만, 소프트웨어 엔지니어로서 전적으로 동감하긴 어렵다고 느낍니다.&lt;/p>
&lt;h3 id="입법-사법-그리고-행정">입법, 사법 그리고 행정&lt;/h3>
&lt;p>어떤 분들은 무신뢰성의 한계에 대해 지적하면서 다음과 같은 대안을 제시하시기도 합니다.&lt;/p>
&lt;blockquote>
&lt;p>Perhaps we ought to reconsider the desire to expunge trust, and instead focus on what should be done to strengthen it. One way to support trust is to hold institutions accountable when they betray it.&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>아마도 우리는 신뢰를 제거하려는 생각을 재고하고, 그것을 강화하기 위해 무엇을 해야 하는지 초점을 맞춰야 할 것입니다. 신뢰를 강화하기 위해 할 수 있는 한 가지 방법은, 기관이 신뢰를 배반했을 때 책임을 지도록 하는 것입니다.&lt;/p>
&lt;/blockquote>
&lt;p>저는 이것이 잘못되었거나 무의미한 일이라고 생각하진 않습니다. 하지만 무신뢰성, 그리고 그것에 기반한 블록체인 기술이 특별히 잘할 수 있는 일이 아니라고 생각됩니다. 왜냐하면, 이런 무신뢰성은 보통 행정에 필요한 권한(e.g., 개인 식별)을 개인에게 환원시키고 프로토콜에 의한 자동화를 강조하는데, 그걸 부정하면 딱히 더 잘할 수 있는 부분이 없기 때문입니다.&lt;/p>
&lt;p>어떤 분들은 행정만큼이나, 혹은 그 이상으로 &amp;ldquo;입법&amp;rdquo;, 그리고 &amp;ldquo;사법&amp;quot;이 중요하다고 말합니다. 그리고 저도 거기에 동의합니다. 다만 그건 블록체인 소프트웨어가 잘할 수 있는 일도 아니며, 본래의 가정을 무시하고 무리하게 취사선택(cherry-pick)할 때 오히려 비효율적인 부분이 늘어나기 때문에 어울리지 않는다고도 생각합니다. 대표적인 예로는 &lt;a href="https://en.wikipedia.org/wiki/Decentralized_autonomous_organization">탈중앙 자율 조직(Decentralized autonomous organization)&lt;/a>이 의사 결정 도구로 많이 사용되지만, 정작 투표 과정에서는 이더리움 네트워크를 사용하지 않는 &lt;a href="https://snapshot.org">snapshot&lt;/a>을 들 수 있겠네요. &lt;sup id="fnref:9">&lt;a href="#fn:9" class="footnote-ref" role="doc-noteref">9&lt;/a>&lt;/sup>&lt;/p>
&lt;h3 id="찍먹과-부먹">&amp;ldquo;찍먹&amp;quot;과 &amp;ldquo;부먹&amp;rdquo;&lt;/h3>
&lt;p>한국에서 탕수육, 특히 배달 탕수육을 먹는데 있어 빠질 수 없는 논쟁거리가 소위 &amp;ldquo;부먹&amp;rdquo;(소스를 부어서 먹기)과 &amp;ldquo;찍먹&amp;rdquo;(소스를 찍어서 먹기)입니다. 여기에는 얼핏 우스꽝스럽지만, 꽤 진지한 이론적 배경도 있죠. &lt;sup id="fnref:10">&lt;a href="#fn:10" class="footnote-ref" role="doc-noteref">10&lt;/a>&lt;/sup> &lt;sup id="fnref:11">&lt;a href="#fn:11" class="footnote-ref" role="doc-noteref">11&lt;/a>&lt;/sup>&lt;/p>
&lt;p>어찌 되었거나, 저는 개인적으론 &amp;ldquo;찍먹&amp;quot;을 선호합니다. 정확하게는 &amp;ldquo;찍먹&amp;quot;이나 &amp;ldquo;부먹&amp;quot;이나 맛에 있어선 별 차이를 못 느낍니다. 하지만 &amp;ldquo;부먹&amp;quot;이 가지는 치명적인 단점은 경계하는데 바로 &amp;ldquo;비가역성&amp;quot;입니다. 제가 탕수육을 시켜서 소스를 다 부어버린다면, 이걸 찍어 먹고 싶은 사람은 선택지가 없어집니다.&lt;/p>
&lt;p>무신뢰성을 이야기하다 갑자기 탕수육 이야기를 한 것은, 신뢰 관계라는 것도 비슷한 비가역성을 가지고 있다고 생각하기 때문입니다. 누군가를 믿는 걸로 전제된 시스템에선, 누군가를 임의로 믿지 않을 수 없습니다. 하지만 반대는 여전히 가능하죠. &lt;sup id="fnref:12">&lt;a href="#fn:12" class="footnote-ref" role="doc-noteref">12&lt;/a>&lt;/sup>&lt;/p>
&lt;h3 id="자동화된-행정">자동화된 행정&lt;/h3>
&lt;p>&amp;ldquo;입법&amp;quot;이나 &amp;ldquo;사법&amp;quot;을 다루기에 현재의 블록체인이 적합하지 않다한들, 혹은 신뢰/무신뢰를 나중에라도 선택을 할 수 있다한들 그것들이 무신뢰성에 기반한 &amp;ldquo;행정&amp;quot;을 용인해야 할 면죄부가 되진 않습니다. 기여를 하건 못하건, 위험한 건 여전히 위험한 겁니다. 또한 성립할지 어쩔지도 모르는 개념을 굳이 선택할 수 있게 할 이유도 없습니다. 그런데 다시 생각해보면 무신뢰성이, 사람들에게 누군가를 믿지 않을 권리를 주는 것이, 정말로 위험하거나 허황 된 일일까요?&lt;/p>
&lt;p>앞서 밝혔듯, 저는 모든 경우에 무신뢰형 시스템이 효율적이거나 윤리적이라고 믿진 않습니다. 현재의 정부, 기업, 또는 중앙화된 구조가 특별히 누군가를 착취하고 박해하려고 발전한 것이 아니라, 이러한 문제를 보다 잘 해결하고자 노력하기 위한 결과라고도 생각합니다. 중앙화된 것이 특별히 구식이거나 비효율적이거나, 청산해야 할 적폐라고 생각하지도 않습니다. 그저 중앙화 되어 있을 뿐이죠. &lt;sup id="fnref:13">&lt;a href="#fn:13" class="footnote-ref" role="doc-noteref">13&lt;/a>&lt;/sup>&lt;/p>
&lt;p>탈중앙화라는 관점에서, 무신뢰성에 기반한 &amp;ldquo;행정&amp;quot;은 무신뢰성 자체보단 행정의 자동화와 &amp;ldquo;사법&amp;quot;을 간소화(이하 &amp;ldquo;자동화된 행정&amp;rdquo;)에 더 큰 가치가 있습니다. 이는 사이퍼펑크들과 Web3가 무신뢰성을 통해 소구했던 것이 결국 &amp;ldquo;주권&amp;quot;이었다는 점을 상기해보면 꽤 자연스러운 흐름입니다.&lt;/p>
&lt;p>저는 작금의 블록체인 기술과 그를 통해 사람들이 기대하는 건, 실제 세상의 전제를 아예 뒤집는 수준의 혁신이라 생각합니다. 세상이 진짜 법대로 돌아간다면 경찰이 필요 없겠죠. 그리고 인류는 그런 세상을 지난 수 천년간 경험해 본 적이 없었고, 그런 공백을 메우기 위한 방법이 그 세월 동안 고안되어 왔습니다. 하지만 실체가 없는 소프트웨어를 돈을 주고 사고팔기 시작한 지는 100년이 안 되었고, (메타버스 운운이 호들갑이라 하더라도) 그런 실체 없는, 하지만 사람이 코드로서 제어할 수 있는 가상 세계가 생긴 지는 고작 수 십년에 지나지 않습니다. 이런 상황에서는 기술과 사회에 대한 가정을 그대로 유지하면서, 그것도 저 같은 소프트웨어 엔지니어가 이에 대해 가타부타 논하는 건 그야말로 갓난아이가 공자 앞에서 문자 쓰는 것과 다를 게 없습니다 &lt;sup id="fnref:14">&lt;a href="#fn:14" class="footnote-ref" role="doc-noteref">14&lt;/a>&lt;/sup> 바꾸어 이야기하면, 제가 &amp;ldquo;자동화된 행정&amp;quot;에 거는 기대는, 실체가 있는 현대 사회에서 인류가 몇 천년간 치고 받으면서 쌓아 올린 다양한 의사 결정 체계&lt;sup id="fnref:15">&lt;a href="#fn:15" class="footnote-ref" role="doc-noteref">15&lt;/a>&lt;/sup>들에 대한 제 나름의 존경과 경의이기도 합니다.&lt;/p>
&lt;h1 id="요약">요약&lt;/h1>
&lt;ul>
&lt;li>무신뢰성은 단순히 선의나 신뢰를 부정해야 한다는 이야기가 아니라, 그럴 수 있는 권리를 개개인에게 부여해야 한다는 주장입니다.&lt;/li>
&lt;li>사이퍼펑크, Web3 모두 대상의 차이(프라이버시 vs 서비스)는 있지만, 모두 권리에 관한 이야기를 하고 있기에 무신뢰성을 전제로 합니다.&lt;/li>
&lt;li>무신뢰성은 때때로(혹은 꽤 자주) 효율적이지 못할 수 있지만, 때로는 빠른 확장을 가능케 하기도 합니다.&lt;/li>
&lt;li>무신뢰성을 전제하는 &amp;ldquo;자동화된 행정&amp;quot;은, 무언가를 탈중앙화하는 데에 있어 가장 좋은 방법은 아닐 수 있습니다. 하지만 블록체인이란 기술을 가장 잘 활용할 수 있는 방법입니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>(이 글은 제 &lt;a href="https://gist.github.com/longfin">개인 Gist&lt;/a>에 올해 10월 &lt;a href="https://gist.github.com/longfin/019e0067275d134f4302539d2ddbff06">게시한 글&lt;/a>을 옮긴 것입니다.)&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>사실 비트코인이 이들의 유일한 부산물인 것은 아닙니다. &lt;a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy#Criminal_investigation">미국의 소프트웨어 수출 제재를 피하기 위해 소스 코드를 출력해서 배포한 전설적인 일화&lt;/a>로 유명한 암호 프로그램인 &lt;a href="https://en.wikipedia.org/wiki/Pretty_Good_Privacy">PGP(Pretty Good Privacy)&lt;/a>는 당대 사이퍼펑크로 유명했던 &lt;a href="https://en.wikipedia.org/wiki/Phil_Zimmermann">필 짐머만(Phil Zimmermann)&lt;/a>의 저작물이며, 넷스케이프(Netscape)의 공동 설립자였던 &lt;a href="https://en.wikipedia.org/wiki/Marc_Andreessen">마크 안데르센(Marc Andreessen)&lt;/a>을 포함한 많은 엔지니어가 &lt;a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#SSL_1.0,_2.0,_and_3.0">Secure Socket Layer(SSL)&lt;/a>과 관련된 소프트웨어들을 만들기도 했죠.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>개인적으로 자유 소프트웨어 진영과 오픈 소스 소프트웨어 진영의 대립을 보는 것 같기도 해서 흥미로운 부분입니다. 하지만 객관적인 비교가 가능할 만큼 충분한 정보가 없다고 생각하여 다루진 못했습니다.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&amp;ldquo;이더리움 재단의 정의가 전체 Web3를 대표할 만큼 대표성이 있는가.&amp;rdquo; 라는 지적이 있을 수 있으며 동의합니다. 이 글이 작성되는 2022년 10월경 제가 접할 수 있는 자료를 기준으로 판단하였으며 이것과 다르면서 더 보편적으로 알려져 있는 정의가 있으면 본 내용은 수정될 수 있습니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Status_quo_bias">현상 유지 편향(Status quo bias)&lt;/a>이나 &lt;a href="https://en.wikipedia.org/wiki/Prospect_theory">전망이론(Prospect theory)&lt;/a> 등이 흔히 일컬어지는 예시입니다.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>정확히는 &lt;a href="https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm">타원 곡선 전자 서명(Elliptic Curve Digital Signature Algorithm)&lt;/a>에 사용되는 숫자로, 자세한 사항은 Bitcoin 위키의 &lt;a href="https://en.bitcoin.it/wiki/Secp256k1">secp256k1&lt;/a> 문서를 참고하시면 됩니다.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>네트워크가 호환되지 않는 나인 크로니클이 이더리움과 같은 개인키를 사용할때 같은 주소가 나오는 것 또한 이런 까닭입니다.&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7">
&lt;p>MetaMask를 개발한 블록체인 기술 기업입니다. &lt;a href="https://infura.io">Infura&lt;/a>처럼 이더리움 생태계에 필요한 소프트웨어들을 만드는 것으로 유명합니다.&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8">
&lt;p>미리 밑밥(?)을 깔아두자면, 저는 학문으로의 철학을 공부하거나 엄밀하게 사고하도록 훈련한 적이 없는 소프트웨어 엔지니어입니다. 때문에 &amp;ldquo;철학&amp;quot;은 학문을 지칭하기보다 일반어로 이해하여 주시면 감사하겠습니다.&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:9">
&lt;p>주장을 개진하다 보니 단언적으로 이야기했지만, &amp;ldquo;무신뢰를 지향하는 시스템에서 이런 의정 활동이 유효한 부분이 전혀 없는가.&amp;rdquo; 저에게도 답이 있는 문제는 아닙니다. 그렇기에 나인 크로니클 DAO에 대해서도 &amp;ldquo;잘은 모르겠지만, 일단 실험해보자&amp;quot;라는 쪽의 생각에 가깝긴 합니다.&amp;#160;&lt;a href="#fnref:9" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:10">
&lt;p>소스를 부어서 먹는 걸 지지하는 분들은, 본래 탕수육이 원래 소스와 볶아서 먹는 요리였음을 주장하는 전통(?)적인 노선과 찍어 먹는 과정에서 생길 수 있는 여러 위생상의 문제를 걱정하는 실리(?)적인 노선이 있습니다.&amp;#160;&lt;a href="#fnref:10" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:11">
&lt;p>&amp;ldquo;찍먹&amp;quot;을 주장하시는 분들은 주로 식감이나 소스의 배합 자유도를 중요시한다고 알려져 있습니다.&amp;#160;&lt;a href="#fnref:11" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:12">
&lt;p>나인 크로니클의 온보딩포탈이나 플레이어 커뮤니티 등의 사례를 봤을 때, 이것이 실질적으로 가능한 선택인가라는 점은 다소 논쟁적이라고는 봅니다.&amp;#160;&lt;a href="#fnref:12" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:13">
&lt;p>그럼 탈중앙화에 &amp;ldquo;자동화된 행정&amp;quot;이 꼭 필요한 것인가라는 반론이 가능합니다. 그에 대한 생각도 정리해보았는데, 글의 분량 관계상 별도로 내어 적으려고 합니다.&amp;#160;&lt;a href="#fnref:13" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:14">
&lt;p>노파심에 계속 적는 거지만, 저는 이게 가치 없다는 주장을 하는 것이 아닙니다. 단지 제가 블록체인 기술로 잘할 수 없는 일이라는 것입니다.&amp;#160;&lt;a href="#fnref:14" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:15">
&lt;p>지금으로 충분하지 않다. 라는 착안에서 의견이 다른 분도 계시겠지만&amp;hellip; 더 이야기하면 지겨우시겠지만, 그래도 이야기하자면 저는 그 의견에 반대하지 않습니다.&amp;#160;&lt;a href="#fnref:15" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>오픈 소스, 블록체인 그리고 탈중앙 애플리케이션</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/12/oss-blockchain-and-decentralized/" title="오픈 소스, 블록체인 그리고 탈중앙 애플리케이션"/><id>https://snack.planetarium.dev/kor/2022/12/oss-blockchain-and-decentralized/</id><published>2022-12-07T00:00:00+00:00</published><updated>2022-12-07T00:00:00+00:00</updated><content type="html">&lt;p>이 글에선 &lt;a href="https://ko.wikipedia.org/wiki/%EC%98%A4%ED%94%88_%EC%86%8C%EC%8A%A4">오픈 소스&lt;/a> 운동과 &lt;a href="https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D%EC%B2%B4%EC%9D%B8">블록체인&lt;/a> 기술이 어떤 특성들을 담보하며, 탈중앙 애플리케이션을 만드는데 어떤 역할을 하는지에 대해 저의 이해를 바탕으로 설명합니다. 이 글의 목적은 &amp;ldquo;진정한 탈중앙 애플리케이션을 만들려면 반드시 오픈 소스를 해야 한다.&amp;ldquo;라기보다는&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, 오픈 소스나 블록체인 기술이 차지하고 있는 역할을 공유함으로써, 추후 이러한 이해 상충이 벌어지는 부분들을 보다 명확히 하기 위함입니다.&lt;/p>
&lt;h1 id="오픈-소스">오픈 소스&lt;/h1>
&lt;p>오픈 소스, 혹은 오픈 소스 운동은 다양한 정의를 가지고 있습니다. &lt;a href="https://ko.wikipedia.org/wiki/%EC%9E%90%EC%9C%A0_%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4">자유 소프트웨어&lt;/a> 운동을 지지하는 쪽에서는 오픈 소스가 자유 소프트웨어의 부분 집합이라고 주장하지만, 오픈 소스를 지지하는 사람들은 오픈 소스가 자유 소프트웨어를 포함하는 더 넓은 개념이라고 이야기하기도 합니다. 이 둘의 차이나 주장도 흥미로운 부분이 많지만, 이 글에서 제가 밝히고 싶은 제 이해의 관점에선 크게 차이가 나진 않으므로 생략하도록 하겠습니다.&lt;/p>
&lt;p>&lt;a href="https://opensource.org/osd">오픈 소스 이니셔티브의 정의&lt;/a>에 따르면, 오픈 소스는 단순히 코드를 공개하는 것 이상의 기준을 갖추고 있습니다. 가령 파생 제작물(Derived Works)에 대해서도 원본 소프트웨어와 같은 라이선스를 유지해야 한다든지, 개인이나 집단을 차별해서는 안 된다는, 일종의 사회 운동과 같은 성격을 지니고 있기도 합니다.&lt;/p>
&lt;p>그런데 이런 기준들을 만족하는 것보다 더 중요한 것은, 이런 기준들을 요구하게 된 배경과 철학입니다. 왜냐면 구체적인 기준은 시대와 기술이 변화함에 따라 바뀌기도 하기 때문이죠. &lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 그리고 저는 오픈 소스(그리고 자유 소프트웨어)의 기저에 깔린 배경과 철학이 다음과 같다고 생각합니다.&lt;/p>
&lt;blockquote>
&lt;p>소프트웨어 저작물을 사용하는 모든 사용자에게, 소프트웨어의 구성(i.e., 소스 코드)을 자유롭게 확인하고 수정본과 파생 저작물을 만들어서 배포할 권리를 보장해야 한다. &lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;/blockquote>
&lt;p>또한 오픈 소스 운동을 지지하는 많은 사람은, 이런 권리가 보장될 때, 해당 소프트웨어의 생태계가 더욱 풍성해지며 공공의 이익이 촉진된다고 믿습니다. 그렇기 때문에 많은 오픈 소스 프로젝트들이 공개 개발과 협업에 관심을 가지는 것이라 할 수 있죠. &lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/p>
&lt;h1 id="블록체인과-포크">블록체인과 포크&lt;/h1>
&lt;p>&lt;a href="https://bitcoin.org/">비트코인&lt;/a>의 세계적인 대히트 이후 블록체인이 (정도나 분야, 전망에 대한 이해는 다를지언정) 우리 사회를 강타했다는 것은 부정하기 어려운 사실입니다. 비트코인을 이야기할 때 빠지지 않는 것이 분산 원장이나 불변성 같은 개념이죠. 이를테면 모든 거래는 하나의 체인에 기록되어 모두의 노드에 저장되므로 누군가가 이를 절대로 위/변조할 수 없다는 그런 구체적인 장점을 들어 이야기하는 경우가 많습니다. 저는 이런 설명이 완전히 틀린 것은 아니지만, 블록체인이 어떤 애플리케이션이나 서비스의 탈중앙화를 하는데 차지하는 역할을 설명하기에는 다소 오해가 생길 수 있는 설명이라는 생각도 합니다. 왜냐면 &amp;ldquo;절대 불변의 분산 장부&amp;quot;라는 매력적인 속성은 블록체인의 기술적인 속성에만 기댄 것이 아니라, 허가형 네트워크에서 오픈 소스 프로젝트로서 취할 수 있는 여러 기법들을 섞어서 만든 비트코인이나 이더리움의 복합적인 성취이기 때문입니다.&lt;/p>
&lt;h2 id="허가비허가형-네트워크">허가/비허가형 네트워크&lt;/h2>
&lt;p>순수하게 기술적인 관점&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>에서 블록체인은 모두가 같은 상태에 대해 합의해야 하는 분산 환경에서, 다른 상태를 계산한 노드를 빠르게 찾기 위한 목적으로 사용됩니다. 그리고 그게 다입니다. 보통 이쯤에서 많은 분들은 이를 배제하는 수단으로써 작업 증명이나 지분 증명 등을 떠올리실 것이고, 또 어떤 분들은 &amp;ldquo;그 또한 블록체인의 일부로 봐야지, 블록체인을 너무 협의로 본 것이 아닌가?&amp;rdquo; 라는 생각이 드실 것입니다. 동의합니다. 하지만 제가 이 글에서 말씀드리고 싶은 것은 이런 구체적인 합의 방법 이전에, 우리가 중요한 결정을 해야 한다는 점입니다. 그것은 바로 네트워크를 허가형으로 운영할 것인지, 아니면 비허가형으로 운영할 것인지입니다.&lt;/p>
&lt;p>우리는 소프트웨어(노드)가 어떠한 주체로부터 허가를 얻어야만 네트워크에 접근할 수 있는지, 아니면 이러한 허가가 없이도 접근할 수 있는지에 따라 이를 허가형(Permissioned), 혹은 비허가형(Permissionless)이라고 지칭합니다. SNS나 멀티플레이어 게임 등이 실행되는 현대의 많은 상업적 네트워크는, 그 서비스/게임의 이용료가 얼마냐와는 무관하게 허가형인 경우가 많은데, 이는 꼭 비용을 요구하지 않더라도 그 네트워크를 이용하기 원하는 소프트웨어의 접근을 특정 주체가 통제할 수 있기 때문입니다. 반대로 이더리움 네트워크는, 트랜잭션을 처리하기 위해 수수료가 발생하는 구조지만, 이러한 수수료만 감당한다면 어떤 주체도 접근을 제한하거나 제어할 수 없기에 비허가형 네트워크로 분류됩니다. &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> 대부분의 탈중앙 네트워크를 지향하는 애플리케이션과 네트워크는 통상적으로 허가형보다는 비허가형으로 설계하여 자유로운 접근을 허용하는 접근을 취합니다.&lt;/p>
&lt;h2 id="프로토콜과-구현">프로토콜과 구현&lt;/h2>
&lt;p>우리가 탈중앙성과 블록체인을 다룰 때 자주 언급하는 것이 프로토콜(Protocol)입니다. 이름에서 알 수 있듯, 탈중앙/비허가 네트워크를 이야기할 때 이 프로토콜은 규칙/규약을 지칭하며, 특정 주체의 판단 대신에 노드가 네트워크를 사용하는 방식을 통제하는 수단입니다.&lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup> 그렇기에 어떤 네트워크가 비허가성, 그리고 그로 인한 탈중앙성을 갖는지 이야기할 때에는 이러한 프로토콜이 얼마나 자세하게 노드의 동작을 규정하는지, 그리고 얼마나 이러한 프로노콜을 잘 유지하는지를 함께 고려하는 경우가 많습니다. 그런데 이런 프로토콜에 대한 고려가 비허가형 네트워크를 만드는데 충분한 조건일까요?&lt;/p>
&lt;p>극단적인 사고 실험을 해보죠. 어떤 노드의 구현이 완벽하게 어떤 네트워크의 프로토콜을 준수하고 호환되며, 심지어 그 네트워크에선 P2P로 모든 노드가 특권 없이 투표를 통해 민주적&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>으로 정해진다고 가정해봅시다. 이 구현을 가지고만 있다면, 누구든지 네트워크에 참여할 수 있다면 이 네트워크는 비허가형일까요? 저는 여기에 대해서 &amp;ldquo;아니오&amp;quot;라고 생각합니다. 왜냐하면, 프로토콜은 규칙을 정해둔 것일뿐, 실제 네트워크에서 동작하는 노드는 소프트웨어이기에 반드시 구현을 필요로 합니다. 즉 사용자들은 어떤 네트워크를 이용할 때에 이러한 구현을 사용합니다. 그런데 이런 구현을 얻는 방법이 제한되어 있다면, 프로토콜의 고려와는 무관하게 탈중앙성도 함께 제한됩니다. 누군가 사용하는 노드의 구현을 바꿔치기하거나, 혹은 구현을 공급하는 주체가 더 이상 공급을 하지 않게 되는 경우 등을 상상해보시면 제 관점의 이해가 수월하시리라 생각됩니다.&lt;/p>
&lt;p>즉 네트워크가 온전히 비허가형이기 위해선 한 가지 속성을 더 만족해야 합니다. 바로 그 노드 구현에 대해서 누구든지 확인할 수 있어야 하며 배포가 독점적인 주체로부터 이뤄지면 안 된다는 것이죠. 이는 오픈 소스가 소프트웨어 저작물에 대해 사용자의 권리로서 보장하는 것과 일치합니다.&lt;/p>
&lt;h2 id="포크">포크&lt;/h2>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Fork_(blockchain)">포크(Fork)&lt;/a>는 전통적인 자유 소프트웨어/오픈 소스 개발에서, &lt;a href="https://en.wikipedia.org/wiki/Fork_(software_development)">어떠한 프로젝트를 자신의 입맛에 맞게 개작하여 분화하는 활동을 일컫는 동명의 단어&lt;/a>에서 유래했습니다. 대표적인 리눅스 배포판 중 하나인 우분투는 데비안 리눅스의 포크이며, MySQL을 포크한 MariaDB와 같이 많은 프로젝트가 이러한 포크를 통해 탄생했습니다. 그런데 예전엔 이런 포크에 대해서 부정적인 인식이 있습니다. 주로 프로젝트를 유지 보수하는 메인테이너들 간의 갈등이나 반목으로 인해 싸우고 나간 결과가 포크이기도 했고, 실질적으로 변경 내역을 패치로, 때로는 조정을 통해서 가져와야 하기 때문에 품이 더 드는 비효율적인 일이기 때문이었죠. 더군다나 사람들은 같은 일을 하는 소프트웨어를 2개 이상 쓸 일도 없으니, 사람들의 한정된 관심사란 자원을 나눠먹는 이적 행위이기도 합니다.&lt;/p>
&lt;p>그럼 이렇게 안 좋기만 한 포크를 막으려면 어떻게 해야 할까요? 코드를 숨기고 재배포를 금지하는 거겠지만 이래서야 기껏 오픈 소스로 프로젝트를 하는 의미가 없습니다. 다른 좋은 방법은&amp;hellip; 적어도 저는 아직 발견하지 못했는데, 이는 포크라는 행위가 오픈 소스를 통해 얻고 싶은 가치인 코드의 열람과 개작, 배포의 자유와 깊게 연관되어 있기 때문이라고 생각합니다.&lt;/p>
&lt;p>그렇기에 사람들은 조금 우직하지만 어떻게 보면 정공법을 택했습니다. 보다 좋은 제품을 만들어서 기여자와 사용자들에게 호소하는 것이죠. 캐노니컬이라는 기업을 등에 입은 우분투라는 포크가 있음에도 사람들이 데비안을 사용하는 것은, 우분투에는 없고 데비안에는 있는 데비안 만의 장점이 있기 때문입니다.&lt;sup id="fnref:9">&lt;a href="#fn:9" class="footnote-ref" role="doc-noteref">9&lt;/a>&lt;/sup> 그래서 어쩌면 이는 포크를 막고 독점 소프트웨어로 돌아가느냐 아니면 기여자들과 사용자들이 자신의 프로젝트를 지지할 수 있게끔 개선을 통해 우위를 유지하느냐의 선택이며, 제 이해로는 오픈 소스 신에 남은 많은 사람은 후자를 택했다고 봅니다.&lt;/p>
&lt;p>이는 비허가형 네트워크에도 비슷하게 적용된다고 생각합니다.&lt;sup id="fnref:10">&lt;a href="#fn:10" class="footnote-ref" role="doc-noteref">10&lt;/a>&lt;/sup> 오픈 소스 모델의 선례를 따르는 많은 공개 네트워크들은 포크가 생길 수 있는 위험에도 불구하고 네트워크의 구성을 공개하고 자유로이 포크 된 네트워크를 띄울 수 있도록 합니다. 이는 포크 된 네트워크에 이점이 있다기보다는, 단순히 포크를 제한하면서 동시에 독점성을 없앨 수 있는 방법이 논리적으로 없기 때문이라고 생각합니다.&lt;/p>
&lt;h1 id="탈중앙-애플리케이션">탈중앙 애플리케이션&lt;/h1>
&lt;p>포크에 대한 위의 전망은 전적으로 오픈 소스 모델에서 빌려 온 논리이므로, 현실의 고도화된 의사 결정 체계를 모사하여 해결할 수 있다는 의견이 있을 수 있습니다. 하지만 저는 거기에 대해서는 회의적인데, 왜냐하면 그런 현실의 세련된 의사 결정 체계의 끝에 있는 것이 현존하는 중앙화 된 의사 결정 체제라고 생각하며, 이미 그들은 그들대로 일을 잘하고 있다고 생각하기 때문입니다. &lt;sup id="fnref:11">&lt;a href="#fn:11" class="footnote-ref" role="doc-noteref">11&lt;/a>&lt;/sup>&lt;/p>
&lt;p>저는 탈중앙 애플리케이션의 강점은 단지 조금 다르게 일을 하는 &lt;a href="https://en.wikipedia.org/wiki/Big_Tech#FAANG">FAANG&lt;/a>가 아니라, 그런 주체 없이도 자율적으로 돌아갈 수 있는, 아주 많이 다르게 일을 하는 점에 있다고 생각합니다. 그리고 이런 목표를 달성하기 위해서 현대의 탈중앙 애플리케이션들은 굳이 포크의 위험을 감수하면서도 오픈 소스로 개발되고 있는 것이라고 생각하고요.&lt;/p>
&lt;h2 id="포크를-허용하지-않는-탈중앙-애플리케이션">포크를 허용하지 않는 탈중앙 애플리케이션&lt;/h2>
&lt;p>글을 적다 보니 위의 탈중앙 애플리케이션이 너무 제 시각의, 좁은 버전일 수 있겠다는 생각도 듭니다. 어느 정도 탈중앙화 된, 그렇지만 모두가 내키지 않는 포크는 허용하지 않는 그런 네트워크가 독점성을 띄고 중앙화 되었다고 하는 것이 예단일 수도 있습니다.&lt;/p>
&lt;p>하지만 적어도 현재로서 저는&lt;/p>
&lt;ul>
&lt;li>비허가형 네트워크를 포크를 허용하지 않으면서 구성할 방법에 대한 아이디어가 없으며&lt;/li>
&lt;li>오픈 소스 개발 모델을 벗어난 개발 모델에서 비허가형 네트워크를 구성할 방법에 대한 아이디어도 없으며&lt;/li>
&lt;li>허가형 네트워크에 의존하는 애플리케이션이 탈중앙화 되어 있다고 보기엔 어렵다고 생각합니다.&lt;/li>
&lt;/ul>
&lt;h1 id="요약">요약&lt;/h1>
&lt;ul>
&lt;li>오픈 소스는 소프트웨어 저작물에 대한 사용자의 사용 이상의 권리를 보장하기 위해 창안되었으며, 이는 소프트웨어 개발에 긍정적인 영향을 주고 있다고 평가됩니다.&lt;/li>
&lt;li>현대의 비허가형 네트워크들은, 오픈 소스 운동의 권리 보장을 차용하여 비허가성을 달성하는데, 이와 동시에 포크에 대한 위협에도 같이 노출됩니다.&lt;/li>
&lt;li>오픈 소스와 비허가형 네트워크들은 포크가 유익해서 이를 감내하는 것이 아니라, 비허가성과 이를 통해 담보되는 탈중앙성을 유지하기 위해서 이를 감내합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;p>(이 글은 제 &lt;a href="https://gist.github.com/longfin">개인 Gist&lt;/a>에 올해 10월 &lt;a href="https://gist.github.com/longfin/0951c39b566e58e4e0a80faf513bb4b1">게시한 글&lt;/a>을 옮긴 것입니다.)&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>물론 저는 이 주장을 지지합니다. 하지만 이 주장을 지지하기에 앞서, 그 까닭을 말씀드리는 것이 먼저라고 생각합니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>실제로 나인 크로니클이 채택하고 있는 라이선스인 &lt;a href="https://www.gnu.org/licenses/agpl-3.0.en.html">AGPL&lt;/a>은 &lt;a href="https://www.gnu.org/licenses/gpl-3.0.html">GPL&lt;/a>의 변형으로, GPL이 가정하던 배포가 바이너리를 직접 제공하는 것 외에도 서버를 통해 서비스를 제공하거나 하는 식으로 바뀐 시대상을 따라가기 위해 제안되었습니다.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&amp;ldquo;이를 촉진하기 위해서 얼마만큼의 제약을 가해야 하는가&amp;quot;가 오픈 소스와 자유 소프트웨어 진영의 가장 큰 논쟁 거리입니다만, 글의 주요한 주제가 아니므로 생략합니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>근래의 많은 오픈 소스 커뮤니티에서 (설사 당장의 기술적인 이득이 생기지 않거나, 혹은 오히려 손해가 발생하더라도) 정치적 올바름과 같은 주제에 대해서 신중하고 포용력 있는 결정을 내리기 위해 고민하는 것은, 이러한 철학이 깔려 있기 때문이라고 생각합니다. 다만 이 또한 글의 주요한 주제가 아니므로 생략합니다.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>보다 구체적으로는, 이더리움 등에서 제안하는 분산 상태 기계로서의 블록체인을 이야기합니다.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>물론 지미 송 같은 비트코인 지지자들은 &lt;a href="https://www.coindeskkorea.com/news/articleView.html?idxno=41885">이더리움이 허가형 네트워크라고 비판하기도 합니다.&lt;/a> 하지만 이는 이더리움이 취하고 있는 접근 방향 자체가 잘못되었다기 보단, 비탈릭을 위시한 이더리움 재단이 &lt;a href="https://www.gemini.com/cryptopedia/the-dao-hack-makerdao">&amp;ldquo;The DAO&amp;rdquo; 사태&lt;/a> 등에서 통제권을 발휘하고 있다는 점의 비판이므로 여기서는 길게 다루지 않겠습니다.&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7">
&lt;p>어떤 네트워크가 비허가형이라고 할 때에는 반드시 어떠한 통제도 없어야 한다는 것을 의미하진 않습니다.&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8">
&lt;p>구성원의 선호를 완벽하게 반영하는 투표가 가능한가에 대한 논의(e.g., &lt;a href="https://ko.wikipedia.org/wiki/%ED%88%AC%ED%91%9C%EC%9D%98_%EC%97%AD%EC%84%A4">콩도르세의 역설&lt;/a>)도 흥미로운 주제이지만, 이 사고 실험의 주된 주제는 아니기에 생략하고, 가능하다고 가정합니다.&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:9">
&lt;p>이 역시도 오픈 소스가 효율성에 대해 많이 비판 받는 지점입니다. 왜냐하면 이러한 장점은 꼭 객관적인 기능의 우열뿐 아니라 개인이 지지하는 가치 등도 포함되기 때문입니다.&amp;#160;&lt;a href="#fnref:9" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:10">
&lt;p>블록체인 포크를 기술적으로 보면 &lt;a href="https://ethereum.org/ko/upgrades/merge/">더 머지(The Merge)&lt;/a>와 같은 체인 호환성이 없는 소프트웨어 업데이트를 일컫는 용어이지만 기술적 논의를 다루는 것이 목표는 아니기에, 여기서는 적대적인 포크로 한정해서 다룹니다.&amp;#160;&lt;a href="#fnref:10" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:11">
&lt;p>어쩌면 이 시각은 독점 소프트웨어를 바라보는 오픈 소스 진영의 논리와 비슷하다는 느낌도 받습니다. 저는 제가 생각하는 탈중앙 애플리케이션이 세상의 모든 애플리케이션을 대체하는 것은 아마도 불가능할 것이라고 생각합니다.&amp;#160;&lt;a href="#fnref:11" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>블록체인? 채굴해서 코인 나오는 건 알겠는데...</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/11/the-simple-of-blockchain/" title="블록체인? 채굴해서 코인 나오는 건 알겠는데..."/><id>https://snack.planetarium.dev/kor/2022/11/the-simple-of-blockchain/</id><published>2022-11-15T00:00:00+00:00</published><updated>2022-11-15T00:00:00+00:00</updated><content type="html">&lt;h2 id="알림">알림&lt;/h2>
&lt;p>이번 스낵 글은 이전에 개인 &lt;a href="https://www.getrevue.co/profile/bin_bash_shell/issues/issue-1-838950">뉴스레터&lt;/a>에서 발행했던 내용을
필사하여 스낵에 올리는 포스트입니다.&lt;/p>
&lt;h2 id="들어가며">들어가며&lt;/h2>
&lt;p>이번 뉴스레터는 “채굴해서 코인 나오는 건 이제 알겠고, 이게 변조 불가능하다고 하는데 이런 특성이랑 코인이 가치를 가지는 거랑 무슨 상관이야?” 정도로 블록체인을 아시는 분들에 대해 설명하는 내용을 담고 있습니다. 기술적 이해도가 필요한 이야기가 약간은 섞여 있고, 설명의 단순화를 위해 생략하거나 감추는 내용들이 있습니다.&lt;/p>
&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>블록체인은 “공개 탈 중앙 분산 데이터베이스” 입니다. 채굴같은 일반적인 분산 데이터베이스에는 없는 특성 같은 경우 공개 탈 중앙형 분산 데이터베이스를 만들기 위한 장치입니다.&lt;/p>
&lt;h2 id="데이터베이스">데이터베이스&lt;/h2>
&lt;p>블록체인을 이야기하려면 데이터베이스라는 것을 이야기하지 않을 수가 없습니다. 데이터베이스라는 것은 무엇일까요? 본인이 RDB 등에 익숙하다면 이 단락을 넘기셔도 좋습니다. 이 밑으로는 고전적인 RDB 이야기를 조금 하려고 합니다.&lt;/p>
&lt;figure>
&lt;a href="https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">
&lt;img src="images/database.jpg" alt="하드디스크의 내부, 헤드와 디스크가 보인다."/>
&lt;figcaption>Reference from https://unsplash.com/photos/GNyjCePVRs8&lt;/figcaption>
&lt;/a>
&lt;/figure>
&lt;p>데이터베이스는 쉽게 말해서 일종의 엑셀입니다. 표가 있고. 표에 값을 저장합니다. 이를 쉽고 빠르게 저장하고 가져다 쓰기 위한 여러 장치, 그리고 그 장치를 동작시키기 위한 약간의 규칙 같은 것들이 존재하는 엑셀이죠.
하지만 엑셀과는 다른 특이한 점이 있는데, 바로 값의 변경 (추가, 수정, 삭제)이 트랜잭션(Transaction) 이라는 연산을 통해 이루어진다는 것입니다.
엑셀에 있는 파일을 여러 사람이 동시에 수정한다고 생각해 보겠습니다. 동시에 한 셀을 수정하려고 하면 어떻게 될까요? ‘나중에 엔터를 친 사람 걸 적용한다’ 라는 규칙같은 것들이 떠오른다면 똑똑하신 분일 거고, “나중” 이라는 걸 어떻게 처리할 거냐 같은 것들이 떠오른다면 개발 경력이 좀 되는 분일 것 같습니다.
이걸 트랜잭션 동시성 제어(Concurrency control)라고 합니다. 데이터베이스에 있어서 매우 중요한 부분이자 골치가 아픈 부분이라고 할 수 있습니다. 이 트랜잭션 단위의 변경이라는 특성을 통해 DB는 트랜잭션 순서와 트래픽을 잘 관리하는 것으로 동시성 제어를 할 수 있습니다.&lt;/p>
&lt;h3 id="데이터베이스와-블록체인">데이터베이스와 블록체인&lt;/h3>
&lt;p>앞에서 데이터베이스의 데이터를 변화시키는 방법으로써 트랜잭션을 소개한 이유는 블록체인도 트랜잭션을 통해 모든 분산 노드의 데이터를 변화시키기 때문입니다.
하지만 다른 점이 있다면 보통 일반적인 데이터베이스는 권한을 가진 초월적인 존재인 오라클이 있다면 이 데이터를 마음대로 수정할 수 있고, 블록체인은 민주적인 방법으로 데이터의 수정 시도를 검증합니다.
그럴 일은 0에 수렴하겠지만 -그리고 이렇게 단순하게 진행되진 않겠지만-, 은행 전산망 담당자가 자신의 잔고 뒷자리에 0을 하나 붙여서 데이터베이스에 쓰기만 하면 손쉽게 변조가 가능합니다.
블록체인은 합의에 참여하는 사람들이 모두 자신의 컴퓨터에 데이터베이스를 만들고, 공개 네트워크에 전파 된 트랜잭션을 이용하여 이 데이터베이스에 데이터를 추가하거나 삭제하는 방법을 택함으로써, 앞에서 소개한 내용의 위/변조를 미연에 막을 수 있습니다.&lt;/p>
&lt;h2 id="블록체인">블록체인&lt;/h2>
&lt;h3 id="변조-불가능">변조 불가능&lt;/h3>
&lt;blockquote>
&lt;p>공개 네트워크에 전파 된 트랜잭션을 이용하여 내 로컬 데이터베이스를 수정하는 것과 위/변조를 미연에 막을 수 있는 건 무슨 상관이죠?&lt;/p>
&lt;/blockquote>
&lt;p>은행 전산망 담당자의 이야기로 돌아갑시다. 전산망 담당자 A씨가 이 데이터를 수정할 수 있었던 것은 권한만 존재한다면 쓰는 건 어떤 식으로 수정하더라도 상관이 없기 때문입니다. 잔고 저장 테이블을 수정할 수 있는 코드를 A씨가 몰래 삽입하여 배포한 뒤 이 코드를 실행시키는 방법도 있을 수 있고, 직접 DB에 접근할 수 있었다면 이야기는 더욱 쉬워질 것입니다.
하지만 이 데이터를 수정할 수 있는 방법은 코드를 수정하여 해당 코드를 실행시키는 트랜잭션을 발생시키는 법 단 하나고, 이 코드를 여러 검증인이 검증하여 위/변조하려는 시도를 했을 때 해당 시도를 무시할 수 있다면 어떨까요?
블록체인의 특성이 그렇습니다. 검증에 참여하는 사용자들은 여러 트랜잭션이 위/변조되었는지 검증하고, 검증이 끝난 트랜잭션들을 잘 모아서 다른 검증인들에게 전파합니다. 다른 검증인들은 해당 트랜잭션들이 올바른지 검증한 후 실행시켜 자신의 로컬 데이터베이스를 변화시킵니다.&lt;/p>
&lt;h3 id="블록과-블록체인">블록과 블록체인&lt;/h3>
&lt;p>이 과정에서 코드를 수정하여 트랜잭션을 변조한 뒤 발생시킨다 하더라도, 이런 검증인들에 의하여 받아들여지지 않고 사라집니다. 이 트랜잭션의 묶음을 우리는 “블록” 이라고 부릅니다.
이렇게 트랜잭션이 계속 발생한다면 블록도 계속 만들어 질 것이고, 해당 블록들이 이전 블록의 정보를 담은 상태로 계속 이어진다면 마치 체인과 같은 형태가 될 것입니다. 이걸 우리는 “블록체인” 이라고 부릅니다.&lt;/p>
&lt;figure>
&lt;img src="images/Linkedlist.png" alt="링크드리스트 그림."/>
&lt;figcaption>LinkedList (https://www.geeksforgeeks.org/data-structures/linked-list/)&lt;/figcaption>
&lt;/figure>
&lt;h3 id="검증인">검증인&lt;/h3>
&lt;p>똑똑하신 여러분들은 위화감을 느낄 겁니다&lt;/p>
&lt;blockquote>
&lt;p>“그럼 누가 검증하고 검증인은 어떻게 믿어?”&lt;/p>
&lt;/blockquote>
&lt;p>검증인을 믿기도 어려울 뿐더러, 검증인이 왜 그걸 해야하는지도 의문이 들 겁니다. 누구도 자신의 검증하기 위한 자원을(시간, 전기, 실리콘 성능) 마구 제공하고 싶어하지 않을 거기 때문이죠. 네트워크를 유지하는 데 필요한 검증을 제공해 준 사람들에게 보상을 어떤 방법으로도 해 주어야 합니다. 이 때 등장하는 개념이 “코인” 입니다.&lt;/p>
&lt;h2 id="코인">코인&lt;/h2>
&lt;p>검증에 올바르게 참여 해 준 보상으로, 네트워크는 이 검증인에게 “코인” 을 줍니다. 이 코인에 가치를 만들어서 네트워크에 참여하게 만드는 것은 역설적이게도 이 네트워크에 참여한 사람들입니다.
이런 블록체인의 특성을 이용하여 게임을 만든다던가, 송금 애플리케이션을 만든다던가, 부동산 증서 거래 애플리케이션을 만드는 방식으로 네트워크에 참여하는 사람들이 있고, 이 사람들의 애플리케이션을 이용하기 위해 코인은 가치를 가지며, 이 코인이 가치를 가지기에 검증인은 검증을 하는 동인이 생기게 됩니다.
즉, 진정한 블록체인의 가치와 그에 따라오는 코인의 가치는 커뮤니티가 만들어 나가는 네트워크에 있다고 저는 생각합니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>최대한 풀어 쓰기 위해 복잡한 내용은 많이 덜어내고 최대한 간결하게 설명하려고 노력해 봤는 데 어떨지 모르겠군요. 잘 읽혔으면 좋겠습니다. 다음 호가 나올 진 모르겠지만 나온다면 조금 더 재미있는 내용으로 찾아뵈려 합니다. 감사합니다.&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>오픈 소스인 립플래닛 프로젝트에 기여 하기 전에 알아야 할 파일들</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/09/files-you-would-better-to-know-while-contributing-oss-projects/" title="오픈 소스인 립플래닛 프로젝트에 기여 하기 전에 알아야 할 파일들"/><id>https://snack.planetarium.dev/kor/2022/09/files-you-would-better-to-know-while-contributing-oss-projects/</id><published>2022-09-14T00:00:00+00:00</published><updated>2022-09-14T00:00:00+00:00</updated><content type="html">&lt;p>개발자 커리어와 오픈 소스는 떼려야 뗄 수 없는 관계입니다. 오픈소스를 통해 얻을 수 있는 것은 경력상의 혜택 뿐 아니라, 안전한 환경에서 새로운 기술을 배우며 효율적이고 효과적으로 의사소통하는 방법과 같은 소프트 스킬을 배울 수 있는 기술적 혜택, 그리고 이와 더불어 인맥적 혜택도 있습니다.&lt;/p>
&lt;p>플라네타리움의 핵심 기술인 립플래닛은 오픈 소스 입니다. 회사 업무를 병행하며 오픈 소스 기여를 하기란 쉽지 않은데, 립플래닛 개발 자체가 오픈 소스 기여가 되는 것이죠.&lt;/p>
&lt;p>그래서 플라네타리움 구성원들 중에서는 오픈 소스 커뮤니티와 개발에 관심이 많았던 분들이 많습니다.&lt;/p>
&lt;p>그럼 립플래닛을 통해 오픈 소스 프로젝트에 기여를 해볼까요? 물론 말처럼 쉽게 시작되진 않습니다. 그리고 시작 전에 알아야 할 몇가지 파일(README, CONTRIBUTING, LICENSE)들이 있습니다. 이 파일들을 통해서 립플래닛에 대해 소개하고 어떤게 립플래닛에 기여할 수 있는지 말씀드리고자 합니다.&lt;/p>
&lt;h2 id="1-readme-파일">1. README 파일&lt;/h2>
&lt;p>&lt;img src="images/1.png">&lt;/p>
&lt;p>립플래닛(Libplanet)은 탈중앙 방식으로 멀티플레이 온라인 게임을 만들기 위한 .NET 라이브러리입니다. 이는 전체 게임 플레이가 승인된 중앙 서버가 아닌 동일한 노드 사이의 P2P 네트워크에서 발생하는 것을 의미합니다. 내부적으로 블록체인의 많은 기능(예: 전자 서명, 비잔틴 장애 허용(BFT) 합의, 데이터 복제)을 통합합니다.&lt;/p>
&lt;blockquote>
&lt;p>💡 &lt;strong>립플래닛을 써야하는 3가지 이유&lt;/strong>
&lt;br>&lt;br>
&lt;em>&lt;strong>Embeddable&lt;/strong>&lt;/em>
게임 앱은 실행 중인 다른 프로세스와 통신할 필요가 없으므로 추가 &lt;a href="https://ko.wikipedia.org/wiki/%EB%A7%88%EC%83%AC%EB%A7%81_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">마샬링&lt;/a> 또는 프로세스 관리가 필요하지 않습니다. Libplanet은 MySQL이나 PostgreSQL보다 &lt;a href="https://ko.wikipedia.org/wiki/SQLite">SQLite&lt;/a>에 더 가깝습니다.
&lt;br>&lt;br>
&lt;em>&lt;strong>Isomorphic&lt;/strong>&lt;/em>
Libplanet은 .NET 라이브러리이므로 모든 게임 로직을 동일한 언어인 C#으로 작성하고 블록체인에서 실행할 수 있습니다. &lt;a href="https://en.wikipedia.org/wiki/Glue_code">글루 코드&lt;/a>나 &amp;ldquo;스마트 계약&amp;quot;이 필요하지 않습니다.
&lt;br>&lt;br>
&lt;em>&lt;strong>Token-independent&lt;/strong>&lt;/em>
거의 모든 블록체인 시스템과 달리 사용자가 또 다른 암호 화폐를 만들고 처리하도록 강요하지 않습니다. 당신의 게임은 무료로 플레이할 수 있으며 일반 게이머가 즐길 수 있습니다.&lt;/p>
&lt;/blockquote>
&lt;h3 id="누겟nuget">누겟(NuGet)&lt;/h3>
&lt;p>모든 안정적인 릴리스에 대해 Libplanet을 .nupkg로 압축하고 NuGet 및 GitHub 릴리스 페이지에 업로드합니다.&lt;/p>
&lt;h3 id="빌드build">빌드(Build)&lt;/h3>
&lt;p>소스 코드에서 Libplanet.dll 및 Libplanet.Stun.dll 어셈블리를 빌드할 수 있습니다.&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet/blob/main/README.md">libplanet/README.md at main · planetarium/libplanet&lt;/a>&lt;/p>
&lt;h2 id="2-contributing-파일">2. CONTRIBUTING 파일&lt;/h2>
&lt;h3 id="기여자-가이드">기여자 가이드&lt;/h3>
&lt;p>참고: 현재 이 문서는 코드 기여자를 위한 것입니다.&lt;/p>
&lt;h3 id="질문-및-온라인-채팅">질문 및 온라인 채팅&lt;/h3>
&lt;p>Libplanet에 대해 논의할 &lt;a href="https://planetarium.dev/discord">Discord 서버&lt;/a>가 있습니다. Libplanet 범주에는 다음과 같은 목적을 위한 몇 가지 채널이 있습니다. 여기 디스코드 내에서는 보통 한국어로 말하지만 자유롭게 영어로 말할 수 있습니다.&lt;/p>
&lt;p>#libplanet-users: Libplanet을 사용하는 게임 프로그래머와 채팅하는 채널
#libplanet-dev: Libplanet을 해킹하고 패치를 만들기 위해 메인테이너 및 기여자에게 질문하고, 채팅하는 채널&lt;/p>
&lt;h3 id="전제-조건">전제 조건&lt;/h3>
&lt;p>최신 C# 컴파일러 및 .NET 런타임을 제공하는 .NET SDK 6.0 이상이 필요합니다. .NET 다운로드 페이지에서 .NET SDK 설치 지침을 읽고 따릅니다.&lt;/p>
&lt;p>선호하는 설정이 없는 경우 Visual Studio Code를 사용하는 것을 추천합니다. .NET을 만든 Microsoft에서 만든 무료 에디터입니다.&lt;/p>
&lt;h3 id="빌드">빌드&lt;/h3>
&lt;p>다음 명령은 종속성(필수 라이브러리 패키지)을 설치하고 전체 Libplanet 솔루션을 빌드합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>dotnet build
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SonarAnalyzer를 사용하여 코드 품질을 확인하지만 빌드하는 데 시간이 더 오래 걸립니다. 분석기를 건너뛰려면 다음을 사용할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>dotnet build -p:SkipSonar=&lt;span style="color:#038">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="프로젝트">프로젝트&lt;/h3>
&lt;p>GitHub의 &lt;a href="https://github.com/planetarium/libplanet">planetarium/libplanet&lt;/a> 저장소는 여러 프로젝트로 구성됩니다.&lt;/p>
&lt;ul>
&lt;li>Libplanet: 대부분의 구현 코드를 포함하는 메인 프로젝트. Libplanet이라는 이름의 NuGet 패키지로 배포됩니다.&lt;/li>
&lt;li>&lt;a href="http://libplanet.net/">Libplanet.Net&lt;/a>: Libplanet 위에 구축된 P2P 네트워킹 계층. 이것은 별개의 NuGet 패키지인 Libplanet.Net으로 배포됩니다.&lt;/li>
&lt;li>Libplanet.Node: 고유한 P2P 네트워크를 구축하기 위한 사용자 친화적인 façade API입니다. 이것은 별개의 NuGet 패키지인 Libplanet.Node로 배포됩니다.&lt;/li>
&lt;/ul>
&lt;h3 id="테스트">테스트&lt;/h3>
&lt;p>해당 구현 코드에 가능한 한 완전한 테스트를 작성합니다. 코드 커버리지 100%에 가까워지는 것이 우리의 목표 중 하나입니다.&lt;/p>
&lt;p>&lt;em>Libplanet&lt;/em> 솔루션은 여러 프로젝트로 구성됩니다. &lt;em>.Tests&lt;/em> 접미사가 없는 모든 프로젝트는 실제 구현입니다. 이들은 &lt;em>Libplanet*.dll&lt;/em> 어셈블리에 빌드되고 하나의 NuGet 패키지에 포장됩니다.&lt;/p>
&lt;h3 id="스타일-규칙">스타일 규칙&lt;/h3>
&lt;p>기존 코딩 규칙을 따라주세요. 우리는 이미 여러 정적 분석기를 사용하고 있습니다. &lt;code>msbuild&lt;/code> 와 함께 자동으로 실행되며 스타일 오류가 있으면 경고합니다.&lt;/p>
&lt;p>우리가 일반적으로 사용하는 Git 후크도 등록해야 합니다.&lt;/p>
&lt;p>선호하는 편집기에 EditorConfig 확장을 설치하는 것이 좋습니다.&lt;/p>
&lt;h3 id="벤치마크">벤치마크&lt;/h3>
&lt;p>성능 향상 또는 회귀를 추적하기 위해 일련의 벤치마크를 유지 관리하고 CI에서 지속적으로 측정합니다. 로컬 환경에서도 벤치마크를 실행할 수 있습니다.&lt;/p>
&lt;p>모든 벤치마크 코드는 &lt;a href="https://github.com/planetarium/libplanet/tree/main/Libplanet.Benchmarks">Libplanet.Benchmarks&lt;/a> 프로젝트에 있습니다. 벤치마크는 &lt;a href="https://benchmarkdotnet.org/">BenchmarkDotNet&lt;/a>을 기반으로 하므로 자세한 내용은 공식 문서를 참조하세요.&lt;/p>
&lt;h3 id="새-버전-출시">새 버전 출시&lt;/h3>
&lt;p>이 주제에 관한 릴리스 가이드를 읽어주세요.&lt;/p>
&lt;h2 id="3-license-파일">3. LICENSE 파일&lt;/h2>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet">planetarium/libplanet&lt;/a>은 &lt;strong>GNU Lesser General Public License v2.1&lt;/strong>에 따라 사용이 허가되었습니다.&lt;/p>
&lt;p>&lt;img src="images/2.png">&lt;/p>
&lt;blockquote>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>라이선스의 특징 및 의무사항&lt;/th>
&lt;th style="text-align:center">GPL 2.0&lt;/th>
&lt;th style="text-align:center">GPL 3.0&lt;/th>
&lt;th style="text-align:center">&lt;strong>LGPL&lt;/strong>&lt;/th>
&lt;th style="text-align:center">AGPL 3.0&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>복제·배포·수정의 권한 부여&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>배포시 라이선스 사본 첨부&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>저작권고지사항 또는 attribution 고지사항 유지&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>배포시 소스코드 제공 의무(reciprocity)와 범위&lt;/td>
&lt;td style="text-align:center">derived work&lt;/td>
&lt;td style="text-align:center">work based on the program&lt;/td>
&lt;td style="text-align:center">&lt;strong>derived work&lt;/strong>&lt;/td>
&lt;td style="text-align:center">derived work&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>조합저작물(larger work) 작성 및 타 라이선스 배포 허용&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>수정시 수정내용 고지&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>명시적 특허라이선스의 부여&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">&lt;strong>​&lt;/strong>&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>라이선시가 특허소송 제기시 라이선스 종료&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">&lt;strong>​&lt;/strong>&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>이름, 상표, 상호에 대한 사용제한&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;td style="text-align:center">&lt;strong>​&lt;/strong>&lt;/td>
&lt;td style="text-align:center">&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>보증의 부인&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>책임의 제한&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;td style="text-align:center">&lt;strong>◯&lt;/strong>&lt;/td>
&lt;td style="text-align:center">◯&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;cite>© 오픈소스 소프트웨어 라이선스 가이드 3.0&lt;/cite>&lt;/p>
&lt;/blockquote>
&lt;h3 id="마무리">마무리&lt;/h3>
&lt;p>위의 3가지 파일 외에도 릴리즈 가이드가 있는 ****&lt;a href="https://github.com/planetarium/libplanet/blob/main/RELEASE.md">RELEASE.md&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet/blob/main/CHANGES.md">CHANGES.md&lt;/a>**들이 있습니다.&lt;/p>
&lt;p>README 파일, CONTRIBUTING 파일, LICENSE 파일을 통해서 오픈 소스 프로젝트인 립플래닛을 소개했습니다. 꼭 립플래닛이 아니어도 좋습니다. 여러분들의 미래를 위해 오픈 소스 프로젝트에 기여하는 것을 추천드립니다. 물론 립플래닛 저장소와 디스코드 서버에서 만나면 더욱 좋고요.&lt;/p>
&lt;p>책 ‘오픈 소스로 미래를 연마하라&amp;rsquo;에 써있는 래블업 CEO 신정규님의 추천사로 글을 마무리할까 합니다.&lt;/p>
&lt;blockquote>
&lt;p>오픈 소스 문화는 사람의 문화입니다. 그래서 코드만큼 빨리 변하지 않습니다. 오픈 소스 소프트웨어의 코드를 만드는 주체는 서로를 잘 모르는 사람들입니다. 서로 모르는 사람들이 프로그램의 기능이라는 목표를 이루기 위해 지켜야할 규칙이 존재하고, 한 명의 머리로 따라가기 힘든 방대한 양의 코드를 관리하기 위한 다양한 기술적, 문화적 장치가 있습니다. 그러한 ‘문화&amp;rsquo;와 ‘방법론&amp;rsquo;에 대해 이해라는 것이 오픈 소스 생태계에 뛰어들기 위해 필요한 일입니다. 하지만 그만큼 복잡하기에 배우기 쉽지 않기도 합니다.&lt;/p>
&lt;/blockquote></content><author><name>황혜경</name><uri>https://github.com/hyekyunghwang</uri><email>hyekyung@planetariumhq.com</email></author></entry><entry><title>세상을 늦게 보기 위해 잃었던 것들</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/03/things-i-lost-to-see-the-world-late/" title="세상을 늦게 보기 위해 잃었던 것들"/><id>https://snack.planetarium.dev/kor/2022/03/things-i-lost-to-see-the-world-late/</id><published>2022-03-29T00:00:00+00:00</published><updated>2022-03-29T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 플라네타리움 엔진팀에서 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>을 개발하고 있는 이수호입니다.
오늘은 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>을 개발하면서 생겼던 문제 중 블록체인에서 흔히 말하는 확정(&lt;code>Confirmation&lt;/code>)으로 인해 생긴 문제와
그 문제를 발견하고 해결하는 과정을 이야기하고자 합니다.&lt;/p>
&lt;h2 id="확정confirmation">확정(&lt;code>Confirmation&lt;/code>)&lt;/h2>
&lt;p>블록체인에서의 블록은, 어떠한 사건이라고 볼 수 있고 체인은 사건으로 이루어진 일련의 시간 흐름이라고 볼 수 있습니다.
이전의 시간 흐름과는 맞지 않는 사건이 발생했을 때, 관측자는 이 사건을 올바르지 않은 사건으로 분류하고 거절합니다.
이 &amp;lsquo;올바른 사건&amp;rsquo;이라는 규칙을 대다수가 공유하고 있다면, 사건들만 순서대로 공유했을 때에 모두가 같은 현상을 관측하고 있다고 할 수 있습니다.&lt;/p>
&lt;p>하지만, 이 서로 다른 &amp;lsquo;올바른 사건&amp;rsquo;이 동시다발적으로 제출된다면 어떻게 될까요?
일시적으로 관측자들 사이에 혼란이 생길 것이지만 결과적으로는 올바른 시간대를 바라보게 됩니다.
하지만 이 혼란으로 인해 관측하고 있는 정보를 기반으로 하고 있는 다른 사용자들은 혼란을 겪게 됩니다.&lt;/p>
&lt;p>예를 들면. 방금 전 사건까지만 해도 분명히 100원이 있었는데, 이 사건이 없던 걸로 되어서 0원이 되어 버린다던가 하는 일들이 생길 수 있습니다.&lt;/p>
&lt;p>이를 막기 위해 사용자는 확정(&lt;code>Confirmation&lt;/code>) 이라는 &amp;lsquo;여기서부터는 뒤집히지 않는다&amp;rsquo; 라는 수치를 두고,
이 수치 이전까지는 블록이 들어와도 체인에 받지 않습니다.
세상을 늦게 보고 확실해질 때 까지 기다리는 것이죠.&lt;/p>
&lt;h2 id="libplanet-에서의-확정confirmation과-렌더러renderer">Libplanet 에서의 확정(&lt;code>Confirmation&lt;/code>)과 렌더러(&lt;code>Renderer&lt;/code>)&lt;/h2>
&lt;p>Libplanet 은 이 확정(&lt;code>Confirmation&lt;/code>)을 지원하고 있습니다. 정확히는 렌더링 과정에서 확정(&lt;code>Confirmation&lt;/code>)을 거칩니다.
이 렌더링 역할을 해 주는 렌더러(&lt;a href="https://docs.libplanet.io/0.30.0/api/Libplanet.Blockchain.Renderers.IRenderer-1.html">Renderer&lt;/a>)는 블록체인의 상태를 수신해서 변경이 일어났을 경우
해당 렌더러의 콜백을 블록체인의 이전 상태,현재 상태와 함께 호출해 주는 역할을 가지고 있습니다.&lt;/p>
&lt;p>이 중에서도 지연 렌더러(&lt;a href="https://docs.libplanet.io/0.30.0/api/Libplanet.Blockchain.Renderers.DelayedRenderer-1.html">DelayedRenderer&lt;/a>)는 블록 자체를 늦게 인지하는 것이 아닌 블록을 전부 인지 및 연산한 후에
렌더링 하는 부분만 가지고 있다가 수치가 넘어가면 감싸고 있는 렌더러(&lt;a href="https://docs.libplanet.io/0.30.0/api/Libplanet.Blockchain.Renderers.IRenderer-1.html">Renderer&lt;/a>)에 보내줍니다.&lt;/p>
&lt;p>더 자세한 정보는 &lt;a href="https://docs.libplanet.io/0.30.0/api/Libplanet.Blockchain.Renderers.DelayedRenderer-1.html">DelayedRenderer&lt;/a>에서 확인할 수 있습니다.&lt;/p>
&lt;h2 id="문제-발생">문제 발생&lt;/h2>
&lt;p>어느 순간, 사용자들에게서 메모리 사용량이 급증한다는 제보를 받았습니다. 켜놓은 지 약 1시간이 지나면 메모리 누수가 심각하게 일어나는 것을 확인할 수 있었습니다.
특정하는 것은 어렵지 않았습니다. &lt;a href="https://www.jetbrains.com/ko-kr/dotmemory/">dotMemory&lt;/a>를 사용하니 어떤 클래스에서 메모리를 가장 많이 사용하는지 특정할 수 있었습니다.&lt;/p>
&lt;figure>&lt;img src="images/dot-memory.png"
alt="DelayedActionRenderer 가 가장 많은 메모리 사용량을 차지하고 있는 dotMemory 분석 결과"/>&lt;figcaption>
&lt;p>DelayedActionRenderer 가 가장 많은 메모리 사용량을 차지하고 있는 dotMemory 분석 결과&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>문제는 다음입니다. 왜 메모리 누수가 일어났을까? 눈치가 빠르거나 경험이 많으신 분들은 이미 눈치채셨을지도 모르겠습니다.&lt;/p>
&lt;h2 id="원인-및-해결">원인 및 해결&lt;/h2>
&lt;p>앞에서 언급했던 문구를 다시 가져와 보겠습니다&lt;/p>
&lt;blockquote>
&lt;p>이를 막기 위해 사용자는 확정(&lt;code>Confirmation&lt;/code>) 이라는 &amp;lsquo;여기서부터는 뒤집히지 않는다&amp;rsquo; 라는 수치를 두고,
이 수치 이전까지는 블록이 들어와도 체인에 받지 않습니다.
세상을 늦게 보고 확실해질 때 까지 기다리는 것이죠.&lt;/p>
&lt;/blockquote>
&lt;p>힌트는 &lt;em>여기서부터는 뒤집히지 않는다&lt;/em> 입니다.
작업 기반 증명(Proof-Of-Work, PoW)에서는 합의 무결성(Safety)를 보장할 수 없기 때문에, 이것은 그 누구도 보장할 수 없습니다.&lt;/p>
&lt;p>따라서 사용자가 지정한 이 확정(&lt;code>Confirmation&lt;/code>) 을 체인 안쪽까지 끌어와서
블록체인 네트워크 엔지니어가 경계 값(Threshold)을 지정할 수 있게 하는 작업이 필요했습니다.
해당 작업의 결과는 &lt;a href="https://github.com/planetarium/libplanet/pull/1163">#1163&lt;/a> PR에서 보실 수 있습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>일련의 모든 블록체인 합의 과정에서의 설명은 모두 작업 기반 증명(Proof-Of-Work, PoW)을 기반으로 설명되었습니다.
지분 기반 증명(Proof-Of-Stake, PoS)나 다른 합의 알고리즘에서는 필요 없는 이야기일 수도 있습니다.&lt;/p>
&lt;p>설명이 조금 모자라거나 틀린 부분이 있으면 의견 남겨주시면 감사하겠습니다.&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>탈중앙 게임과 AWS re:Invent</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/01/2021-aws-reinvent/" title="탈중앙 게임과 AWS re:Invent"/><id>https://snack.planetarium.dev/kor/2022/01/2021-aws-reinvent/</id><published>2022-01-25T00:00:00+00:00</published><updated>2022-01-25T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>을 만들고 있는 &lt;a href="https://planetariumhq.com/">플라네타리움&lt;/a>의 문성원입니다.
오늘은 작년 11월 29일부터 12월 3일까지 열린, &lt;a href="https://reinvent.awsevents.com/">AWS re:Invent&lt;/a>에 참석하게 된 계기에 대해서 짤막하게나마 공유토록 하겠습니다.&lt;/p>
&lt;h1 id="aws-reinvent">AWS re:Invent&lt;/h1>
&lt;p>&lt;img src="images/reinvent2021.png">&lt;/p>
&lt;p>AWS re:Invent는 2012년부터 (코로나 19로 연기된 2019년을 제외하고) 매해 열린 개발자
행사입니다. 클라우드가 단순히 서비스 운영을 넘어, 소프트웨어 개발에 걸쳐서 막대한
영향력을 끼치는 현대에 들어서는 가장 큰 개발자 행사라고 해도 과언이 아니죠.&lt;/p>
&lt;p>AWS는 re:Invent를 통해서 자사의 비전이나 새로운 제품/기능을 소개하는 것을 넘어서
자사 제품을 사용하여 구축한 모범 사례나 개발 방법론을 공유하기도 합니다.&lt;/p>
&lt;h1 id="탈중앙-애플리케이션을-만드는-사람들이-왜">탈중앙 애플리케이션을 만드는 사람들이 왜?&lt;/h1>
&lt;p>저희가 만드는 Libplanet은 탈중앙 게임을 만들기 위한 블록체인 라이브러리입니다.
저희는 이 Libplanet을 통해서 별도의 중앙 서버 없이도 영원히 플레이 가능한
멀티플레이어 게임이 만들어지는 것을 기대하며, 목표로 하고 있습니다. 실제로 이
Libplanet을 사용해서 만들어진 최초의 MMO 게임인 &lt;a href="https://nine-chronicles.com">나인 크로니클&lt;/a> 역시, 현재는 비록
불완전하지만 이런 탈중앙화 된 게임을 목표로 하여 개발/운영되고 있습니다.&lt;/p>
&lt;p>여기까지만 보면 Libplanet과 나인 크로니클을 만드는 저희가 AWS 같은 중앙화 된
&lt;abbr title="Infrastructure as a Service">&lt;a href="https://en.wikipedia.org/wiki/Infrastructure_as_a_service">IaaS&lt;/a>&lt;/abbr>를 쓰는 것, 그리고 그런
서비스의 제품군을 소개하는 행사에 참석하는 것이 아이러니하게 보일 수 있습니다.&lt;/p>
&lt;p>여기에는 크게 2가지 이야기할 거리가 있을 것 같습니다.&lt;/p>
&lt;h2 id="aws는-단순한-운영-도구-이상입니다">AWS는 단순한 운영 도구 이상입니다.&lt;/h2>
&lt;p>서두에 말씀드린 것처럼, 현대 소프트웨어 개발에 있어서 AWS와 같은 클라우드 기반
IaaS들이 가져온 변화는 상상 이상의 것입니다. 많은 개발자가 물리 서버 기반의
초기 투자 없이도 자신의 서비스를 가볍게 시험해보고, 또 릴리스해 볼 수 있게
되었습니다. 블록체인 역시 소프트웨어이기 때문에 예외가 아닙니다.
실제로, AWS나 Azure, GCP 모두 블록체인(주로 이더리움) 노드에 대한 템플릿, 혹은
관리형 서비스를 제공합니다.&lt;/p>
&lt;p>&lt;img src="images/aws-blockchain-template.png">&lt;/p>
&lt;p>이런 템플릿으로 노드를 쉽게 띄워서 돌려볼 수 있게 하므로, 엔지니어가 서비스나
애플리케이션(저희의 경우 게임)의 공개까지 개발 기간을 단축 시키는 효과를 가져올 뿐
아니라, 운영 환경에서 얻을 수 있는 정보들을 빠르게 개발팀으로 피드백 시키는 수단으로
활용 할 수 있습니다.&lt;/p>
&lt;h2 id="결국-운영-그리고-운영">결국 운영, 그리고 운영&lt;/h2>
&lt;p>저희가 만들고 있는 나인 크로니클은 특정 중앙 주체가 도맡아서 운영하는 대신, 분산된
노드들을 여러 주체가 운영하는 것을 목표로 합니다. 하지만 과연 노드를 어디서 어떻게
실행해야 할까요?&lt;/p>
&lt;p>종래의 중앙화 된 게임 서버들은 &lt;a href="https://en.wikipedia.org/wiki/On-premises_software">온 프레미스&lt;/a>(on-premises)라고 불리는
호스팅 환경에서 실행되어왔습니다. 최근에 와서는 운영 효율 등을 고려하여 클라우드
IaaS로의 이전을 검토하고, &lt;a href="https://aws.amazon.com/ko/gaming/gaming-customer-references/">성공 사례들&lt;/a>이 나오고 있지만, 크게 대중화된 방식은
아닙니다. 주요한 이유 중 하나는, 개인이나 작은 규모의 팀들이 고민하는
&amp;ldquo;작은 규모로 먼저 시작할 수 있다&amp;quot;라는 강점이 그리 크게 받아들여지기 어렵기 때문일
것입니다.&lt;/p>
&lt;p>&lt;img src="images/9c-structure.jpg">&lt;/p>
&lt;p>하지만 탈중앙 게임을 지향하는 나인 크로니클과 같은 게임에서, 저희는 노드를 운영하는
사람들이 초기 투자를 많이 하지 않고도 본인들이 원하는 규모에서
&lt;a href="https://en.wikipedia.org/wiki/Scalability#Horizontal_(scale_out)_and_vertical_scaling_(scale_up)">스케일 아웃&lt;/a> 할 수 있는 환경을 제공하는 것은 대단히 중요하다고
생각합니다. 이는 AWS와 같은 클라우드 IaaS가 제공하는 강점과 정확히 부합하죠.&lt;/p>
&lt;h1 id="남은-이야기들">남은 이야기들&lt;/h1>
&lt;p>거창하게 여러 가지 이유를 이야기했지만, 아쉽게도 저는 re:Invent 행사장에서 많은
세션을 듣지는 못했습니다. 하지만 걱정 마세요. 곧 이어서 다른 분들의 re:Invent
후기를 이곳에 공유토록 하겠습니다.&lt;/p>
&lt;p>또한, 저희와 함께 AWS와 같은 클라우드에 탈중앙 게임 노드를 배포 / 운영하는
도구를 함께 만들 인프라 엔지니어를 &lt;a href="https://recruit.planetariumhq.com/e2ba3fcc-ce76-456a-bea9-0be97622cb48">모시고 있습니다.&lt;/a> 블록체인이나 C# 경험이
없더라도, AWS와 같은 IaaS를 사용해보신 경험이 있으신 분들이라면 가벼운 마음으로
많은 지원 부탁드립니다.&lt;/p></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>Libplanet 팀이 2022년 1월 스프린트서울에도 참여합니다!</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2022/01/sprintseoul/" title="Libplanet 팀이 2022년 1월 스프린트서울에도 참여합니다!"/><id>https://snack.planetarium.dev/kor/2022/01/sprintseoul/</id><published>2022-01-17T00:00:00+00:00</published><updated>2022-01-17T00:00:00+00:00</updated><content type="html">&lt;p>정말로 오랜만입니다! &lt;a href="https://sprintseoul.org/">스프린트서울&lt;/a>에 프로젝트 리더로 참가하는 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>
팀입니다.&lt;/p>
&lt;p>장기화 된 코로나로 많은 행사들이 연기되거나 축소되어 많은 분들이 아쉬워하고 계실 것
같습니다. 그런데 다행히도 &lt;a href="https://sprintseoul.org/2022-01-22/">올해 1월 22일 토요일에 스프린트서울이 비대면으로
재개된다는 기쁜 소식&lt;/a>을 접했고,
감사하게도 이번에도 프로젝트 리더로 선정되어 여러분을 만나려 합니다.
지난 번 참여했을 때에는 라이브러리인 Libplanet으로 참가했었는데, 이번에는 함께
개발한 오픈소스 탈중앙 게임인 &lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>쪽도 함께 참가합니다.&lt;/p>
&lt;h2 id="프로젝트-소개">프로젝트 소개&lt;/h2>
&lt;p>&lt;a href="https://libplanet.io/">Libplanet&lt;/a>은 BitTorrent처럼 서버 없이 돌아가는 P2P 멀티플레이 게임을 만들기
위한 네트워킹・스토리지 라이브러리로, 이를 달성하기 위해 블록체인 기술을
구현합니다. 이용자 각각이 실행하는 게임 앱들이 네트워크에서 서로 연결되며,
게임의 공정한 판정과 기록을 위해 운영되는 서버가 없는 대신,
공정한 판정은 합의 알고리즘을 통해, 기록은 리플리케이션을 통해 이뤄집니다.&lt;/p>
&lt;p>&lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>은 위에서 소개한 Libplanet을 사용한 최초의 P2P MMO 게임으로,
2020년 10월 메인넷을 출범한 이후 현재까지 약 1년 3개월간 운영하고 있는 커뮤니티
주도형 탈중앙 게임입니다. 게임 진행에 필요한 모든 게임 로직이 블록체인 위에서
동작하는 것이 가장 큰 특징으로, 현재 일 평균 3,000명 정도가 플레이하고 있습니다.&lt;/p>
&lt;p>이번 스프린트에서 다룰 저장소로는 아래 두 곳으로, 각자 익숙하거나 선호하시는 환경에
따라 다른 저장소에 기여해 주시면 됩니다. 또한 모든 저장소의 프로젝트는
Linux, macOS, Windows 세 플랫폼에서 개발 가능합니다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a>: 네트워킹 및 스토리지, 블록체인 등을 구현하는
프로젝트의 핵심으로, Unity 등의 게임 엔진과 함께 쓰일 수 있도록 C#으로
작성되어 있으며 멀티플랫폼입니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/planetarium/9c-launcher">나인 크로니클 게임 론처&lt;/a>: 나인 크로니클의 개인 키와 계정 관리,
그리고 가장 중요한 게임 클라이언트의 실행을 담당하는 GUI 애플리케이션입니다.
Electron으로 개발되어 있으며 TypeScript와 React, 그리고 GraphQL을 적극적으로 사용하고 있습니다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="c-개발-환경">C# 개발 환경&lt;/h2>
&lt;p>먼저, C# 프로젝트에 참여하기 위해서는 개발 환경을 설치해야 합니다.
C#은 Python이나 JavaScript 등과 달리 IDE가 없으면 코딩하기 힘든 언어입니다.
Windows라면 최신 버전의 Visual Studio를 설치하면 되겠지만, 여러 플랫폼에서
두루 쓸 수 있는 IDE로 Rider나 VS Code를 추천합니다. 아래 문서들은
Rider 또는 Visual Studio Code를 쓴다는 가정 하에 Libplanet의 개발 환경을
설치하는 방법을 한국어로 안내하고 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://sprintseoul.org/2022-01-22/">Libplanet 개발 환경 설정 (VS Code)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gist.github.com/dahlia/08f6e659e2266e941ad026f591c30c9a">Libplanet 개발 환경 설정 (Rider)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>그 외에, Libplanet 저장소의 &lt;em>&lt;a href="https://github.com/planetarium/libplanet/blob/main/CONTRIBUTING.md">CONTRIBUTING.md&lt;/a>&lt;/em> 문서는 CLI 도구만을 이용해서
개발하는 아주 기본적인 개발 환경 설정을 안내합니다. 꼭 자신이 이용하는 에디터를
쓰고 싶은 분들은 이쪽을 읽어주시면 되겠습니다.&lt;/p>
&lt;h2 id="고민되거나-망설여진다면">고민되거나 망설여진다면&lt;/h2>
&lt;p>어떤 기여를 어떻게 해야 할지 고민이 되는 분들은, 저희 프로젝트에 기여하신 분들의
경험담을 읽어보시고 결정하셔도 좋을 것 같습니다.&lt;/p>
&lt;ul>
&lt;li>이승훈 님께서 쓰신 &lt;cite>&lt;a href="https://snack.planetarium.dev/kor/2019/05/first-contribution/">Libplanet 처음 기여하기&lt;/a>&lt;/cite>&lt;/li>
&lt;li>이수호 님께서 쓰신 &lt;cite>&lt;a href="https://web.archive.org/web/20201028104023/https://blog.hanaoto.me/sprint_seoul_2019_june/">2019 스프린트 서울 6월 행사를 참여하고 나서&amp;hellip;&lt;/a>&lt;/cite>&lt;/li>
&lt;/ul>
&lt;h2 id="질문-및-대화방">질문 및 대화방&lt;/h2>
&lt;p>궁금한 게 있으시면 &lt;a href="https://discord.gg/YaHPjcrdrw">저희 Discord 서버&lt;/a>에 오셔서 물어보셔도 됩니다. 행사 전에
미리 들어오셔서 물어보셔도 좋고, 행사 끝난 뒤라도 좋습니다. 물론 가볍게 놀러 오시는
것도 환영입니다!&lt;/p></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.11–0.19 업데이트 요약</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2021/10/libplanet-0.11-0.19/" title="Libplanet 0.11–0.19 업데이트 요약"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2021/10/libplanet-0.11-0.19/" hreflang="" title="What's new in Libplanet 0.11–0.19"/><id>https://snack.planetarium.dev/kor/2021/10/libplanet-0.11-0.19/</id><published>2021-10-29T00:00:00+00:00</published><updated>2021-10-29T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 오랜만에 소식 전합니다. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>은 지난 몇 달 동안, 여러
마이너 버전을 릴리스했습니다. 그렇지만 저희의 릴리스 정책과 주기가 바뀜에 따라,
그리고 Libplanet으로 만들어진 첫 게임 〈&lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>〉 메인넷의 여러 문제들에
대응하느라 차분히 그간의 업데이트를 정리된 글로 쓸 여유가 없었습니다.
그래서 이번 글에서 그 사이의 변화 중 큰 것들을 중심으로 소개해 볼까 합니다.&lt;/p>
&lt;h2 id="달라진-릴리스-주기">달라진 릴리스 주기&lt;/h2>
&lt;p>이전까지 Libplanet은 릴리스 주기에 뚜렷한 규칙이 없었습니다. 주로 큰 API 변경이
있거나 마지막 릴리스 이후로 시간이 많이 지났을 때 그 동안의 변경을 모아서 새
버전 번호를 부여하는 것에 가까웠습니다.&lt;/p>
&lt;p>그러나 지난해 〈&lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>〉 메인넷 (이하 &lt;q>메인넷&lt;/q>) 출범 이후,
메인넷의 크고 작은 문제들을 해결해 나가기 위해 Libplanet도 그에 발맞춘 잦은
릴리스가 이뤄져야 했습니다. 현재 플라네타리움의 Libplanet 팀과 〈나인 크로니클〉
팀은 긴밀히 협력하며 릴리스 주기를 맞추고 있습니다. 이러한 기조는 한동안 바뀌지
않을 것으로 보입니다.&lt;/p>
&lt;p>그러한 방침 아래, 지난 몇 달 동안 릴리스된 Libplanet 버전으로는 올해 3월에 나온
0.11.0부터 금주에 나온 0.19.0까지 총 9번의 마이너 업데이트가 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.11.0">0.11.0&lt;/a> (3월 30일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.12.0">0.12.0&lt;/a> (7월 23일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.13.0">0.13.0&lt;/a> (7월 28일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.14.0">0.14.0&lt;/a> (8월 5일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.15.0">0.15.0&lt;/a> (8월 18일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.16.0">0.16.0&lt;/a> (8월 25일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.17.0">0.17.0&lt;/a> (9월 28일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.18.0">0.18.0&lt;/a> (10월 13일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.19.0">0.19.0&lt;/a> (10월 27일)&lt;/li>
&lt;/ul>
&lt;h2 id="프로토콜-버전">프로토콜 버전&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.11.0">0.11.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>프로토콜 버전은 블록에 붙는 속성으로, 해당 블록이 어떤 Libplanet 버전을 써서
마이닝됐는지 기록합니다. 프로토콜 버전은 Libplanet을 이용해 만들어진 게임이
Libplanet 버전을 쉽게 업그레이드할 수 있도록 도우며, 한편으로는 Libplanet 쪽에서
기존의 네트워크를 유지하면서도 기능을 추가할 수 있게 합니다.&lt;/p>
&lt;p>API 측면에서는 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_ProtocolVersion">&lt;code>Block&amp;lt;T&amp;gt;.ProtocolVersion&lt;/code> 속성&lt;/a>으로
확인할 수 있으며, 32비트 정수형으로 표현됩니다. 표현되는 프로토콜 버전은
Libplanet의 패키지 버전과는 별개의 네트워크 프로토콜의 버전인데, 패키지 버전의
패치 릴리스는 프로토콜 버전이 올라갈 수 없고 반드시 마이너 및 메이저 릴리스할
때만 프로토콜 버전도 함께 증가됩니다.&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.19.0">0.19.0&lt;/a> 버전 현재 프로토콜 버전은 2이고, 프로토콜 버전이 도입된 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.11.0">0.11.0&lt;/a> 버전
미만에서 생성된 블록은 모두 프로토콜 버전 0으로 취급됩니다.&lt;/p>
&lt;h2 id="네트워크-트랜스포트-레이어">네트워크 트랜스포트 레이어&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.11.0">0.11.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>오랫동안 Libplanet은 네트워크 통신에 있어 많은 저수준 처리를 &lt;a href="https://zeromq.org/">ZeroMQ&lt;/a>의
.NET 구현인 &lt;a href="https://github.com/zeromq/netmq">NetMQ&lt;/a>에 맡겨 왔습니다. 하지만 모바일이나 웹 등 여러 플랫폼에서도
Libplanet을 쓸 수 있도록, NetMQ에 의존하지 않고도 네트워크 통신이 가능하게
바뀔 필요가 있었습니다.&lt;/p>
&lt;p>네트워크 트랜스포트 레이어는 저수준 통신 방식을 다양화하고, 특수한 요구사항이
있을 경우 게임 개발자도 직접 저수준 통신 방식을 정의하여 쓸 수 있도록 추가된
실험적인 추상화 계층입니다.&lt;/p>
&lt;p>API 측면에서는 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Net.Transports.ITransport.html">&lt;code>ITransport&lt;/code> 인터페이스&lt;/a>로 표현되며, 이를 구현한
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Net.Transports.NetMQTransport.html">&lt;code>NetMQTransport&lt;/code> 클래스&lt;/a>가 기본 제공됩니다.&lt;/p>
&lt;p>시범 단계이기에 인터페이스는 현재 여러 마이너 릴리스에 걸쳐 조정되고 있으며,
아직 게임 개발자가 직접 정의한 트랜스포트 구현을 사용할 수는 없습니다.
연내에는 &lt;code>NetMQTransport&lt;/code>를 대체할 &lt;a href="https://github.com/planetarium/libplanet/pull/1523">새로운 TCP 기반 트랜스포트&lt;/a>
구현과 함께 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Net.Swarm-1.html">&lt;code>Swarm&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 객체가 사용자 정의 트랜스포트를 쓰도록 설정
가능해질 예정입니다.&lt;/p>
&lt;h2 id="교체-가능한-작업-증명-해시-알고리즘">교체 가능한 작업 증명 해시 알고리즘&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.12.0">0.12.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>이전까지 Libplanet은 작업 증명에 &lt;a href="https://ko.wikipedia.org/wiki/SHA-2">SHA-256&lt;/a> 해시 알고리즘을 써 왔습니다.
그러나 0.12.0 버전부터는 네트워크마다 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_GetHashAlgorithm_System_Int64_">&lt;code>IBlockPolicy&amp;lt;T&amp;gt;.GetHashAlgorithm()&lt;/code>
메서드&lt;/a>를 정의하여 해시 알고리즘을 선택할
수 있게 됐습니다. 네트워크마다 다르게 할 수 있을 뿐만 아니라 블록 인덱스에
따라 다른 해시 알고리즘을 쓸 수도 있기 때문에, 네트워크 출범 이후에도 다른 해시
알고리즘으로 쉽게 이행할 수 있습니다.&lt;/p>
&lt;p>.NET 런타임에 정의된 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hashalgorithm">&lt;code>HashAlgorithm&lt;/code> 추상 클래스&lt;/a>의
서브클래스라면 모두 해시 알고리즘으로 사용할 수 있습니다. 서브클래스는 꼭
.NET 런타임에서 제공하는 것으로 국한되지 않으며, 사용자가 직접 상속 받아
구현하거나 NuGet 등으로 제공되는 서드파티 라이브러리에서 정의한 것도
쓸 수 있습니다. 이를테면 플라네타리움에서 직접 만든 RandomX의 .NET 바인딩
라이브러리인 &lt;a href="https://github.com/planetarium/RandomXSharp">RandomXSharp&lt;/a> 역시 &lt;code>HashAlgorithm&lt;/code>의 서브클래스를 제공합니다.&lt;/p>
&lt;p>다음 코드는 1만번째 블록까지는 SHA-256을 쓰고 그 뒤부터는 SHA-512를 쓰도록
블록체인 정책을 설정하는 예입니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-csharp" data-lang="csharp">&lt;span style="display:flex;">&lt;span>HashAlgorithmType GetHashAlgorithm(&lt;span style="color:#888;font-weight:bold">long&lt;/span> index) =&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> index &amp;lt;= &lt;span style="color:#00d;font-weight:bold">10_000&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ? HashAlgorithmType.Of&amp;lt;SHA256&amp;gt;()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> : HashAlgorithmType.Of&amp;lt;SHA512&amp;gt;();
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="논블로킹-렌더러">논블로킹 렌더러&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.14.0">0.14.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>노드의 로컬 블록체인의 상태가 변화를 이벤트로 수신할 수 있는
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Renderers.IRenderer-1.html">&lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 및 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Renderers.IActionRenderer-1.html">&lt;code>IActionRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a>
인터페이스는 별도의 스레드를 만들지 않는 대신 렌더링 로직이 블로킹으로
동작합니다. 이를테면, 렌더링 로직이 &lt;code>Thread.Sleep(60_000)&lt;/code>을 호출한다면
블록체인의 다음 상태 변화는 60초의 렌더링을 기다린 뒤에 이뤄진다는 것입니다.&lt;/p>
&lt;p>0.14.0 버전부터는 시간이 소요되는 렌더링 로직을 별도 스레드에서 논블로킹
방식으로 실행할 수 있게 해주는 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Renderers.NonblockRenderer-1.html">&lt;code>NonblockRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 및
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Renderers.NonblockActionRenderer-1.html">&lt;code>NonblockActionRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 데코레이터 클래스가
도입됐습니다. 두 클래스는 생성자에서 다른 렌더러를 인자로 받아, 해당 렌더러의
이벤트 핸들러를 별도 스레드에서 호출합니다. 따라서 기존의 렌더러 구현을 한 번
감싸는 것만으로 논블로킹 방식으로 전환할 수 있습니다.&lt;/p>
&lt;p>논블로킹 방식이지만 내부적으로는 대기열이 존재하며, 따라서 이벤트의 순서는
보장됩니다.&lt;/p>
&lt;h2 id="마이너가-설정-가능한-트랜잭션-선호-함수">마이너가 설정 가능한 트랜잭션 선호 함수&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.17.0">0.17.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>마이닝할 블록에 포함할 트랜잭션들은 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_ValidateNextBlockTx_Libplanet_Blockchain_BlockChain__0__Libplanet_Tx_Transaction__0__">&lt;code>IBlockPolicy&amp;lt;T&amp;gt;.ValidateNextBlockTx()&lt;/code>
서술 메서드&lt;/a>를 만족하기만 한다면,
프로토콜에서 정해진 우선순위는 없습니다.&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> 그렇지만 아직 블록에 포함되지 않는
트랜잭션이 너무 많을 때는 한 블록에 너무 많은 트랜잭션을 다 넣을 수 없기 때문에,
어떤 트랜잭션을 이번 블록에 포함시키고 어떤 트랜잭션을 나중 블록으로 미룰지 줄을
세워야 합니다.&lt;/p>
&lt;p>0.17.0 버전부터는 어떤 트랜잭션부터 블록에 넣을지 그 기준을 Libplanet이 임의로
정하는 대신 마이너가 정할 수 있게 됐습니다. API 측면에서는
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1_MineBlock_Libplanet_Crypto_PrivateKey_DateTimeOffset_System_Boolean_System_Int32_System_Int32_IComparer_Libplanet_Tx_Transaction__0___CancellationToken_">&lt;code>BlockChain&amp;lt;T&amp;gt;.MineBlock()&lt;/code> 메서드&lt;/a>에
&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icomparer-1">&lt;code>IComparer&amp;lt;Transaction&amp;lt;T&amp;gt;&amp;gt;&lt;/code> 타입&lt;/a>의 옵션 &lt;code>txPriority&lt;/code>가
생겼습니다.&lt;/p>
&lt;h2 id="블록-서명">블록 서명&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.18.0">0.18.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>프로토콜 버전 2, Libplanet 버전 0.18.0부터 블록은 마이너의 비밀 키로 서명되며
블록에는 마이너의 주소 뿐만 아니라 공개 키가 포함됩니다.&lt;/p>
&lt;p>API 측면에서는, 블록의 서명은 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_Signature">&lt;code>Block&amp;lt;T&amp;gt;.Signature&lt;/code> 속성&lt;/a>에
담기고 마이너의 공개 키는 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_PublicKey">&lt;code>Block&amp;lt;T&amp;gt;.PublicKey&lt;/code> 속성&lt;/a>에
담기게 됩니다. 프로토콜 버전 1 및 0의 블록에서는 두 속성이 모두 &lt;code>null&lt;/code>로
비어 있습니다.&lt;/p>
&lt;h2 id="병렬-프로세스-마이닝">병렬 프로세스 마이닝&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.19.0">0.19.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>Libplanet 0.19.0 버전부터는 블록 마이닝이 자동으로 해당 기기의 프로세서 코어
수에 따라 병렬로 수행됩니다. 마이너가 직접 활용할 프로세스 수를 조절하는
옵션은 추후 버전에서 추가될 예정입니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 외에도 수많은 기능이 더해졌을 뿐만 아니라, 몇 달 동안의 메인넷 운영에서
발생한 문제를 해결하며 많은 영역에서 크게 안정화 됐습니다. 자세한 내용은
각 버전의 &lt;a href="https://github.com/planetarium/libplanet/blob/0.19.0/CHANGES.md">전체 변경 내역&lt;/a>에서 확인해 주세요.&lt;/p>
&lt;p>호기심이 생기신 분들은 설치해서 이용해 보시고, 궁금한 점이 있으시다면 저희 팀이
상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드&lt;/a>에도 놀러오세요!&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>모든 메이저 및 마이너 릴리스가 프로토콜 버전을 증가시키는 것은 아닙니다.
사실, 대부분의 릴리스는 프로토콜 버전을 증가시키지 않습니다.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>물론 같은 서명자의 트랜잭션들 사이에는
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Tx.Transaction-1.html#Libplanet_Tx_Transaction_1_Nonce">&lt;code>Transaction&amp;lt;T&amp;gt;.Nonce&lt;/code>&lt;/a>를 기준으로 정해지는 순서가
있습니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.10 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/12/libplanet-0.10/" title="Libplanet 0.10 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/12/libplanet-0.10/" hreflang="" title="Libplanet 0.10 Released"/><id>https://snack.planetarium.dev/kor/2020/12/libplanet-0.10/</id><published>2020-12-08T00:00:00+00:00</published><updated>2020-12-08T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 열 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.10.0">0.10 버전&lt;/a>이
릴리스되었습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&lt;/p>
&lt;p>이번 버전부터 Libplanet은 상태를 관리하기 위해 &lt;a href="https://eth.wiki/en/fundamentals/patricia-tree">&lt;abbr title="Merkle–Patricia Trie">MPT&lt;/abbr>&lt;/a>를
사용하고, 자산 관리를 위한 별도의 API가 추가되는 등, 여기서 소개하는 내용 이외에도
인터페이스 내외로 많은 변경점이 있었습니다.&lt;/p>
&lt;p>이 글에서는 0.10 버전의 주요 변경 사항들에 대해서 다루겠습니다.&lt;/p>
&lt;h2 id="결과-상태를-포함하여-유도된-blockthash">결과 상태를 포함하여 유도된 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_Hash">&lt;code>Block&amp;lt;T&amp;gt;.Hash&lt;/code>&lt;/a>&lt;/h2>
&lt;p>그동안 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html">&lt;code>Block&amp;lt;T&amp;gt;&lt;/code>&lt;/a>은 해당 블록이 가지고 있는 상태에 대한 정보를 따로 들고 있지 않았습니다.
따라서 블록에서 상태를 유도할 수는 있어도, 블록에서 상태의 정합성 등을 검증할 수 있는 방법은
오직 액션을 직접 실행하는 방법 뿐이었습니다. 하지만 이제 &lt;code>Block&amp;lt;T&amp;gt;.Hash&lt;/code> 는 해당 블록에 대한 정보 뿐만 아니라,
블록 내 액션을 평가하고 나온 결과의 해시값인 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_StateRootHash">&lt;code>Block&amp;lt;T&amp;gt;.StateRootHash&lt;/code>&lt;/a>도 포함되어 유도됩니다. 이전과 같이 액션을 평가하지 않고 블록 정보만을 가진
해시는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_PreEvaluationHash">&lt;code>Block&amp;lt;T&amp;gt;.PreEvaluationHash&lt;/code>&lt;/a> 속성에 들어갑니다.&lt;/p>
&lt;h2 id="blockttotaldifficulty">&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_TotalDifficulty">&lt;code>Block&amp;lt;T&amp;gt;.TotalDifficulty&lt;/code>&lt;/a>&lt;/h2>
&lt;p>그동안은 블록체인의 정본 체인(canonical chain)의 선출 기준에는 블록 높이(&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_Index">&lt;code>Block&amp;lt;T&amp;gt;.Index&lt;/code>&lt;/a>)만 고려되었습니다.
하지만 네트워크에 같은 높이의 블록이 비슷한 속도로 여럿 나오는 경우는 흔하기에, 합의가 지역적으로만 이뤄지는 경우가 잦았습니다.
같은 높이라면 어떤 블록을 선택해도 괜찮으니, 선택지가 많아 모호성이 생기기 때문입니다.
이 문제를 바로잡기 위해, 새 버전부터는 사실상 선택지가 언제나 하나가 되도록 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_TotalDifficulty">&lt;code>Block&amp;lt;T&amp;gt;.TotalDifficulty&lt;/code>&lt;/a> 속성을 추가하고, 이 속성을 정본의 기준으로 삼게 되었습니다.
&lt;code>Block&amp;lt;T&amp;gt;.TotalDifficulty&lt;/code> 속성은 해당 블록에서부터 제너시스 블록에 이르는 모든 블록(자기 자신과 제너시스 포함)의 난이도(&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_Difficulty">&lt;code>Block&amp;lt;T&amp;gt;.Difficulty&lt;/code>&lt;/a>)의 합입니다.
따라서 단순히 난이도가 낮은 블록을 빨리 찍어서 블록을 높게 쌓는 것만으로 정본을 취할 수 없기에 보안 측면에서도 향상됐습니다.&lt;/p>
&lt;h2 id="abbr-titlemerklepatricia-triemptabbr">&lt;abbr title="Merkle–Patricia Trie">MPT&lt;/abbr>&lt;/h2>
&lt;p>&lt;abbr title="Merkle–Patricia Trie">MPT&lt;/abbr>는 이더리움 등에서 상태를 저장하는 데에 사용되는 트라이(trie) 자료 구조입니다.
기존에는 상태를 저장하는 데 블록 단위로 전역 상태의 변량을 보존하고 상태 참조라는 색인을 통해
조회하는 방식을 사용했었는데, 이 방식은 오랫동안 갱신되지 않은 상태를 조회할 때
시간이 많이 걸리는 문제가 있었습니다. 이제는 MPT 구조를 통해 훨씬 빠르게 상태를 조회할 수 있게 하였습니다.&lt;/p>
&lt;p>또한 디버깅을 돕기 위해 새로 추가된 &lt;code>planet mpt&lt;/code> 명령어로 블록 간 상태를
비교하거나, 특정 블록에서의 상태를 손쉽게 가져올 수 있게 되었습니다. 사용법은 &lt;code>planet mpt --help&lt;/code> 옵션을
참고해 주십시오.&lt;/p>
&lt;h2 id="자산을-위한-별도-상태-api">자산을 위한 별도 상태 API&lt;/h2>
&lt;p>이제까지 Libplanet으로 게임을 만들 때 게임 내 재화는 다른 게임 내 상태와 같은 방식으로 다뤄졌습니다.
이를테면 NCG(〈나인 크로니클〉 골드)는 정수 자료형의 값으로 구현되었습니다. 그러나 그러한 재화는
복제되거나 함부로 소멸되어서는 안 되는데, 사칙연산이 자유롭고 재화 특유의 성질을 내제하고 있지 않은
정수 자료형으로 재화를 구현하다 보면 버그가 끼어들기 쉬웠습니다.&lt;/p>
&lt;p>예를 들어, 돈을 이체할 경우에도,
원래 소유자의 잔고는 줄이고 새 소유자의 잔고는 늘려야 하는데, 원래 소유자의 잔고에서 금액을 빼는 것을
빼먹거나 반대로 새 소유자의 잔고에 더하는 것을 빼먹는 버그가 들어갈 수 있었습니다. 혹은 돈을 여러 사람에게
분배할 때도, 나누어 떨어지지 않는 금액이 아무도 모르게 소멸되는 버그도 생기기 쉬웠습니다.&lt;/p>
&lt;p>더 큰 수준의 버그도 일어나기 쉬웠는데, 이를테면 프로그래머가 별 신경을 쓰지 않고 게임의 보상으로 플레이어에
잔고에 돈을 더해주는 식의 코드만 짜도, 게임 전체의 경제상으로는 사실상 화폐를 사적으로 주조를 하는 것과 다름 없어집니다.&lt;/p>
&lt;p>이러한 실수들을 일찍부터 방지하기 위해, 이번 버전에서는 자산만을 다루기 위한 별도의 상태 API가 생겼습니다.
기존의 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1_GetState_Libplanet_Address_System_Nullable_Libplanet_HashDigest_SHA256___Libplanet_Blockchain_StateCompleter__0__">&lt;code>BlockChain&amp;lt;T&amp;gt;.GetState()&lt;/code>&lt;/a> 및 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_GetState_Libplanet_Address_">&lt;code>IAccountStateDelta.GetState()&lt;/code>&lt;/a> 메서드와 나란히 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1_GetBalance_Libplanet_Address_Libplanet_Assets_Currency_System_Nullable_Libplanet_HashDigest_SHA256___Libplanet_Blockchain_FungibleAssetStateCompleter__0__">&lt;code>BlockChain&amp;lt;T&amp;gt;.GetBalance()&lt;/code>&lt;/a>
및 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_GetBalance_Libplanet_Address_Libplanet_Assets_Currency_">&lt;code>IAccountStateDelta.GetBalance()&lt;/code>&lt;/a> 메서드가 생겼고, 상태를 자유롭게 덮어 쓸 수 있는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_SetState_Libplanet_Address_IValue_">&lt;code>IAccountStateDelta.SetState()&lt;/code>&lt;/a> 메서드와
달리 이체를 위한 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_SetState_Libplanet_Address_IValue_">&lt;code>IAccountStateDelta.TransferAsset()&lt;/code>&lt;/a>과 주조를 위한 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_MintAsset_Libplanet_Address_Libplanet_Assets_FungibleAssetValue_">&lt;code>IAccountStateDelta.MintAsset()&lt;/code>&lt;/a> 등 용도별 메서드가 생겼습니다.&lt;/p>
&lt;p>또, 자산을 값으로 다룰 때도 .NET의 내장 정수 자료형을 쓰는 대신, Libplanet에 새롭게 더해진
&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Assets.FungibleAssetValue.html">&lt;code>FungibleAssetValue&lt;/code>&lt;/a> 자료형을 써야 합니다. &lt;code>FungibleAssetValue&lt;/code>는 기본적으로 &lt;a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.numerics.biginteger?view=net-5.0">&lt;code>BigInteger&lt;/code>&lt;/a>처럼 생겼지만,
몇 몇 부분에서 차이가 있습니다.&lt;/p>
&lt;ol>
&lt;li>나눗셈을 할 때 나머지 값을 암시적으로 버리지 않고, 항상 나머지를 명시적으로 다뤄야 합니다.
따라서 나눗셈 연산자(&lt;code>/&lt;/code>)를 구현하지 않고 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Assets.FungibleAssetValue.html#Libplanet_Assets_FungibleAssetValue_DivRem_Libplanet_Assets_FungibleAssetValue_">&lt;code>DivRem()&lt;/code>&lt;/a> 메서드만 구현합니다.&lt;/li>
&lt;li>달러–센트 같이 하부 화폐 단위(minor currency units)를 지원하며, 하부 단위의 자릿수에 한계를 둡니다.&lt;/li>
&lt;li>서로 통화끼리는 섞이지 않도록, 각 값의 화폐 단위를 보존합니다.
마지막으로, 위의 3번을 구현하기 위해 화폐 단위를 정의하는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Assets.Currency.html">&lt;code>Currency&lt;/code>&lt;/a> 자료형이 생겼습니다.
해당 자료형은 화폐 단위의 명칭이나 티커 심볼, 하부 단위의 자릿수 등을 속성으로 갖습니다.&lt;/li>
&lt;/ol>
&lt;p>현재 자산 상태 API는 게임 머니 같은 변용성 자산(fungible assets)만 지원하지만, 추후 버전에서는 게임 아이템 같은 대체 불가 자산
&lt;a href="https://en.wikipedia.org/wiki/Non-fungible_token">&lt;abbr title="non-fungible token">NFT&lt;/abbr>&lt;/a>도 지원할 예정입니다.&lt;/p>
&lt;h2 id="새로운-렌더링-api">새로운 렌더링 API&lt;/h2>
&lt;p>기존에는 액션의 결과를 화면 등에 반영하기 위해 액션 클래스에 &lt;a href="https://docs.libplanet.io/0.9.2/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Render_Libplanet_Action_IActionContext_Libplanet_Action_IAccountStateDelta_">&lt;code>Render()&lt;/code>&lt;/a> 메서드를
구현해야 했습니다. 그러나 이러한 기존 API는 순수한 로직에 해당하는 액션 클래스에 뷰가 섞이게
만드는 문제가 있었습니다.&lt;/p>
&lt;p>예를 들어 같은 블록체인에 대해 3D 게임 엔진을 탑재한 풀 게임 프론트엔드와,
간단한 알림 기능과 게임 내 자산만 보여주는 지갑 프론트엔드를 만드려고 하면, &lt;code>Render()&lt;/code> 메서드에는
양쪽에 필요한 모든 코드가 들어가거나, 콜백을 전역 상태로 두고 이를 호출하는 패턴을 따르게 됩니다.
하나의 액션에 다양한 렌더링을 구현할 수 없기 때문입니다.&lt;/p>
&lt;p>이를 해결하기 위해 새 버전부터는 &lt;a href="https://docs.libplanet.io/0.9.2/api/Libplanet.Action.IAction.html">&lt;code>IAction&lt;/code>&lt;/a> 인터페이스에 &lt;code>Render()&lt;/code> 및 &lt;a href="https://docs.libplanet.io/0.9.2/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Unrender_Libplanet_Action_IActionContext_Libplanet_Action_IAccountStateDelta_">&lt;code>Unrender()&lt;/code>&lt;/a>
메서드가 사라지고, 대신 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IRenderer-1.html">&lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 및 그 서브타입인 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IActionRenderer-1.html">&lt;code>IActionRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a>
인터페이스가 새롭게 생겼습니다. 프론트엔드는 각자를 위한 &lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code> 또는 &lt;code>IActionRenderer&amp;lt;T&amp;gt;&lt;/code> 구현을 갖고,
이를 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.BlockChain-1.html">&lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 객체 생성시에 연결하면 됩니다.&lt;/p>
&lt;p>간단한 렌더링만이 필요할 때는 인터페이스를 구현하는
클래스를 직접 짜는 대신, &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.AnonymousRenderer-1.html">&lt;code>AnonymousRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 클래스를 써보는 것을 추천합니다.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>
또한, 새 렌더링 API는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IActionRenderer-1.html#Libplanet_Blockchain_Renderers_IActionRenderer_1_RenderActionError_Libplanet_Action_IAction_Libplanet_Action_IActionContext_Exception_">&lt;code>IActionRenderer&amp;lt;T&amp;gt;.RenderActionError()&lt;/code>&lt;/a> 메서드를 통해 액션에서 난 예외를 다루거나,
&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IRenderer-1.html#Libplanet_Blockchain_Renderers_IRenderer_1_RenderBlock_Libplanet_Blocks_Block__0__Libplanet_Blocks_Block__0__">&lt;code>IRenderer&amp;lt;T&amp;gt;.RenderBlock()&lt;/code>&lt;/a> 메서드를 통해 블록체인의 높이가 바뀐 것을 감지하거나, &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IRenderer-1.html#Libplanet_Blockchain_Renderers_IRenderer_1_RenderReorg_Libplanet_Blocks_Block__0__Libplanet_Blocks_Block__0__Libplanet_Blocks_Block__0__">&lt;code>IRenderer&amp;lt;T&amp;gt;.RenderReorg()&lt;/code>&lt;/a>
메서드를 통해 리오그&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>가 일어난 것을 감지할 수 있게 되었습니다. 렌더링 코드가 액션과 분리되어 렌더러라는 독립적인 단위가 된 덕에,
데코레이터 패턴을 통한 미들웨어 구조가 가능해졌습니다. 그 예로, 새 버전부터 제공되는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.LoggedRenderer-1.html">&lt;code>LoggedRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 클래스는
다른 &lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code> 구현을 감싸 어떤 렌더링 이벤트가 어떤 시점에 발생했는지를 로그로 남겨줍니다. 디버그할 때는
게임 렌더러를 &lt;code>LoggedRenderer&amp;lt;T&amp;gt;&lt;/code>로 감싸서 실행하고, 실제 프로덕션에서는 감싸지 않고 게임 렌더러만을 쓰게 하는 식으로 활용 가능합니다.&lt;/p>
&lt;h2 id="지연-렌더러">지연 렌더러&lt;/h2>
&lt;p>Libplanet은 현재 종국성(finality)이 없는 작업 증명(PoW) 방식을 쓰고 있어, 최근 블록들은 리오그가 일어나기 쉽습니다.
이 때문에 여러 암호화폐 지갑이나 거래소에서도 트랜잭션의 컨펌 수(number of confirmations) 표시를 흔히 접할 수 있습니다.
컨펌 수가 높을 수록 리오그가 일어날 개연성이 떨어지기 때문입니다. 게임 내 행동의 결과가 리오그로 인해 너무 자주 변동될 경우 너무 혼란스러우므로,
이를 완화하기 위해 지연 렌더러가 추가됐습니다. &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.DelayedRenderer-1.html">&lt;code>DelayedRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a>는 &lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code>를 입력으로 받으며 그 스스로도 &lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code>를 구현하는 데코레이터로,
이름처럼 렌더링 이벤트를 다소 지연시키는 미들웨어입니다. 블록체인에 새 블록이 쌓여도 바로 관련된 이벤트를 발생시키는 대신, 잠시 기다린 뒤 설정한 컨펌 수를 만족하게 되는 순간 이벤트를 발생시킵니다.
&lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>에서도 지연 렌더러를 쓰고 있으며, 컨펌 수는 플레이어가 설정 가능하게 옵션으로 제공하고 있습니다.&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="정적-분석기">&lt;a href="https://github.com/planetarium/libplanet/tree/main/Libplanet.Analyzers">정적 분석기&lt;/a>&lt;/h2>
&lt;p>Libplanet에서 모든 블록체인 내 상태는 액션을 통해서만 변경될 수 있습니다. 이 액션은 각 노드마다 각자 실행하여 이전 상태로부터 새 상태를 도출하는데,
따라서 블록체인 네트워크의 모든 노드가 일관된 상태를 합의하려면, 액션은 반드시 결정적(deterministic)이어야 합니다.
그러나 아무리 어떠한 요소가 코드를 비결정적으로 만드는지 알고 있다고 하더라도, 복잡한 로직을 결정적으로 짜는 것은 쉽지 않습니다.
알고도 실수할 수 있고, 여러 사람들이 함께 만지다보면 각자 수정한 부분은 결정적으로 보여도 다 합쳐놓고 보니 비결정적으로 되기도 쉽습니다.&lt;/p>
&lt;p>이러한 실수를 완화하기 위해, 새 버전부터는 Libplanet 액션 코드의 실수를 정적 분석으로 체크하는 &lt;a href="https://www.nuget.org/packages/Libplanet.Analyzers">Libplanet.Analyzers 패키지&lt;/a>가 도입되었습니다.
이 정적 분석기는 저희가 실제로 나인 크로니클을 개발하면서 반복적으로 만났던 실수들을 토대로 흔한 잠재적 버그들을 미리 경고해 줍니다.
사용법은 아주 쉬운데, NuGet 패키지 의존성으로 추가하기만 하면 빌드할 때 C# 컴파일러 오류와 함께 경고로 출력됩니다.&lt;/p>
&lt;p>다만, 아직 초기 버전이기 때문에, 아직 체크의 수가 다양하지 않고, 또 사람이 보기에는 명백하게 바른 코드인데도 잠재적 버그로 경고하는 경우가 여전히 많습니다.
이러한 부분들은 추후 버전에서 점진적으로 개선될 예정입니다.&lt;/p>
&lt;h2 id="블록당-바이트-사이즈-및-트랜잭션-수-제한">블록당 바이트 사이즈 및 트랜잭션 수 제한&lt;/h2>
&lt;p>이제까지 Libplanet은 한 블록의 용량이 아무리 크거나 트랜잭션이 아무리 많이 들어가도 이를 제한하지 않았습니다.
그렇지만 이러한 제한이 없을 경우 악의적 공격에 노출되기 쉽고, 아무도 악의적이지 않더라도 너무 많은 트랜잭션을 한 블록에 담으려다 보니
레이턴시가 지나치게 떨어지는 현상이 왕왕 발생했습니다.&lt;/p>
&lt;p>이를 완화하기 위해, 새 버전에서는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html">&lt;code>IBlockPolicy&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 인터페이스에서 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_GetMaxBlockBytes_System_Int64_">&lt;code>GetMaxBlockBytes()&lt;/code>&lt;/a> 메서드 및 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_MaxTransactionsPerBlock">&lt;code>MaxTransactionsPerBlock&lt;/code>&lt;/a> 속성을 통해
블럭 하나에 최대 몇 바이트까지 차지할 수 있는지, 그리고 한 블럭에 최대 몇 개의 트랜잭션까지 수용할 수 있는지를 네트워크 단위로 설정 가능하게 됐습니다.
마이너는 블록을 만들 때 설정된 수를 초과하지 않는 선에서 알아서 트랜잭션들을 나눠 담게 되며, 악의적인 노드가 네트워크 설정을 초과하는 블록을
만들어서 전파하더라도 다른 노드들은 이 블록을 무효한 것으로 보게 됩니다.&lt;/p>
&lt;p>네트워크나 애플리케이션에 따라 최적 설정이 달라질 수 있으므로, 설정 수치는 개발 단계에서 시범 네트워크를 운영해보며 조정하는 것이
바람직합니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 외에도 여러 성능 개선이나 자잘한 마이너 패치가 있었습니다. 자세한 내용은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.10.0">전체 변경 내용&lt;/a> 에서 확인해 주세요.&lt;/p>
&lt;p>질문이나 관심이 있으신 분들은 또한 저희 &lt;a href="https://discord.gg/planetarium">Discord&lt;/a> 채널에 놀러와 주세요!&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Java와 달리 C#에는 익명 클래스가 없습니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>리오그에 관해서는 김무훈 님의 지난 스낵 글 &lt;a href="https://snack.planetarium.dev/kor/2020/10/decentralized-and-online-game-intersect/">〈탈중앙과 온라인 게임이 교차하다〉&lt;/a>를 참고하세요.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>현재 UI로 설정 가능하지는 않지만, 설정 파일을 직접 고칠 수 있습니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>탈중앙과 온라인 게임이 교차하다</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/10/decentralized-and-online-game-intersect/" title="탈중앙과 온라인 게임이 교차하다"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/10/decentralized-and-online-game-intersect/" hreflang="" title="Decentralization Intersects with Online Game"/><id>https://snack.planetarium.dev/kor/2020/10/decentralized-and-online-game-intersect/</id><published>2020-10-08T00:00:00+00:00</published><updated>2020-10-08T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요! 지난 2개월 간 플라네타리움의 엔지니어링 인턴으로 일한 김무훈입니다. 저는 &lt;a href="https://nine-chronicles.com">나인 크로니클&lt;/a> 출시 직전의 베타 과정을 함께했는데요.&lt;/p>
&lt;p>간단히 블록체인과 게임을 결합하며 특이하다고 생각한 기술적인 사례를 소개하겠습니다.&lt;/p>
&lt;h2 id="탈중앙">탈중앙&lt;/h2>
&lt;p>온라인 게임은 멀티 플레이와 사용자의 데이터를 저장하는 등 서비스를 운영하기 위한 용도로 서버를 이용합니다. 그러나 운영사가 폐업하는 등 여러 이유로 서비스가 중단되면 더 이상 게임을 즐길 수 없게 됩니다.&lt;/p>
&lt;p>모두가 온라인 게임을 분업하여 유지할 수 있다면 사용자가 남아있는 한 서비스가 종료될 걱정은 없게 됩니다. 이 개념에 맞는 탈중앙은 전통적인 중앙 서버의 역할을 사용자에게 분담해두는 형태를 의미하는데요. 기술적으로는 &lt;abbr title="Peer to peer">P2P&lt;/abbr>나, 분산화 기술이라고 아마 한 번쯤은 들어 보셨을 겁니다.&lt;/p>
&lt;h2 id="재구성-현상">재구성 현상&lt;/h2>
&lt;p>플라네타리움은 여러 분산화 기술 중에 블록체인을 활용해서 게임 내 재화, 보유한 아이템, 달성한 퀘스트 등의 데이터를 보존합니다.&lt;/p>
&lt;p>블록체인에 게임 플레이 데이터를 보관하면 간혹 이 정보가 몇시간 전으로 되돌아가는 문제가 있습니다. 블록체인 네트워크에서 일어나는 &lt;dfn>재구성 현상&lt;/dfn>이라는 결함인데요.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 블록체인 커뮤니티에서는 이를 &lt;dfn>리오그&lt;/dfn>(&lt;abbr title="reorganization">reorg&lt;/abbr>)라 줄여서 부릅니다. 이 글에서도 편의상 리오그라 칭하겠습니다.&lt;/p>
&lt;figure>&lt;img src="images/single-chain.png"
alt="블록이 순서대로 연결되어 있는 것을 체인이라 한다."/>&lt;figcaption>
&lt;p>블록이 순서대로 연결되어 있는 것을 체인이라 한다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>리오그 현상에 대해 설명하기 전에 블록체인 네트워크에는 언제나 하나의 체인을 정본으로 지목한다는 사실부터 짚고 넘어가야 합니다.&lt;/p>
&lt;p>블록체인의 블록은 누구나 생성할 수 있습니다. 그러나 블록을 생성하는 여러 노드가&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 같은 시점에 블록을 동시에 만든다면 시작은 같은데 끝 부분이 서로 다른 여러 체인이 나타납니다. 어떻게 하면 하나의 체인을 정본으로 지목할 수 있는 것일까요? 중앙의 누군가가 정해주는 것도 아닌데도 말입니다.&lt;/p>
&lt;figure>&lt;img src="images/orphaned-block.png"
alt="비슷한 시점에 더 많은 자원이 투입된 체인을 채택한다."/>&lt;figcaption>
&lt;p>비슷한 시점에 더 많은 자원이 투입된 체인을 채택한다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>각 노드가 제멋대로 체인을 고르지는 않고, 모든 노드가 공유한 규칙에 따라 가장 규칙에 적합한 체인을 고릅니다. 나인 크로니클 및 Libplanet이 따르고 있는 작업 증명(&lt;abbr title="proof-of-work">PoW&lt;/abbr>) 방식에서는 비슷한 시점에 블록을 생성하는데 더 많은 자원이 투자된 체인을 채택합니다.&lt;/p>
&lt;figure>&lt;img src="images/orphaned-blocks.png"
alt="5개의 길이를 가졌던 파란 블록의 체인이 빨간 블록으로 리오그된다. (깊은 리오그)"/>&lt;figcaption>
&lt;p>5개의 길이를 가졌던 파란 블록의 체인이 빨간 블록으로 리오그된다. (깊은 리오그)&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>그런데 기존의 주류 체인보다도 이 규칙에 더 부합하는 다른 체인이 네트워크에 나타날 경우, 이 순간 주류 블록체인이 뒤집히게 됩니다.&lt;/p>
&lt;p>보통의 경우 블록 한두 개를 두고 &lt;dfn>얕은 리오그&lt;/dfn>가 일어나지만 나누어진 블록의 깊이가 일정 개수보다 많다면 &lt;dfn>깊은 리오그&lt;/dfn>가 일어납니다. 예를 들어,&lt;/p>
&lt;ol>
&lt;li>A, B 분기로 체인이 나뉘어져 다른 노드로 전파된다.&lt;/li>
&lt;li>비슷한 비율로 점차 전파되는 노드가 늘어가며 체인의 길이도 늘어간다.&lt;/li>
&lt;li>모든 노드가 A 분기와 B 분기 중 하나를 채택했고, A 분기의 체인이 더 길면서 채택된 비율이 높다.&lt;/li>
&lt;li>B 분기의 체인을 채택한 모든 노드의 체인이 A로 리오그 됩니다.&lt;/li>
&lt;/ol>
&lt;style>
@media screen and (min-width: 70em) {
img[src="images/bug-report.png"] {
width: 60%
}
}
&lt;/style>
&lt;figure>&lt;img src="images/bug-report.png"
alt="어제 10,000 골드를 보유했던 사용자가 1,000 미만의 골드를 보유하게 되었다고 제보를 했다."/>&lt;figcaption>
&lt;p>어제 10,000 골드를 보유했던 사용자가 1,000 미만의 골드를 보유하게 되었다고 제보를 했다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>그래서 앞서 이야기했듯이, 리오그 현상 때문에 레벨이나 가진 아이템이 몇 분에서 몇 시간 전의 상태로 되돌아갔다는 이야기가 나인 크로니클 커뮤니티에서 자주 언급되었습니다.&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> 탈중앙 네트워크에서 발생한 일이기 때문에 운영진에게 되돌려달라고 할 수도 없는 노릇입니다.&lt;/p>
&lt;h2 id="블록체인-네트워크-초기화">블록체인 네트워크 초기화&lt;/h2>
&lt;p>나인 크로니클은 베타 기간 동안 체인 네트워크를 일곱 번 초기화했습니다. 체인 네트워크가 초기화되면 게임 플레이어가 일구었던 게임 데이터가 모두 사라지게 됩니다. 이런 위험을 감수하고도 초기화를 감행한 이유는 다음과 같습니다.&lt;/p>
&lt;p>블록체인 네트워크 코어 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>에서는 게임의 상태를 블록에 저장합니다. 사용자의 행동은 경우 &lt;a href="https://docs.libplanet.io/0.9.5/api/Libplanet.Action.IAction.html">액션&lt;/a>이라는 이름의 자료 구조에 맞추어 저장됩니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;stageId&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;123&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;ntPSdIREOUOARaRYJHlGEg==&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;equipments&amp;#34;&lt;/span>: [&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;KTm6cLkrtEWs6k4A821K3Q==&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;avatarAddress&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;sGo0bo0VwrYA7ubq6yV8ctiU2vc=&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;foods&amp;#34;&lt;/span>: [],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#b06;font-weight:bold">&amp;#34;worldId&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>만약 게임 내에서 의상 요소가 업데이트된다면 &lt;code>costumes&lt;/code> 같이 새로운 속성이 추가되고, 이 정보가 담긴 블록의 해시가&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> 이전 블록의 해시를 만드는 규약(protocol)과 맞지 않게 됩니다. 규약이 달라지면 이전의 블록 데이터를 이어서 사용할 수 없게 됩니다.&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> 이 외에도 유니크한 값이 다르게 되거나, Libplanet이나 그 SDK의 코드 중에 해시에 영향이 가는 수정이 생긴다면 달라집니다.&lt;/p>
&lt;p>이런 경우의 대개 다른 블록체인에서는 몇 번째 블록 이후부터 블록을 다르게 해석하도록 규약을 추가합니다. 나인 크로니클도 그럴 수 있지만, 크고 작은 변경이 잦은 베타 기간에 이런 방법을 취하는 것은 무리라고 판단했습니다. 그래서 체인을 매번 초기화하는 것을 감행한 것입니다.&lt;/p>
&lt;p>정식 출시 이후에는 체인을 유지할 예정입니다. 그러기 위한 여러 제안이 검토된 상황으로, 기회가 된다면 이후에 스낵에서 이를 소개하겠습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>플라네타리움은 &amp;ldquo;커뮤니티가 운영하는 온라인 게임&amp;quot;이라는 매력으로 새로운 형태의 게임 문화를 정착시키는 것에 큰 기대를 하고 있습니다. 간혹 온라인 게임의 운영사 직원이 게임의 자원을 횡령하여 게임의 생태계를 무너뜨리는 일이 언론에 보도되는데요. 나인 크로니클은 게임의 규칙이 프로토콜 수준으로 투명해져서 그런 일이 원칙적으로 일어날 수 없습니다.&lt;/p>
&lt;p>이러한 장점에도 불구하고 Libplanet이 사용하는 블록체인 프로토콜이 진입 장벽으로 느껴질 수 있습니다. 작업 내역을 라인 단위로 분산하고 자동으로 병합이 되는 Git을 처음 보고 느낀 충격이랄까요. 그래서 여러분이 게임을 플레이하면 겪는 아쉬움, 개선점을 &lt;a href="https://discord.gg/planetarium">디스코드 채널&lt;/a>과 GitHub&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>에서 받고 있습니다.&lt;/p>
&lt;p>이 글은 앞으로 시리즈로 연재되며, 다음 발행 때에는 나인 크로니클이 리오그 현상과 체인 리셋을 어떻게 대처하였는지 소개하는 시간을 가질 예정입니다. 읽어주셔서 감사합니다.&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>엔지니어링 팀 내부에서는 플레이했던 기록이 꿈처럼 되어 버린다고 해서 &lt;dfn>신기루&lt;/dfn> 현상으로 부릅니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>블록체인 네트워크에 참여하는 컴퓨터를 의미합니다.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>블록체인 코리빙·코워킹 커뮤니티 논스(nonce) 공동 창립자 하시은 님이 쓴 &lt;a href="https://www.facebook.com/unseenone.flohsdpsyphle/posts/1027765500973348">게임 후기&lt;/a>에서 사용자 입장의 상황이 잘 설명되었습니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>블록체인은 그 이전 블록의 해시를 메타 정보 삼아 체인을 이읍니다. 연결 리스트를 떠오르면 이해하기 쉽습니다.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>확장한 명세가 들어간 게임 클라이언트가 이전 블록을 제대로 해석하지 못할 가능성이 있습니다.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>P2P 온라인 게임을 위한 블록체인 코어 — &lt;a href="https://github.com/planetarium/libplanet">libplanet&lt;/a>, 나인 크로니클을 위한 Libplanet 기반의 SDK — &lt;a href="https://github.com/planetarium/lib9c">Lib9c&lt;/a>, 나인 크로니클 클라이언트 전용의 블록체인 노드 서비스 — &lt;a href="https://github.com/planetarium/ninechronicles.standalone">NineChronicles.Standalone&lt;/a>, 이 밖에도 나인 크로니클 론처와 게임 클라이언트의 저장소를 공개할 예정입니다.&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></content><author><name>김무훈</name><uri>https://github.com/x86chi</uri><email>iam@muhun.kim</email></author></entry></feed>