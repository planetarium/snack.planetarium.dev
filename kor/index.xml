<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><title>플라네타리움 엔지니어링 스낵</title><link rel="self" href="https://snack.planetarium.dev/kor/index.xml"/><link rel="alternate" href="https://snack.planetarium.dev/kor/" title="플라네타리움 엔지니어링 스낵"/><link rel="alternate" href="https://snack.planetarium.dev/eng/" hreflang="en" title="Planetarium Engineering Snack"/><updated>2021-10-29T00:00:00+00:00</updated><id>https://snack.planetarium.dev/kor/</id><entry><title>Libplanet 0.11–0.19 업데이트 요약</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2021/10/libplanet-0.11-0.19/" title="Libplanet 0.11–0.19 업데이트 요약"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2021/10/libplanet-0.11-0.19/" hreflang="en" title="What's new in Libplanet 0.11–0.19"/><id>https://snack.planetarium.dev/kor/2021/10/libplanet-0.11-0.19/</id><published>2021-10-29T00:00:00+00:00</published><updated>2021-10-29T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 오랜만에 소식 전합니다. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>은 지난 몇 달 동안, 여러
마이너 버전을 릴리스했습니다. 그렇지만 저희의 릴리스 정책과 주기가 바뀜에 따라,
그리고 Libplanet으로 만들어진 첫 게임 〈&lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>〉 메인넷의 여러 문제들에
대응하느라 차분히 그간의 업데이트를 정리된 글로 쓸 여유가 없었습니다.
그래서 이번 글에서 그 사이의 변화 중 큰 것들을 중심으로 소개해 볼까 합니다.&lt;/p>
&lt;h2 id="달라진-릴리스-주기">달라진 릴리스 주기&lt;/h2>
&lt;p>이전까지 Libplanet은 릴리스 주기에 뚜렷한 규칙이 없었습니다. 주로 큰 API 변경이
있거나 마지막 릴리스 이후로 시간이 많이 지났을 때 그 동안의 변경을 모아서 새
버전 번호를 부여하는 것에 가까웠습니다.&lt;/p>
&lt;p>그러나 지난해 〈&lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>〉 메인넷 (이하 &lt;q>메인넷&lt;/q>) 출범 이후,
메인넷의 크고 작은 문제들을 해결해 나가기 위해 Libplanet도 그에 발맞춘 잦은
릴리스가 이뤄져야 했습니다. 현재 플라네타리움의 Libplanet 팀과 〈나인 크로니클〉
팀은 긴밀히 협력하며 릴리스 주기를 맞추고 있습니다. 이러한 기조는 한동안 바뀌지
않을 것으로 보입니다.&lt;/p>
&lt;p>그러한 방침 아래, 지난 몇 달 동안 릴리스된 Libplanet 버전으로는 올해 3월에 나온
0.11.0부터 금주에 나온 0.19.0까지 총 9번의 마이너 업데이트가 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.11.0">0.11.0&lt;/a> (3월 30일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.12.0">0.12.0&lt;/a> (7월 23일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.13.0">0.13.0&lt;/a> (7월 28일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.14.0">0.14.0&lt;/a> (8월 5일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.15.0">0.15.0&lt;/a> (8월 18일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.16.0">0.16.0&lt;/a> (8월 25일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.17.0">0.17.0&lt;/a> (9월 28일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.18.0">0.18.0&lt;/a> (10월 13일)&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.19.0">0.19.0&lt;/a> (10월 27일)&lt;/li>
&lt;/ul>
&lt;h2 id="프로토콜-버전">프로토콜 버전&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.11.0">0.11.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>프로토콜 버전은 블록에 붙는 속성으로, 해당 블록이 어떤 Libplanet 버전을 써서
마이닝됐는지 기록합니다. 프로토콜 버전은 Libplanet을 이용해 만들어진 게임이
Libplanet 버전을 쉽게 업그레이드할 수 있도록 도우며, 한편으로는 Libplanet 쪽에서
기존의 네트워크를 유지하면서도 기능을 추가할 수 있게 합니다.&lt;/p>
&lt;p>API 측면에서는 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_ProtocolVersion">&lt;code>Block&amp;lt;T&amp;gt;.ProtocolVersion&lt;/code> 속성&lt;/a>으로
확인할 수 있으며, 32비트 정수형으로 표현됩니다. 표현되는 프로토콜 버전은
Libplanet의 패키지 버전과는 별개의 네트워크 프로토콜의 버전인데, 패키지 버전의
패치 릴리스는 프로토콜 버전이 올라갈 수 없고 반드시 마이너 및 메이저 릴리스할
때만 프로토콜 버전도 함께 증가됩니다.&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.19.0">0.19.0&lt;/a> 버전 현재 프로토콜 버전은 2이고, 프로토콜 버전이 도입된 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.11.0">0.11.0&lt;/a> 버전
미만에서 생성된 블록은 모두 프로토콜 버전 0으로 취급됩니다.&lt;/p>
&lt;h2 id="네트워크-트랜스포트-레이어">네트워크 트랜스포트 레이어&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.11.0">0.11.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>오랫동안 Libplanet은 네트워크 통신에 있어 많은 저수준 처리를 &lt;a href="https://zeromq.org/">ZeroMQ&lt;/a>의
.NET 구현인 &lt;a href="https://github.com/zeromq/netmq">NetMQ&lt;/a>에 맡겨 왔습니다. 하지만 모바일이나 웹 등 여러 플랫폼에서도
Libplanet을 쓸 수 있도록, NetMQ에 의존하지 않고도 네트워크 통신이 가능하게
바뀔 필요가 있었습니다.&lt;/p>
&lt;p>네트워크 트랜스포트 레이어는 저수준 통신 방식을 다양화하고, 특수한 요구사항이
있을 경우 게임 개발자도 직접 저수준 통신 방식을 정의하여 쓸 수 있도록 추가된
실험적인 추상화 계층입니다.&lt;/p>
&lt;p>API 측면에서는 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Net.Transports.ITransport.html">&lt;code>ITransport&lt;/code> 인터페이스&lt;/a>로 표현되며, 이를 구현한
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Net.Transports.NetMQTransport.html">&lt;code>NetMQTransport&lt;/code> 클래스&lt;/a>가 기본 제공됩니다.&lt;/p>
&lt;p>시범 단계이기에 인터페이스는 현재 여러 마이너 릴리스에 걸쳐 조정되고 있으며,
아직 게임 개발자가 직접 정의한 트랜스포트 구현을 사용할 수는 없습니다.
연내에는 &lt;code>NetMQTransport&lt;/code>를 대체할 &lt;a href="https://github.com/planetarium/libplanet/pull/1523">새로운 TCP 기반 트랜스포트&lt;/a>
구현과 함께 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Net.Swarm-1.html">&lt;code>Swarm&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 객체가 사용자 정의 트랜스포트를 쓰도록 설정
가능해질 예정입니다.&lt;/p>
&lt;h2 id="교체-가능한-작업-증명-해시-알고리즘">교체 가능한 작업 증명 해시 알고리즘&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.12.0">0.12.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>이전까지 Libplanet은 작업 증명에 &lt;a href="https://ko.wikipedia.org/wiki/SHA-2">SHA-256&lt;/a> 해시 알고리즘을 써 왔습니다.
그러나 0.12.0 버전부터는 네트워크마다 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_GetHashAlgorithm_System_Int64_">&lt;code>IBlockPolicy&amp;lt;T&amp;gt;.GetHashAlgorithm()&lt;/code>
메서드&lt;/a>를 정의하여 해시 알고리즘을 선택할
수 있게 됐습니다. 네트워크마다 다르게 할 수 있을 뿐만 아니라 블록 인덱스에
따라 다른 해시 알고리즘을 쓸 수도 있기 때문에, 네트워크 출범 이후에도 다른 해시
알고리즘으로 쉽게 이행할 수 있습니다.&lt;/p>
&lt;p>.NET 런타임에 정의된 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.security.cryptography.hashalgorithm">&lt;code>HashAlgorithm&lt;/code> 추상 클래스&lt;/a>의
서브클래스라면 모두 해시 알고리즘으로 사용할 수 있습니다. 서브클래스는 꼭
.NET 런타임에서 제공하는 것으로 국한되지 않으며, 사용자가 직접 상속 받아
구현하거나 NuGet 등으로 제공되는 서드파티 라이브러리에서 정의한 것도
쓸 수 있습니다. 이를테면 플라네타리움에서 직접 만든 RandomX의 .NET 바인딩
라이브러리인 &lt;a href="https://github.com/planetarium/RandomXSharp">RandomXSharp&lt;/a> 역시 &lt;code>HashAlgorithm&lt;/code>의 서브클래스를 제공합니다.&lt;/p>
&lt;p>다음 코드는 1만번째 블록까지는 SHA-256을 쓰고 그 뒤부터는 SHA-512를 쓰도록
블록체인 정책을 설정하는 예입니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-csharp" data-lang="csharp">HashAlgorithmType GetHashAlgorithm(&lt;span style="color:#888;font-weight:bold">long&lt;/span> index) =&amp;gt;
index &amp;lt;= &lt;span style="color:#00d;font-weight:bold">10_000&lt;/span>
? HashAlgorithmType.Of&amp;lt;SHA256&amp;gt;()
: HashAlgorithmType.Of&amp;lt;SHA512&amp;gt;();
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="논블로킹-렌더러">논블로킹 렌더러&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.14.0">0.14.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>노드의 로컬 블록체인의 상태가 변화를 이벤트로 수신할 수 있는
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Renderers.IRenderer-1.html">&lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 및 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Renderers.IActionRenderer-1.html">&lt;code>IActionRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a>
인터페이스는 별도의 스레드를 만들지 않는 대신 렌더링 로직이 블로킹으로
동작합니다. 이를테면, 렌더링 로직이 &lt;code>Thread.Sleep(60_000)&lt;/code>을 호출한다면
블록체인의 다음 상태 변화는 60초의 렌더링을 기다린 뒤에 이뤄진다는 것입니다.&lt;/p>
&lt;p>0.14.0 버전부터는 시간이 소요되는 렌더링 로직을 별도 스레드에서 논블로킹
방식으로 실행할 수 있게 해주는 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Renderers.NonblockRenderer-1.html">&lt;code>NonblockRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 및
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Renderers.NonblockActionRenderer-1.html">&lt;code>NonblockActionRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 데코레이터 클래스가
도입됐습니다. 두 클래스는 생성자에서 다른 렌더러를 인자로 받아, 해당 렌더러의
이벤트 핸들러를 별도 스레드에서 호출합니다. 따라서 기존의 렌더러 구현을 한 번
감싸는 것만으로 논블로킹 방식으로 전환할 수 있습니다.&lt;/p>
&lt;p>논블로킹 방식이지만 내부적으로는 대기열이 존재하며, 따라서 이벤트의 순서는
보장됩니다.&lt;/p>
&lt;h2 id="마이너가-설정-가능한-트랜잭션-선호-함수">마이너가 설정 가능한 트랜잭션 선호 함수&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.17.0">0.17.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>마이닝할 블록에 포함할 트랜잭션들은 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_ValidateNextBlockTx_Libplanet_Blockchain_BlockChain__0__Libplanet_Tx_Transaction__0__">&lt;code>IBlockPolicy&amp;lt;T&amp;gt;.ValidateNextBlockTx()&lt;/code>
서술 메서드&lt;/a>를 만족하기만 한다면,
프로토콜에서 정해진 우선순위는 없습니다.&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> 그렇지만 아직 블록에 포함되지 않는
트랜잭션이 너무 많을 때는 한 블록에 너무 많은 트랜잭션을 다 넣을 수 없기 때문에,
어떤 트랜잭션을 이번 블록에 포함시키고 어떤 트랜잭션을 나중 블록으로 미룰지 줄을
세워야 합니다.&lt;/p>
&lt;p>0.17.0 버전부터는 어떤 트랜잭션부터 블록에 넣을지 그 기준을 Libplanet이 임의로
정하는 대신 마이너가 정할 수 있게 됐습니다. API 측면에서는
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1_MineBlock_Libplanet_Crypto_PrivateKey_DateTimeOffset_System_Boolean_System_Int32_System_Int32_IComparer_Libplanet_Tx_Transaction__0___CancellationToken_">&lt;code>BlockChain&amp;lt;T&amp;gt;.MineBlock()&lt;/code> 메서드&lt;/a>에
&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.icomparer-1">&lt;code>IComparer&amp;lt;Transaction&amp;lt;T&amp;gt;&amp;gt;&lt;/code> 타입&lt;/a>의 옵션 &lt;code>txPriority&lt;/code>가
생겼습니다.&lt;/p>
&lt;h2 id="블록-서명">블록 서명&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.18.0">0.18.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>프로토콜 버전 2, Libplanet 버전 0.18.0부터 블록은 마이너의 비밀 키로 서명되며
블록에는 마이너의 주소 뿐만 아니라 공개 키가 포함됩니다.&lt;/p>
&lt;p>API 측면에서는, 블록의 서명은 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_Signature">&lt;code>Block&amp;lt;T&amp;gt;.Signature&lt;/code> 속성&lt;/a>에
담기고 마이너의 공개 키는 &lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_PublicKey">&lt;code>Block&amp;lt;T&amp;gt;.PublicKey&lt;/code> 속성&lt;/a>에
담기게 됩니다. 프로토콜 버전 1 및 0의 블록에서는 두 속성이 모두 &lt;code>null&lt;/code>로
비어 있습니다.&lt;/p>
&lt;h2 id="병렬-프로세스-마이닝">병렬 프로세스 마이닝&lt;/h2>
&lt;p>&lt;em>&lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.19.0">0.19.0&lt;/a> 버전에서 추가됨.&lt;/em>&lt;/p>
&lt;p>Libplanet 0.19.0 버전부터는 블록 마이닝이 자동으로 해당 기기의 프로세서 코어
수에 따라 병렬로 수행됩니다. 마이너가 직접 활용할 프로세스 수를 조절하는
옵션은 추후 버전에서 추가될 예정입니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 외에도 수많은 기능이 더해졌을 뿐만 아니라, 몇 달 동안의 메인넷 운영에서
발생한 문제를 해결하며 많은 영역에서 크게 안정화 됐습니다. 자세한 내용은
각 버전의 &lt;a href="https://github.com/planetarium/libplanet/blob/0.19.0/CHANGES.md">전체 변경 내역&lt;/a>에서 확인해 주세요.&lt;/p>
&lt;p>호기심이 생기신 분들은 설치해서 이용해 보시고, 궁금한 점이 있으시다면 저희 팀이
상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드&lt;/a>에도 놀러오세요!&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>모든 메이저 및 마이너 릴리스가 프로토콜 버전을 증가시키는 것은 아닙니다.
사실, 대부분의 릴리스는 프로토콜 버전을 증가시키지 않습니다.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>물론 같은 서명자의 트랜잭션들 사이에는
&lt;a href="https://docs.libplanet.io/0.19.0/api/Libplanet.Tx.Transaction-1.html#Libplanet_Tx_Transaction_1_Nonce">&lt;code>Transaction&amp;lt;T&amp;gt;.Nonce&lt;/code>&lt;/a>를 기준으로 정해지는 순서가
있습니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.10 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/12/libplanet-0.10/" title="Libplanet 0.10 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/12/libplanet-0.10/" hreflang="en" title="Libplanet 0.10 Released"/><id>https://snack.planetarium.dev/kor/2020/12/libplanet-0.10/</id><published>2020-12-08T00:00:00+00:00</published><updated>2020-12-08T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 열 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.10.0">0.10 버전&lt;/a>이
릴리스되었습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&lt;/p>
&lt;p>이번 버전부터 Libplanet은 상태를 관리하기 위해 &lt;a href="https://eth.wiki/en/fundamentals/patricia-tree">&lt;abbr title="Merkle–Patricia Trie">MPT&lt;/abbr>&lt;/a>를
사용하고, 자산 관리를 위한 별도의 API가 추가되는 등, 여기서 소개하는 내용 이외에도
인터페이스 내외로 많은 변경점이 있었습니다.&lt;/p>
&lt;p>이 글에서는 0.10 버전의 주요 변경 사항들에 대해서 다루겠습니다.&lt;/p>
&lt;h2 id="결과-상태를-포함하여-유도된-blockthash">결과 상태를 포함하여 유도된 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_Hash">&lt;code>Block&amp;lt;T&amp;gt;.Hash&lt;/code>&lt;/a>&lt;/h2>
&lt;p>그동안 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html">&lt;code>Block&amp;lt;T&amp;gt;&lt;/code>&lt;/a>은 해당 블록이 가지고 있는 상태에 대한 정보를 따로 들고 있지 않았습니다.
따라서 블록에서 상태를 유도할 수는 있어도, 블록에서 상태의 정합성 등을 검증할 수 있는 방법은
오직 액션을 직접 실행하는 방법 뿐이었습니다. 하지만 이제 &lt;code>Block&amp;lt;T&amp;gt;.Hash&lt;/code> 는 해당 블록에 대한 정보 뿐만 아니라,
블록 내 액션을 평가하고 나온 결과의 해시값인 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_StateRootHash">&lt;code>Block&amp;lt;T&amp;gt;.StateRootHash&lt;/code>&lt;/a>도 포함되어 유도됩니다. 이전과 같이 액션을 평가하지 않고 블록 정보만을 가진
해시는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_PreEvaluationHash">&lt;code>Block&amp;lt;T&amp;gt;.PreEvaluationHash&lt;/code>&lt;/a> 속성에 들어갑니다.&lt;/p>
&lt;h2 id="blockttotaldifficulty">&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_TotalDifficulty">&lt;code>Block&amp;lt;T&amp;gt;.TotalDifficulty&lt;/code>&lt;/a>&lt;/h2>
&lt;p>그동안은 블록체인의 정본 체인(canonical chain)의 선출 기준에는 블록 높이(&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_Index">&lt;code>Block&amp;lt;T&amp;gt;.Index&lt;/code>&lt;/a>)만 고려되었습니다.
하지만 네트워크에 같은 높이의 블록이 비슷한 속도로 여럿 나오는 경우는 흔하기에, 합의가 지역적으로만 이뤄지는 경우가 잦았습니다.
같은 높이라면 어떤 블록을 선택해도 괜찮으니, 선택지가 많아 모호성이 생기기 때문입니다.
이 문제를 바로잡기 위해, 새 버전부터는 사실상 선택지가 언제나 하나가 되도록 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_TotalDifficulty">&lt;code>Block&amp;lt;T&amp;gt;.TotalDifficulty&lt;/code>&lt;/a> 속성을 추가하고, 이 속성을 정본의 기준으로 삼게 되었습니다.
&lt;code>Block&amp;lt;T&amp;gt;.TotalDifficulty&lt;/code> 속성은 해당 블록에서부터 제너시스 블록에 이르는 모든 블록(자기 자신과 제너시스 포함)의 난이도(&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blocks.Block-1.html#Libplanet_Blocks_Block_1_Difficulty">&lt;code>Block&amp;lt;T&amp;gt;.Difficulty&lt;/code>&lt;/a>)의 합입니다.
따라서 단순히 난이도가 낮은 블록을 빨리 찍어서 블록을 높게 쌓는 것만으로 정본을 취할 수 없기에 보안 측면에서도 향상됐습니다.&lt;/p>
&lt;h2 id="abbr-titlemerklepatricia-triemptabbr">&lt;abbr title="Merkle–Patricia Trie">MPT&lt;/abbr>&lt;/h2>
&lt;p>&lt;abbr title="Merkle–Patricia Trie">MPT&lt;/abbr>는 이더리움 등에서 상태를 저장하는 데에 사용되는 트라이(trie) 자료 구조입니다.
기존에는 상태를 저장하는 데 블록 단위로 전역 상태의 변량을 보존하고 상태 참조라는 색인을 통해
조회하는 방식을 사용했었는데, 이 방식은 오랫동안 갱신되지 않은 상태를 조회할 때
시간이 많이 걸리는 문제가 있었습니다. 이제는 MPT 구조를 통해 훨씬 빠르게 상태를 조회할 수 있게 하였습니다.&lt;/p>
&lt;p>또한 디버깅을 돕기 위해 새로 추가된 &lt;code>planet mpt&lt;/code> 명령어로 블록 간 상태를
비교하거나, 특정 블록에서의 상태를 손쉽게 가져올 수 있게 되었습니다. 사용법은 &lt;code>planet mpt --help&lt;/code> 옵션을
참고해 주십시오.&lt;/p>
&lt;h2 id="자산을-위한-별도-상태-api">자산을 위한 별도 상태 API&lt;/h2>
&lt;p>이제까지 Libplanet으로 게임을 만들 때 게임 내 재화는 다른 게임 내 상태와 같은 방식으로 다뤄졌습니다.
이를테면 NCG(〈나인 크로니클〉 골드)는 정수 자료형의 값으로 구현되었습니다. 그러나 그러한 재화는
복제되거나 함부로 소멸되어서는 안 되는데, 사칙연산이 자유롭고 재화 특유의 성질을 내제하고 있지 않은
정수 자료형으로 재화를 구현하다 보면 버그가 끼어들기 쉬웠습니다.&lt;/p>
&lt;p>예를 들어, 돈을 이체할 경우에도,
원래 소유자의 잔고는 줄이고 새 소유자의 잔고는 늘려야 하는데, 원래 소유자의 잔고에서 금액을 빼는 것을
빼먹거나 반대로 새 소유자의 잔고에 더하는 것을 빼먹는 버그가 들어갈 수 있었습니다. 혹은 돈을 여러 사람에게
분배할 때도, 나누어 떨어지지 않는 금액이 아무도 모르게 소멸되는 버그도 생기기 쉬웠습니다.&lt;/p>
&lt;p>더 큰 수준의 버그도 일어나기 쉬웠는데, 이를테면 프로그래머가 별 신경을 쓰지 않고 게임의 보상으로 플레이어에
잔고에 돈을 더해주는 식의 코드만 짜도, 게임 전체의 경제상으로는 사실상 화폐를 사적으로 주조를 하는 것과 다름 없어집니다.&lt;/p>
&lt;p>이러한 실수들을 일찍부터 방지하기 위해, 이번 버전에서는 자산만을 다루기 위한 별도의 상태 API가 생겼습니다.
기존의 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1_GetState_Libplanet_Address_System_Nullable_Libplanet_HashDigest_SHA256___Libplanet_Blockchain_StateCompleter__0__">&lt;code>BlockChain&amp;lt;T&amp;gt;.GetState()&lt;/code>&lt;/a> 및 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_GetState_Libplanet_Address_">&lt;code>IAccountStateDelta.GetState()&lt;/code>&lt;/a> 메서드와 나란히 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1_GetBalance_Libplanet_Address_Libplanet_Assets_Currency_System_Nullable_Libplanet_HashDigest_SHA256___Libplanet_Blockchain_FungibleAssetStateCompleter__0__">&lt;code>BlockChain&amp;lt;T&amp;gt;.GetBalance()&lt;/code>&lt;/a>
및 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_GetBalance_Libplanet_Address_Libplanet_Assets_Currency_">&lt;code>IAccountStateDelta.GetBalance()&lt;/code>&lt;/a> 메서드가 생겼고, 상태를 자유롭게 덮어 쓸 수 있는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_SetState_Libplanet_Address_IValue_">&lt;code>IAccountStateDelta.SetState()&lt;/code>&lt;/a> 메서드와
달리 이체를 위한 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_SetState_Libplanet_Address_IValue_">&lt;code>IAccountStateDelta.TransferAsset()&lt;/code>&lt;/a>과 주조를 위한 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Action.IAccountStateDelta.html#Libplanet_Action_IAccountStateDelta_MintAsset_Libplanet_Address_Libplanet_Assets_FungibleAssetValue_">&lt;code>IAccountStateDelta.MintAsset()&lt;/code>&lt;/a> 등 용도별 메서드가 생겼습니다.&lt;/p>
&lt;p>또, 자산을 값으로 다룰 때도 .NET의 내장 정수 자료형을 쓰는 대신, Libplanet에 새롭게 더해진
&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Assets.FungibleAssetValue.html">&lt;code>FungibleAssetValue&lt;/code>&lt;/a> 자료형을 써야 합니다. &lt;code>FungibleAssetValue&lt;/code>는 기본적으로 &lt;a href="https://docs.microsoft.com/ko-kr/dotnet/api/system.numerics.biginteger?view=net-5.0">&lt;code>BigInteger&lt;/code>&lt;/a>처럼 생겼지만,
몇 몇 부분에서 차이가 있습니다.&lt;/p>
&lt;ol>
&lt;li>나눗셈을 할 때 나머지 값을 암시적으로 버리지 않고, 항상 나머지를 명시적으로 다뤄야 합니다.
따라서 나눗셈 연산자(&lt;code>/&lt;/code>)를 구현하지 않고 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Assets.FungibleAssetValue.html#Libplanet_Assets_FungibleAssetValue_DivRem_Libplanet_Assets_FungibleAssetValue_">&lt;code>DivRem()&lt;/code>&lt;/a> 메서드만 구현합니다.&lt;/li>
&lt;li>달러–센트 같이 하부 화폐 단위(minor currency units)를 지원하며, 하부 단위의 자릿수에 한계를 둡니다.&lt;/li>
&lt;li>서로 통화끼리는 섞이지 않도록, 각 값의 화폐 단위를 보존합니다.
마지막으로, 위의 3번을 구현하기 위해 화폐 단위를 정의하는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Assets.Currency.html">&lt;code>Currency&lt;/code>&lt;/a> 자료형이 생겼습니다.
해당 자료형은 화폐 단위의 명칭이나 티커 심볼, 하부 단위의 자릿수 등을 속성으로 갖습니다.&lt;/li>
&lt;/ol>
&lt;p>현재 자산 상태 API는 게임 머니 같은 변용성 자산(fungible assets)만 지원하지만, 추후 버전에서는 게임 아이템 같은 대체 불가 자산
&lt;a href="https://en.wikipedia.org/wiki/Non-fungible_token">&lt;abbr title="non-fungible token">NFT&lt;/abbr>&lt;/a>도 지원할 예정입니다.&lt;/p>
&lt;h2 id="새로운-렌더링-api">새로운 렌더링 API&lt;/h2>
&lt;p>기존에는 액션의 결과를 화면 등에 반영하기 위해 액션 클래스에 &lt;a href="https://docs.libplanet.io/0.9.2/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Render_Libplanet_Action_IActionContext_Libplanet_Action_IAccountStateDelta_">&lt;code>Render()&lt;/code>&lt;/a> 메서드를
구현해야 했습니다. 그러나 이러한 기존 API는 순수한 로직에 해당하는 액션 클래스에 뷰가 섞이게
만드는 문제가 있었습니다.&lt;/p>
&lt;p>예를 들어 같은 블록체인에 대해 3D 게임 엔진을 탑재한 풀 게임 프론트엔드와,
간단한 알림 기능과 게임 내 자산만 보여주는 지갑 프론트엔드를 만드려고 하면, &lt;code>Render()&lt;/code> 메서드에는
양쪽에 필요한 모든 코드가 들어가거나, 콜백을 전역 상태로 두고 이를 호출하는 패턴을 따르게 됩니다.
하나의 액션에 다양한 렌더링을 구현할 수 없기 때문입니다.&lt;/p>
&lt;p>이를 해결하기 위해 새 버전부터는 &lt;a href="https://docs.libplanet.io/0.9.2/api/Libplanet.Action.IAction.html">&lt;code>IAction&lt;/code>&lt;/a> 인터페이스에 &lt;code>Render()&lt;/code> 및 &lt;a href="https://docs.libplanet.io/0.9.2/api/Libplanet.Action.IAction.html#Libplanet_Action_IAction_Unrender_Libplanet_Action_IActionContext_Libplanet_Action_IAccountStateDelta_">&lt;code>Unrender()&lt;/code>&lt;/a>
메서드가 사라지고, 대신 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IRenderer-1.html">&lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 및 그 서브타입인 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IActionRenderer-1.html">&lt;code>IActionRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a>
인터페이스가 새롭게 생겼습니다. 프론트엔드는 각자를 위한 &lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code> 또는 &lt;code>IActionRenderer&amp;lt;T&amp;gt;&lt;/code> 구현을 갖고,
이를 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.BlockChain-1.html">&lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 객체 생성시에 연결하면 됩니다.&lt;/p>
&lt;p>간단한 렌더링만이 필요할 때는 인터페이스를 구현하는
클래스를 직접 짜는 대신, &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.AnonymousRenderer-1.html">&lt;code>AnonymousRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 클래스를 써보는 것을 추천합니다.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>
또한, 새 렌더링 API는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IActionRenderer-1.html#Libplanet_Blockchain_Renderers_IActionRenderer_1_RenderActionError_Libplanet_Action_IAction_Libplanet_Action_IActionContext_Exception_">&lt;code>IActionRenderer&amp;lt;T&amp;gt;.RenderActionError()&lt;/code>&lt;/a> 메서드를 통해 액션에서 난 예외를 다루거나,
&lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IRenderer-1.html#Libplanet_Blockchain_Renderers_IRenderer_1_RenderBlock_Libplanet_Blocks_Block__0__Libplanet_Blocks_Block__0__">&lt;code>IRenderer&amp;lt;T&amp;gt;.RenderBlock()&lt;/code>&lt;/a> 메서드를 통해 블록체인의 높이가 바뀐 것을 감지하거나, &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.IRenderer-1.html#Libplanet_Blockchain_Renderers_IRenderer_1_RenderReorg_Libplanet_Blocks_Block__0__Libplanet_Blocks_Block__0__Libplanet_Blocks_Block__0__">&lt;code>IRenderer&amp;lt;T&amp;gt;.RenderReorg()&lt;/code>&lt;/a>
메서드를 통해 리오그&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>가 일어난 것을 감지할 수 있게 되었습니다. 렌더링 코드가 액션과 분리되어 렌더러라는 독립적인 단위가 된 덕에,
데코레이터 패턴을 통한 미들웨어 구조가 가능해졌습니다. 그 예로, 새 버전부터 제공되는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.LoggedRenderer-1.html">&lt;code>LoggedRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 클래스는
다른 &lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code> 구현을 감싸 어떤 렌더링 이벤트가 어떤 시점에 발생했는지를 로그로 남겨줍니다. 디버그할 때는
게임 렌더러를 &lt;code>LoggedRenderer&amp;lt;T&amp;gt;&lt;/code>로 감싸서 실행하고, 실제 프로덕션에서는 감싸지 않고 게임 렌더러만을 쓰게 하는 식으로 활용 가능합니다.&lt;/p>
&lt;h2 id="지연-렌더러">지연 렌더러&lt;/h2>
&lt;p>Libplanet은 현재 종국성(finality)이 없는 작업 증명(PoW) 방식을 쓰고 있어, 최근 블록들은 리오그가 일어나기 쉽습니다.
이 때문에 여러 암호화폐 지갑이나 거래소에서도 트랜잭션의 컨펌 수(number of confirmations) 표시를 흔히 접할 수 있습니다.
컨펌 수가 높을 수록 리오그가 일어날 개연성이 떨어지기 때문입니다. 게임 내 행동의 결과가 리오그로 인해 너무 자주 변동될 경우 너무 혼란스러우므로,
이를 완화하기 위해 지연 렌더러가 추가됐습니다. &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Renderers.DelayedRenderer-1.html">&lt;code>DelayedRenderer&amp;lt;T&amp;gt;&lt;/code>&lt;/a>는 &lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code>를 입력으로 받으며 그 스스로도 &lt;code>IRenderer&amp;lt;T&amp;gt;&lt;/code>를 구현하는 데코레이터로,
이름처럼 렌더링 이벤트를 다소 지연시키는 미들웨어입니다. 블록체인에 새 블록이 쌓여도 바로 관련된 이벤트를 발생시키는 대신, 잠시 기다린 뒤 설정한 컨펌 수를 만족하게 되는 순간 이벤트를 발생시킵니다.
&lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>에서도 지연 렌더러를 쓰고 있으며, 컨펌 수는 플레이어가 설정 가능하게 옵션으로 제공하고 있습니다.&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="정적-분석기">&lt;a href="https://github.com/planetarium/libplanet/tree/main/Libplanet.Analyzers">정적 분석기&lt;/a>&lt;/h2>
&lt;p>Libplanet에서 모든 블록체인 내 상태는 액션을 통해서만 변경될 수 있습니다. 이 액션은 각 노드마다 각자 실행하여 이전 상태로부터 새 상태를 도출하는데,
따라서 블록체인 네트워크의 모든 노드가 일관된 상태를 합의하려면, 액션은 반드시 결정적(deterministic)이어야 합니다.
그러나 아무리 어떠한 요소가 코드를 비결정적으로 만드는지 알고 있다고 하더라도, 복잡한 로직을 결정적으로 짜는 것은 쉽지 않습니다.
알고도 실수할 수 있고, 여러 사람들이 함께 만지다보면 각자 수정한 부분은 결정적으로 보여도 다 합쳐놓고 보니 비결정적으로 되기도 쉽습니다.&lt;/p>
&lt;p>이러한 실수를 완화하기 위해, 새 버전부터는 Libplanet 액션 코드의 실수를 정적 분석으로 체크하는 &lt;a href="https://www.nuget.org/packages/Libplanet.Analyzers">Libplanet.Analyzers 패키지&lt;/a>가 도입되었습니다.
이 정적 분석기는 저희가 실제로 나인 크로니클을 개발하면서 반복적으로 만났던 실수들을 토대로 흔한 잠재적 버그들을 미리 경고해 줍니다.
사용법은 아주 쉬운데, NuGet 패키지 의존성으로 추가하기만 하면 빌드할 때 C# 컴파일러 오류와 함께 경고로 출력됩니다.&lt;/p>
&lt;p>다만, 아직 초기 버전이기 때문에, 아직 체크의 수가 다양하지 않고, 또 사람이 보기에는 명백하게 바른 코드인데도 잠재적 버그로 경고하는 경우가 여전히 많습니다.
이러한 부분들은 추후 버전에서 점진적으로 개선될 예정입니다.&lt;/p>
&lt;h2 id="블록당-바이트-사이즈-및-트랜잭션-수-제한">블록당 바이트 사이즈 및 트랜잭션 수 제한&lt;/h2>
&lt;p>이제까지 Libplanet은 한 블록의 용량이 아무리 크거나 트랜잭션이 아무리 많이 들어가도 이를 제한하지 않았습니다.
그렇지만 이러한 제한이 없을 경우 악의적 공격에 노출되기 쉽고, 아무도 악의적이지 않더라도 너무 많은 트랜잭션을 한 블록에 담으려다 보니
레이턴시가 지나치게 떨어지는 현상이 왕왕 발생했습니다.&lt;/p>
&lt;p>이를 완화하기 위해, 새 버전에서는 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html">&lt;code>IBlockPolicy&amp;lt;T&amp;gt;&lt;/code>&lt;/a> 인터페이스에서 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_GetMaxBlockBytes_System_Int64_">&lt;code>GetMaxBlockBytes()&lt;/code>&lt;/a> 메서드 및 &lt;a href="https://docs.libplanet.io/0.10.2/api/Libplanet.Blockchain.Policies.IBlockPolicy-1.html#Libplanet_Blockchain_Policies_IBlockPolicy_1_MaxTransactionsPerBlock">&lt;code>MaxTransactionsPerBlock&lt;/code>&lt;/a> 속성을 통해
블럭 하나에 최대 몇 바이트까지 차지할 수 있는지, 그리고 한 블럭에 최대 몇 개의 트랜잭션까지 수용할 수 있는지를 네트워크 단위로 설정 가능하게 됐습니다.
마이너는 블록을 만들 때 설정된 수를 초과하지 않는 선에서 알아서 트랜잭션들을 나눠 담게 되며, 악의적인 노드가 네트워크 설정을 초과하는 블록을
만들어서 전파하더라도 다른 노드들은 이 블록을 무효한 것으로 보게 됩니다.&lt;/p>
&lt;p>네트워크나 애플리케이션에 따라 최적 설정이 달라질 수 있으므로, 설정 수치는 개발 단계에서 시범 네트워크를 운영해보며 조정하는 것이
바람직합니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 외에도 여러 성능 개선이나 자잘한 마이너 패치가 있었습니다. 자세한 내용은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.10.0">전체 변경 내용&lt;/a> 에서 확인해 주세요.&lt;/p>
&lt;p>질문이나 관심이 있으신 분들은 또한 저희 &lt;a href="https://discord.gg/planetarium">Discord&lt;/a> 채널에 놀러와 주세요!&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>Java와 달리 C#에는 익명 클래스가 없습니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>리오그에 관해서는 김무훈 님의 지난 스낵 글 &lt;a href="https://snack.planetarium.dev/kor/2020/10/decentralized-and-online-game-intersect/">〈탈중앙과 온라인 게임이 교차하다〉&lt;/a>를 참고하세요.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>현재 UI로 설정 가능하지는 않지만, 설정 파일을 직접 고칠 수 있습니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>탈중앙과 온라인 게임이 교차하다</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/10/decentralized-and-online-game-intersect/" title="탈중앙과 온라인 게임이 교차하다"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/10/decentralized-and-online-game-intersect/" hreflang="en" title="Decentralization Intersects with Online Game"/><id>https://snack.planetarium.dev/kor/2020/10/decentralized-and-online-game-intersect/</id><published>2020-10-08T00:00:00+00:00</published><updated>2020-10-08T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요! 지난 2개월 간 플라네타리움의 엔지니어링 인턴으로 일한 김무훈입니다. 저는 &lt;a href="https://nine-chronicles.com">나인 크로니클&lt;/a> 출시 직전의 베타 과정을 함께했는데요.&lt;/p>
&lt;p>간단히 블록체인과 게임을 결합하며 특이하다고 생각한 기술적인 사례를 소개하겠습니다.&lt;/p>
&lt;h2 id="탈중앙">탈중앙&lt;/h2>
&lt;p>온라인 게임은 멀티 플레이와 사용자의 데이터를 저장하는 등 서비스를 운영하기 위한 용도로 서버를 이용합니다. 그러나 운영사가 폐업하는 등 여러 이유로 서비스가 중단되면 더 이상 게임을 즐길 수 없게 됩니다.&lt;/p>
&lt;p>모두가 온라인 게임을 분업하여 유지할 수 있다면 사용자가 남아있는 한 서비스가 종료될 걱정은 없게 됩니다. 이 개념에 맞는 탈중앙은 전통적인 중앙 서버의 역할을 사용자에게 분담해두는 형태를 의미하는데요. 기술적으로는 &lt;abbr title="Peer to peer">P2P&lt;/abbr>나, 분산화 기술이라고 아마 한 번쯤은 들어 보셨을 겁니다.&lt;/p>
&lt;h2 id="재구성-현상">재구성 현상&lt;/h2>
&lt;p>플라네타리움은 여러 분산화 기술 중에 블록체인을 활용해서 게임 내 재화, 보유한 아이템, 달성한 퀘스트 등의 데이터를 보존합니다.&lt;/p>
&lt;p>블록체인에 게임 플레이 데이터를 보관하면 간혹 이 정보가 몇시간 전으로 되돌아가는 문제가 있습니다. 블록체인 네트워크에서 일어나는 &lt;dfn>재구성 현상&lt;/dfn>이라는 결함인데요.&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 블록체인 커뮤니티에서는 이를 &lt;dfn>리오그&lt;/dfn>(&lt;abbr title="reorganization">reorg&lt;/abbr>)라 줄여서 부릅니다. 이 글에서도 편의상 리오그라 칭하겠습니다.&lt;/p>
&lt;figure>&lt;img src="images/single-chain.png"
alt="블록이 순서대로 연결되어 있는 것을 체인이라 한다."/>&lt;figcaption>
&lt;p>블록이 순서대로 연결되어 있는 것을 체인이라 한다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>리오그 현상에 대해 설명하기 전에 블록체인 네트워크에는 언제나 하나의 체인을 정본으로 지목한다는 사실부터 짚고 넘어가야 합니다.&lt;/p>
&lt;p>블록체인의 블록은 누구나 생성할 수 있습니다. 그러나 블록을 생성하는 여러 노드가&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup> 같은 시점에 블록을 동시에 만든다면 시작은 같은데 끝 부분이 서로 다른 여러 체인이 나타납니다. 어떻게 하면 하나의 체인을 정본으로 지목할 수 있는 것일까요? 중앙의 누군가가 정해주는 것도 아닌데도 말입니다.&lt;/p>
&lt;figure>&lt;img src="images/orphaned-block.png"
alt="비슷한 시점에 더 많은 자원이 투입된 체인을 채택한다."/>&lt;figcaption>
&lt;p>비슷한 시점에 더 많은 자원이 투입된 체인을 채택한다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>각 노드가 제멋대로 체인을 고르지는 않고, 모든 노드가 공유한 규칙에 따라 가장 규칙에 적합한 체인을 고릅니다. 나인 크로니클 및 Libplanet이 따르고 있는 작업 증명(&lt;abbr title="proof-of-work">PoW&lt;/abbr>) 방식에서는 비슷한 시점에 블록을 생성하는데 더 많은 자원이 투자된 체인을 채택합니다.&lt;/p>
&lt;figure>&lt;img src="images/orphaned-blocks.png"
alt="5개의 길이를 가졌던 파란 블록의 체인이 빨간 블록으로 리오그된다. (깊은 리오그)"/>&lt;figcaption>
&lt;p>5개의 길이를 가졌던 파란 블록의 체인이 빨간 블록으로 리오그된다. (깊은 리오그)&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>그런데 기존의 주류 체인보다도 이 규칙에 더 부합하는 다른 체인이 네트워크에 나타날 경우, 이 순간 주류 블록체인이 뒤집히게 됩니다.&lt;/p>
&lt;p>보통의 경우 블록 한두 개를 두고 &lt;dfn>얕은 리오그&lt;/dfn>가 일어나지만 나누어진 블록의 깊이가 일정 개수보다 많다면 &lt;dfn>깊은 리오그&lt;/dfn>가 일어납니다. 예를 들어,&lt;/p>
&lt;ol>
&lt;li>A, B 분기로 체인이 나뉘어져 다른 노드로 전파된다.&lt;/li>
&lt;li>비슷한 비율로 점차 전파되는 노드가 늘어가며 체인의 길이도 늘어간다.&lt;/li>
&lt;li>모든 노드가 A 분기와 B 분기 중 하나를 채택했고, A 분기의 체인이 더 길면서 채택된 비율이 높다.&lt;/li>
&lt;li>B 분기의 체인을 채택한 모든 노드의 체인이 A로 리오그 됩니다.&lt;/li>
&lt;/ol>
&lt;style>
@media screen and (min-width: 70em) {
img[src="images/bug-report.png"] {
width: 60%
}
}
&lt;/style>
&lt;figure>&lt;img src="images/bug-report.png"
alt="어제 10,000 골드를 보유했던 사용자가 1,000 미만의 골드를 보유하게 되었다고 제보를 했다."/>&lt;figcaption>
&lt;p>어제 10,000 골드를 보유했던 사용자가 1,000 미만의 골드를 보유하게 되었다고 제보를 했다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>그래서 앞서 이야기했듯이, 리오그 현상 때문에 레벨이나 가진 아이템이 몇 분에서 몇 시간 전의 상태로 되돌아갔다는 이야기가 나인 크로니클 커뮤니티에서 자주 언급되었습니다.&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup> 탈중앙 네트워크에서 발생한 일이기 때문에 운영진에게 되돌려달라고 할 수도 없는 노릇입니다.&lt;/p>
&lt;h2 id="블록체인-네트워크-초기화">블록체인 네트워크 초기화&lt;/h2>
&lt;p>나인 크로니클은 베타 기간 동안 체인 네트워크를 일곱 번 초기화했습니다. 체인 네트워크가 초기화되면 게임 플레이어가 일구었던 게임 데이터가 모두 사라지게 됩니다. 이런 위험을 감수하고도 초기화를 감행한 이유는 다음과 같습니다.&lt;/p>
&lt;p>블록체인 네트워크 코어 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>에서는 게임의 상태를 블록에 저장합니다. 사용자의 행동은 경우 &lt;a href="https://docs.libplanet.io/0.9.5/api/Libplanet.Action.IAction.html">액션&lt;/a>이라는 이름의 자료 구조에 맞추어 저장됩니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-json" data-lang="json">{
&lt;span style="color:#b06;font-weight:bold">&amp;#34;stageId&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;123&amp;#34;&lt;/span>,
&lt;span style="color:#b06;font-weight:bold">&amp;#34;id&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;ntPSdIREOUOARaRYJHlGEg==&amp;#34;&lt;/span>,
&lt;span style="color:#b06;font-weight:bold">&amp;#34;equipments&amp;#34;&lt;/span>: [&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;KTm6cLkrtEWs6k4A821K3Q==&amp;#34;&lt;/span>],
&lt;span style="color:#b06;font-weight:bold">&amp;#34;avatarAddress&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;sGo0bo0VwrYA7ubq6yV8ctiU2vc=&amp;#34;&lt;/span>,
&lt;span style="color:#b06;font-weight:bold">&amp;#34;foods&amp;#34;&lt;/span>: [],
&lt;span style="color:#b06;font-weight:bold">&amp;#34;worldId&amp;#34;&lt;/span>: &lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;3&amp;#34;&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>만약 게임 내에서 의상 요소가 업데이트된다면 &lt;code>costumes&lt;/code> 같이 새로운 속성이 추가되고, 이 정보가 담긴 블록의 해시가&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup> 이전 블록의 해시를 만드는 규약(protocol)과 맞지 않게 됩니다. 규약이 달라지면 이전의 블록 데이터를 이어서 사용할 수 없게 됩니다.&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> 이 외에도 유니크한 값이 다르게 되거나, Libplanet이나 그 SDK의 코드 중에 해시에 영향이 가는 수정이 생긴다면 달라집니다.&lt;/p>
&lt;p>이런 경우의 대개 다른 블록체인에서는 몇 번째 블록 이후부터 블록을 다르게 해석하도록 규약을 추가합니다. 나인 크로니클도 그럴 수 있지만, 크고 작은 변경이 잦은 베타 기간에 이런 방법을 취하는 것은 무리라고 판단했습니다. 그래서 체인을 매번 초기화하는 것을 감행한 것입니다.&lt;/p>
&lt;p>정식 출시 이후에는 체인을 유지할 예정입니다. 그러기 위한 여러 제안이 검토된 상황으로, 기회가 된다면 이후에 스낵에서 이를 소개하겠습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>플라네타리움은 &amp;ldquo;커뮤니티가 운영하는 온라인 게임&amp;quot;이라는 매력으로 새로운 형태의 게임 문화를 정착시키는 것에 큰 기대를 하고 있습니다. 간혹 온라인 게임의 운영사 직원이 게임의 자원을 횡령하여 게임의 생태계를 무너뜨리는 일이 언론에 보도되는데요. 나인 크로니클은 게임의 규칙이 프로토콜 수준으로 투명해져서 그런 일이 원칙적으로 일어날 수 없습니다.&lt;/p>
&lt;p>이러한 장점에도 불구하고 Libplanet이 사용하는 블록체인 프로토콜이 진입 장벽으로 느껴질 수 있습니다. 작업 내역을 라인 단위로 분산하고 자동으로 병합이 되는 Git을 처음 보고 느낀 충격이랄까요. 그래서 여러분이 게임을 플레이하면 겪는 아쉬움, 개선점을 &lt;a href="https://discord.gg/planetarium">디스코드 채널&lt;/a>과 GitHub&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>에서 받고 있습니다.&lt;/p>
&lt;p>이 글은 앞으로 시리즈로 연재되며, 다음 발행 때에는 나인 크로니클이 리오그 현상과 체인 리셋을 어떻게 대처하였는지 소개하는 시간을 가질 예정입니다. 읽어주셔서 감사합니다.&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>엔지니어링 팀 내부에서는 플레이했던 기록이 꿈처럼 되어 버린다고 해서 &lt;dfn>신기루&lt;/dfn> 현상으로 부릅니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>블록체인 네트워크에 참여하는 컴퓨터를 의미합니다.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>블록체인 코리빙·코워킹 커뮤니티 논스(nonce) 공동 창립자 하시은 님이 쓴 &lt;a href="https://www.facebook.com/unseenone.flohsdpsyphle/posts/1027765500973348">게임 후기&lt;/a>에서 사용자 입장의 상황이 잘 설명되었습니다.&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>블록체인은 그 이전 블록의 해시를 메타 정보 삼아 체인을 이읍니다. 연결 리스트를 떠오르면 이해하기 쉽습니다.&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>확장한 명세가 들어간 게임 클라이언트가 이전 블록을 제대로 해석하지 못할 가능성이 있습니다.&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&lt;p>P2P 온라인 게임을 위한 블록체인 코어 — &lt;a href="https://github.com/planetarium/libplanet">libplanet&lt;/a>, 나인 크로니클을 위한 Libplanet 기반의 SDK — &lt;a href="https://github.com/planetarium/lib9c">Lib9c&lt;/a>, 나인 크로니클 클라이언트 전용의 블록체인 노드 서비스 — &lt;a href="https://github.com/planetarium/ninechronicles.standalone">NineChronicles.Standalone&lt;/a>, 이 밖에도 나인 크로니클 론처와 게임 클라이언트의 저장소를 공개할 예정입니다.&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content><author><name>김무훈</name><uri>https://github.com/x86chi</uri><email>iam@muhun.kim</email></author></entry><entry><title>플라네타리움에서 한 달동안 경험한 이야기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/06/junior-experience/" title="플라네타리움에서 한 달동안 경험한 이야기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/06/junior-experience/" hreflang="en" title="My First Month at Planetarium"/><id>https://snack.planetarium.dev/kor/2020/06/junior-experience/</id><published>2020-06-02T00:00:00+00:00</published><updated>2020-06-02T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 이번에 &lt;a href="https://planetariumhq.com/">플라네타리움&lt;/a>에 합류하게 된 이수호입니다. 합류한 지 한 달이 된 기념(?)으로 제가 이 회사에 어떤 기대를 하고 입사하였는지, 한 달 동안 무엇을 했고 플라네타리움은 어떻게 일하는지 간단하게 소개해 보는 시간을 가지고자 합니다.&lt;/p>
&lt;h2 id="입사-계기">입사 계기&lt;/h2>
&lt;p>작년 6월경, &lt;a href="https://www.sprintseoul.org/2019-06-29/">2019 스프린트 서울&lt;/a>이라는 행사에 참여하게 되었습니다. 무슨 오픈 소스에 기여할까 고민하던 저에게 당시 플라네타리움 팀원이셨던 홍민희 님이 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>에 기여를 해 보면 어떻겠냐는 제안을 해 오셨습니다. 그렇게 즐겁게 기여를 마치고 나서 잊지 않고 있다가, 플라네타리움 구인 기간에 지원하여 입사하게 되었습니다. 이 곳이라면 내가 얻었던 즐거운 경험을 남들에게도 줄 수 있고, 나 자신도 그런 경험을 계속 쌓아나갈 수 있을 것이라고 판단하였기 때문입니다.&lt;/p>
&lt;h2 id="한-달-동안-한-것">한 달 동안 한 것&lt;/h2>
&lt;p>한 달 동안은 기본적으로 Libplanet의 구조와 C#에 대한 이해를 끌어올렸습니다. 개념 증명(&lt;abbr title="proof of concept">PoC&lt;/abbr>) 수준의 Libplanet을 새로 작성해 보고, 각 모듈별 설명을 들을 때마다 그 모듈에 대한 이슈를 하나씩 제거해 나갔습니다.&lt;/p>
&lt;figure>&lt;img src="images/resolved-issue.png"
alt="한 달 동안 제거해나간 이슈 목록"/>&lt;figcaption>
&lt;p>한 달 동안 제거해나간 이슈 목록&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>개인적으로 매우 효과를 본 방법이라고 생각합니다. 설명을 들을 때는 높은 문맥의 이야기만 대부분 듣기 때문에, 이 높은 문맥에서 일어나는 일들이 낮은 문맥에서 어떻게 일어나는지 직접 알아가며 체득하고, 실제로 문제를 해결하기 위해 분석하다 보니 이해도가 높았습니다.&lt;/p>
&lt;p>또한 일일 업무일지를 저 개인적으로 적어나갔습니다.&lt;/p>
&lt;figure>&lt;img src="images/daily-reports.png"
alt="업무일지 목록"/>&lt;figcaption>
&lt;p>업무일지 목록&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;figure>&lt;img src="images/daily-report.png"
alt="업무일지"/>&lt;figcaption>
&lt;p>업무일지&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>이렇게 간단하게 독백하듯 막히는 것을 적어놓는 습관을 들이게 된 이유는 바로 &lt;em>데일리 미팅&lt;/em> 때문입니다.&lt;/p>
&lt;h2 id="회의-문화">회의 문화&lt;/h2>
&lt;p>Libplanet팀에서 하는 회의 종류에는 총 3가지 있습니다.&lt;/p>
&lt;ul>
&lt;li>데일리 미팅&lt;/li>
&lt;li>주간 미팅&lt;/li>
&lt;li>분기별 회고&lt;/li>
&lt;/ul>
&lt;p>이 중 &lt;dfn>데일리 미팅&lt;/dfn>(줄여서 &lt;dfn>데일리&lt;/dfn>)은 간단하게 현재 하고 있는 일을 오후 2시에 공유하는 미팅입니다. 보통 자기가 &amp;lsquo;집중 모드&amp;rsquo;에 들어간 경우, 누군가 깨워 주거나 아이디어를 주기 전까지는 계속 오버엔지니어링 혹은 이른바 삽질을 계속 하게 됩니다. 하지만 데일리 미팅을 진행하므로써 그것을 미연에 방지하고 서로의 일을 조금씩 도와줄 수 있다는 점이 좋았습니다. 또한 저 개인적으로는 데일리용 업무일지를 적으면서 자기객관화가 쉽게 이루어져, 업무 자체에도 도움이 많이 되었습니다.&lt;/p>
&lt;p>데일리는 많은 곳에서 진행하지만, 이걸 자신의 &lt;em>일 했다는 알리바이 증명 용도&lt;/em>로 사용하게 되는 경우가 많습니다 (예: 수직적 의사결정 구조에서 하급자가 상급자에게 보고하는 형태). 하지만 저희 팀은 데일리 미팅 때 내가 하는 일을 부풀리거나 보고하는 게 아닌 막히고 있는 부분을 솔직하게 밝히고, 모르는 부분이 있으면 물어보는 등 서로에게 정보를 공유하는 점이 매우 마음에 들었습니다.&lt;/p>
&lt;h2 id="실천하는-팀원들">실천하는 팀원들&lt;/h2>
&lt;p>의사 결정에 있어 실패에 대한 책임을 묻는 것은 아무 의미도 없다는 말은 진부할 정도로 누구나 잘 알고 있습니다. 실패하면 빠르게 공유·피드백하고, 이를 통해 대안책을 찾아 나가는 것이 좋다는 것도 누구나 알고 있습니다. 하지만 실천하는 것은 말처럼 쉽지가 않습니다.&lt;/p>
&lt;p>제가 들어온 지 얼마 안 됐을 때, Windows와 macOS에서 모두 동작하는 작은 GUI 앱을 만들 일이 있었는데, 보름 전에 쓰기로 결정했던 크로스플랫폼 GUI 프레임워크가 저희가 풀려는 문제 상황에 적합하지 않다는 것을 뒤늦게 깨닫게 되었습니다. 그렇지만 해당 작업을 진행하던 사람은 어떻게든 문제를 해결하려고 집중하다 보니 이미 일주일도 넘는 시간이 훌쩍 지나 있었고, 결과적으로 GUI 프레임워크를 교체하자는 결정을 늦게 내리게 되어서 이로 인해 일정이 뒤로 밀리게 되었습니다. 이러한 실패는 보통 회고 시간에 당연히 에둘러서라도 아쉬운 소리를 한다든가, 여태 얼마나 오랜 시간을 허비하였는지에 대해 (설령 그럴 의지가 없었다 하더라도) 비난하게 됩니다.&lt;/p>
&lt;p>하지만 오히려 &lt;q>우리는 이런 선택이 잘못되었음을 알았다. 얻은 게 있으니 상관없다&lt;/q>라고 말하며 앞으로 이런 결정을 하지 않을 방법을 찾았고, &lt;q>좀 더 자주 모여 얘기하면 문제를 해결하는 데 집중하느라 놓치는 것들을 알 수 있을 것&lt;/q>이라는 결론에 도달했습니다. 그리고 구체적인 방안으로, 데일리 이외에 저녁의 짧은 공유 세션을 하나 더 만들었습니다.&lt;/p>
&lt;p>이후 팀 내에서 오전에는 작업이 순조롭다 생각했으나 몰입하다 보니 오후까지 같은 걸 붙잡고 늘어지고 있었단 걸 저녁 공유 세션을 통해 깨닫게 되어서 좋았다는 피드백이 있었습니다.&lt;/p>
&lt;p>이런 식으로 무슨 일이 순조롭게 되지 않았을 때 &lt;q>왜 계획대로 하지 못했냐&lt;/q>고 다그치는 게 아닌, &lt;q>그럼 다른 방법으로 해보자&lt;/q>라는 팀 분위기가 매우 좋았습니다.&lt;/p>
&lt;h2 id="그-외-복지">그 외 복지&lt;/h2>
&lt;p>여러 복지가 있지만, 그 중에서도 기억에 남는 복지들입니다.&lt;/p>
&lt;ul>
&lt;li>리모트 근무&lt;/li>
&lt;li>(진짜) 수평적 의사결정&lt;/li>
&lt;li>멋지고 뛰어난 사람들&lt;/li>
&lt;/ul>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>이 글을 쓰고 있던 도중, 엔지니어링 워크샵에서 이런 발언이 나왔습니다.&lt;/p>
&lt;blockquote>
&lt;p>우리 이름을 스낵이라고 지어 놓고, 너무 무거운 글들이 올라오는 거 아니에요? (웃음)&lt;/p>
&lt;/blockquote>
&lt;p>생각해보니 그렇습니다. 그래서 최대한 글 양을 줄이고 스크린숏을 넣는 등 여러 시도를 해 보았는데 어떠셨을지 모르겠네요. 읽는 데 편안했었으면 좋겠습니다.&lt;/p>
&lt;p>마지막으로 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>은 여러분의 기여를 언제나 기다리고 있습니다! 오픈 소스에 관심있는 분들은 저희 &lt;a href="https://discord.gg/planetarium">디스코드 채널&lt;/a>에도 놀러오세요. 감사합니다!&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>Libplanet 팀이 2020 스프린트서울에도 참여합니다!</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/05/sprintseoul/" title="Libplanet 팀이 2020 스프린트서울에도 참여합니다!"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/05/sprintseoul/" hreflang="en" title="Team Libplanet is Participating in 2020 Sprint Seoul!"/><id>https://snack.planetarium.dev/kor/2020/05/sprintseoul/</id><published>2020-05-19T00:00:00+00:00</published><updated>2020-05-19T00:00:00+00:00</updated><content type="html">&lt;p>오랜만입니다! &lt;a href="https://sprintseoul.org/">스프린트서울&lt;/a>에 프로젝트 리더로 참가하게 된
&lt;a href="https://libplanet.io/">Libplanet&lt;/a> 팀입니다.&lt;/p>
&lt;p>저희 팀은 꾸준히 행사에 참여하고 있으며, 이번 스프린트에도 참여했습니다!
그동안 스프린트서울은 하루라는 짧은 시간동안 함께 문제를 해결해 나가는 행사였지만,
이번 스프린트서울은 5월 한 달 내내 진행됩니다.&lt;/p>
&lt;p>그에 맞춰 저희도 이번엔 조금 더 긴 시간동안 도전적인 문제를 해결해 보고 싶은 분들이
관심이 있어할 만한 이슈들과, 처음 기여하시는 분들이 부담 없이 기여하실 수 있는 이슈
두 가지 모두 준비해 보았습니다.&lt;/p>
&lt;p>또한 스프린트에 참가하여 저희 저장소에 기여해 주신 분들에 대해 &lt;strong>소정의 상품&lt;/strong>도 준비하고 있으니,
많은 참여 부탁드립니다!&lt;/p>
&lt;h2 id="프로젝트-소개">프로젝트 소개&lt;/h2>
&lt;p>&lt;a href="https://libplanet.io/">Libplanet&lt;/a>은 BitTorrent처럼 서버 없이 돌아가는 P2P 멀티플레이 게임을 만들기
위한 네트워킹・스토리지 라이브러리로, 이를 달성하기 위해 블록체인 기술을
구현합니다. 이용자 각각이 실행하는 게임 앱들이 네트워크에서 서로 연결되며,
게임의 공정한 판정과 기록을 위해 운영되는 서버가 없는 대신,
공정한 판정은 합의 알고리즘을 통해, 기록은 리플리케이션을 통해 이뤄집니다.&lt;/p>
&lt;p>이번 스프린트에서 다룰 저장소로는 아래 세 곳이 있습니다.
각자 익숙하거나 선호하는 환경에 따라 다른 저장소에 기여해 주시면 될 것 같습니다.
참고로 세 저장소 모두 Linux, macOS, Windows 세 플랫폼에서 개발 가능합니다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a>: 네트워킹 및 스토리지, 블록체인 등을 구현하는
프로젝트의 핵심으로, Unity 등의 게임 엔진과 함께 쓰일 수 있도록 C#으로
작성되어 있으며 멀티플랫폼입니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet-explorer">Libplanet Explorer (서버)&lt;/a>: Libplanet을 이용해 만든
게임이 분산 네트워크 위에서 쌓아 올린 블록체인 데이터를 게임 외부에서도
열람할 수 있도록 GraphQL 프로토콜로 노출하는 C# 앱입니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet-explorer-frontend">Libplanet Explorer (웹)&lt;/a>: 웹 서버가 GraphQL을
통해 제공하는 데이터를 웹 프론트엔드로 구현한 비교적 최종 사용자 지향의
웹 앱(클라이언트)입니다. TypeScript, React, Gatsby, Apollo를 이용해
작성되어 있습니다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>특히 이 중에서 *Libplanet Explorer (웹)*은 TypeScript로 되어 있어, 블록체인 기술이나
C#을 잘 모르지만, Libplanet에 대해 관심이 있던 참가자 분들도 기여하실 수 있습니다.&lt;/p>
&lt;h2 id="c-개발-환경">C# 개발 환경&lt;/h2>
&lt;p>먼저, C# 프로젝트에 참여하기 위해서는 개발 환경을 설치해야 합니다.
C#은 Python이나 JavaScript 등과 달리 IDE가 없으면 코딩하기 힘든 언어입니다.
Windows라면 최신 버전의 Visual Studio를 설치하면 되겠지만, 여러 플랫폼에서
두루 쓸 수 있는 IDE로 Rider나 VS Code를 추천합니다. 아래 문서들은
Rider 또는 Visual Studio Code를 쓴다는 가정 하에 Libplanet의 개발 환경을
설치하는 방법을 한국어로 안내하고 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://gist.github.com/dahlia/5333634f62509293cd46c0e4ba65b2f5">Libplanet 개발 환경 설정 (VS Code)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gist.github.com/dahlia/08f6e659e2266e941ad026f591c30c9a">Libplanet 개발 환경 설정 (Rider)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>그 외에, Libplanet 저장소의 &lt;em>&lt;a href="https://github.com/planetarium/libplanet/blob/master/CONTRIBUTING.md">CONTRIBUTING.md&lt;/a>&lt;/em> 문서는 CLI 도구만을 이용해서 개발하는 아주
기본적인 개발 환경 설정을 안내합니다. 꼭 자신이 이용하는 에디터를 쓰고 싶은 분들은 이쪽을 읽어주시면
되겠습니다.&lt;/p>
&lt;h2 id="typescript-개발-환경">TypeScript 개발 환경&lt;/h2>
&lt;p>TypeScript 개발 환경은 C# 개발 환경에 비해 간단합니다. Libplanet Explorer (웹) 저장소의 &lt;em>&lt;a href="https://github.com/planetarium/libplanet-explorer-frontend/blob/master/README.md">README.md&lt;/a>&lt;/em> 문서에
잘 정리되어 있으니, 어렵지 않게 따라하실 수 있을 것입니다.&lt;/p>
&lt;h2 id="살펴볼-만한-이슈">살펴볼 만한 이슈&lt;/h2>
&lt;p>처음 기여하시는 분들을 위한 각 프로젝트 별 초심자용 이슈들을 모아놨습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">Libplanet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet-explorer/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">Libplanet Explorer (서버)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet-explorer-frontend/issues?q=is%3Aissue+is%3Aopen+label%3A%22good+first+issue%22">Libplanet Explorer (웹)&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>프로젝트 구조를 자세히 파악하지 못한 상태에서도 깊게 들어가지 않고 해볼 수 있을 만한 것들입니다.&lt;/p>
&lt;p>뿐만 아니라, 좀 더 도전적인 문제를 찾는 분들을 위한 &lt;em>help wanted&lt;/em> 레이블 또한 준비되어 있습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22">Libplanet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet-explorer/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22">Libplanet Explorer (서버)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet-explorer-frontend/issues?q=is%3Aissue+is%3Aopen+label%3A%22help+wanted%22">Libplanet Explorer (웹)&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="고민되거나-망설여진다면">고민되거나 망설여진다면&lt;/h2>
&lt;p>어떤 기여를 어떻게 해야 할지 고민이 되는 분들은, 저희 프로젝트에 기여하신 분들의 경험담을 읽어보시고
결정하셔도 좋을 것 같습니다.&lt;/p>
&lt;ul>
&lt;li>이승훈 님께서 쓰신 &lt;cite>&lt;a href="https://snack.planetarium.dev/kor/2019/05/first-contribution/">Libplanet 처음 기여하기&lt;/a>&lt;/cite>&lt;/li>
&lt;li>이수호 님께서 쓰신 &lt;cite>&lt;a href="https://blog.hanaoto.me/sprint_seoul_2019_june/">2019 스프린트 서울 6월 행사를 참여하고 나서&amp;hellip;&lt;/a>&lt;/cite>&lt;/li>
&lt;/ul>
&lt;h2 id="질문-및-대화방">질문 및 대화방&lt;/h2>
&lt;p>궁금한 게 있으시면 &lt;a href="https://discord.gg/wUgwkYW">저희 Discord 서버&lt;/a>에 있는 #libplanet-users-kr 채널에
오셔서 물어보셔도 됩니다. 행사 전에 미리 들어오셔서 물어보셔도 좋고, 행사 끝난 뒤라도
좋습니다. 단순히 놀러 오셔도 환영입니다!&lt;/p></content><author><name>이수호</name><uri>https://github.com/riemannulus</uri><email>suho@planetariumhq.com</email></author></entry><entry><title>Unity DOTS DynamicBuffer 사용하기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/" title="Unity DOTS DynamicBuffer 사용하기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/05/unity-dots-start-to-use-dynamic-buffer/" hreflang="en" title="How to Use Unity DOTS DynamicBuffer"/><id>https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/</id><published>2020-05-18T00:00:00+00:00</published><updated>2020-05-18T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. &lt;a href="https://planetariumhq.com/">플라네타리움&lt;/a>에서 &lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>을 개발하고 있는 현승민입니다. 해당 프로젝트는 아직 Unity &lt;a href="https://unity.com/dots">&lt;abbr title="Data-Oriented Technology Stack">DOTS&lt;/abbr>&lt;/a>를 사용하고 있지 않지만, 차기작에 적용하기 위해 열심히 공부 중인데요. 앞으로 공부한 내용을 꾸준히 공유해보려고 해요.&lt;/p>
&lt;p>이번에는 &lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html">&lt;code>DynamicBuffer&amp;lt;T&amp;gt;&lt;/code>&lt;/a>에 대해서 알아 볼게요. 엔티티에 동적 버퍼를 설정하고 이를 사용하는 방법에 대한 것인데요. DOTS와 관련한 첫 번째 글 치고는 몇 단계를 넘어 오기는 했지만 그 양이 적으니 관련한 내용을 함께 보시면 바로 이해하실 수 있을 것이라 생각해요.&lt;/p>
&lt;p>이 글은 &lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/manual/dynamic_buffers.html">Unity 공식 문서&lt;/a>와 &lt;a href="https://www.youtube.com/watch?v=XC84bc95heI">튜토리얼 영상&lt;/a>을 참고했어요.&lt;/p>
&lt;h2 id="개발-환경">개발 환경&lt;/h2>
&lt;dl>
&lt;dt>Unity&lt;/dt>
&lt;dd>2019.3.12f1&lt;/dd>
&lt;dt>&lt;code>com.unity.entities&lt;/code>&lt;/dt>
&lt;dd>0.10.0-preview.6&lt;/dd>
&lt;/dl>
&lt;h2 id="ibufferelementdataibufferelementdata-구현하기">&lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IBufferElementData.html">&lt;code>IBufferElementData&lt;/code>&lt;/a> 구현하기&lt;/h2>
&lt;p>엔티티에 더하는 컴포넌트가 &lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IComponentData.html">&lt;code>IComponentData&lt;/code> 인터페이스&lt;/a>를 구현해야 하는 것과 마찬가지로, &lt;code>DynamicBuffer&amp;lt;T&amp;gt;&lt;/code> 또한 &lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IBufferElementData.html">&lt;code>IBufferElementData&lt;/code> 인터페이스&lt;/a>를 구현해야 해요.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>IBufferElementData&lt;/code>를 구현하는 &lt;code>IntBufferElement&lt;/code> 구조체를 만들었어요. &lt;code>IComponentData&lt;/code>와 같은 흐름이죠?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">Unity.Entities&lt;/span>;
&lt;span style="color:#080;font-weight:bold">namespace&lt;/span> &lt;span style="color:#b06;font-weight:bold">DOTS_DynamicBuffer&lt;/span>
{
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">IntBufferElement&lt;/span> : IBufferElementData
{
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#888;font-weight:bold">int&lt;/span> Value;
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="entitymanageraddbuffertentitymanageraddbuffert-사용하기">&lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddBuffer__1_Unity_Entities_Entity_">&lt;code>EntityManager.AddBuffer&amp;lt;T&amp;gt;()&lt;/code>&lt;/a> 사용하기&lt;/h2>
&lt;p>엔티티에 컴포넌트를 더하는 방법과 같이 버퍼를 더할 때도 &lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html">&lt;code>EntityManager&lt;/code>&lt;/a>를 활용해요. 아래에서는 게임 오브젝트에 더해서 사용할 &lt;code>PlayModeTest&lt;/code>라는 컴포넌트를 작성하고 플레이 모드에서 &lt;em>Entity Debugger&lt;/em>를 확인해 볼게요.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>엔티티에 &lt;code>IntBufferElement&lt;/code> 버퍼를 더하고, 그 버퍼에 값을 좀 넣어 볼게요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">UnityEngine&lt;/span>;
&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">Unity.Entities&lt;/span>;
&lt;span style="color:#080;font-weight:bold">namespace&lt;/span> &lt;span style="color:#b06;font-weight:bold">DOTS_DynamicBuffer&lt;/span>
{
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">PlayModeTest&lt;/span> : MonoBehaviour
{
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">void&lt;/span> Awake()
{
&lt;span style="color:#888;font-weight:bold">var&lt;/span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
&lt;span style="color:#888;font-weight:bold">var&lt;/span> entity = entityManager.CreateEntity();
&lt;span style="color:#888;font-weight:bold">var&lt;/span> dynamicBuffer = entityManager.AddBuffer&amp;lt;IntBufferElement&amp;gt;(entity);
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement { Value = &lt;span style="color:#00d;font-weight:bold">1&lt;/span> });
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement { Value = &lt;span style="color:#00d;font-weight:bold">2&lt;/span> });
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement { Value = &lt;span style="color:#00d;font-weight:bold">3&lt;/span> });
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;em>DOTS_DynamicBufferScene&lt;/em>을 만들고 &lt;code>PlayModeTest&lt;/code> 스크립트를 같은 이름의 게임 오브젝트에 추가했어요.&lt;/p>
&lt;p>&lt;img src="images/01.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>플레이 모드에서 &lt;em>Entity Debugger&lt;/em> 를 통해서 &lt;code>PlayModeTest.Awake()&lt;/code> 메서드에서 생성한 엔티티를 확인할 수 있어요. &lt;code>IntBufferElement&lt;/code> 버퍼에 값이 세 개인 것이 보이시죠?&lt;/p>
&lt;p>&lt;img src="images/02.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="dynamicbuffertreinterpretudynamicbuffertreinterpretu-사용하기">&lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html#Unity_Entities_DynamicBuffer_1_Reinterpret__1">&lt;code>DynamicBuffer&amp;lt;T&amp;gt;.Reinterpret&amp;lt;U&amp;gt;()&lt;/code>&lt;/a> 사용하기&lt;/h2>
&lt;p>버퍼에 담긴 구조체가 포함하는 값을 직접 수정하는 방법을 알아 볼게요.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>PlayModeTest.Awake()&lt;/code> 메서드를 조금 수정해서 재해석이라는 의미의 &lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html#Unity_Entities_DynamicBuffer_1_Reinterpret__1">&lt;code>DynamicBuffer&amp;lt;T&amp;gt;.Reinterpret&amp;lt;U&amp;gt;()&lt;/code> 메서드&lt;/a>를 사용해 봤어요. 12번 줄에서와 같이 인덱스로 접근한 구조체는 변수로 분류되지 않는 임시 값이기 때문에 변경할 수 없는데, 14&amp;ndash;15번 줄에서와 같은 방법을 사용하면 값을 수정할 수 있어요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">void&lt;/span> Awake()
{
&lt;span style="color:#888;font-weight:bold">var&lt;/span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
&lt;span style="color:#888;font-weight:bold">var&lt;/span> entity = entityManager.CreateEntity();
&lt;span style="color:#888;font-weight:bold">var&lt;/span> dynamicBuffer = entityManager.AddBuffer&amp;lt;IntBufferElement&amp;gt;(entity);
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement {Value = &lt;span style="color:#00d;font-weight:bold">1&lt;/span>});
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement {Value = &lt;span style="color:#00d;font-weight:bold">2&lt;/span>});
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement {Value = &lt;span style="color:#00d;font-weight:bold">3&lt;/span>});
&lt;span style="color:#888">// ERROR: Indexer access returns temporary value.
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#888">// Cannot modify struct member when accessed struct is not classified as a variable
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#888">// dynamicBuffer[0].Value *= 10;
&lt;/span>&lt;span style="color:#888">&lt;/span>
&lt;span style="color:#888;font-weight:bold">var&lt;/span> intDynamicBuffer = dynamicBuffer.Reinterpret&amp;lt;&lt;span style="color:#888;font-weight:bold">int&lt;/span>&amp;gt;();
intDynamicBuffer[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>] *= &lt;span style="color:#00d;font-weight:bold">10&lt;/span>;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>값이 바뀌었는지 플레이 모드에서 확인해 볼게요. 잘 바뀌었네요! 15번 줄에서 변경한 &lt;code>intDynamicBuffer[0]&lt;/code>의 값을 &lt;code>dynamicBuffer[0]&lt;/code>에 다시 넣지 않았는데 버퍼의 값이 바뀐 것이 중요한 점으로 보여요.&lt;/p>
&lt;p>&lt;img src="images/03.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="entitymanagergetbuffertentitymanagergetbuffert-사용하기">&lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_GetBuffer__1_Unity_Entities_Entity_">&lt;code>EntityManager.GetBuffer&amp;lt;T&amp;gt;()&lt;/code>&lt;/a> 사용하기&lt;/h2>
&lt;p>엔티티의 버퍼에 접근하는 방법도 필요하겠죠?&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>PlayModeTest&lt;/code> 클래스를 수정했어요. &lt;code>Awake()&lt;/code> 메서드에서 생성한 엔티티와 이것에 추가한 버퍼를 &lt;code>Start()&lt;/code> 메서드에서 불러와서 값을 수정했어요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">PlayModeTest&lt;/span> : MonoBehaviour
{
&lt;span style="color:#080;font-weight:bold">private&lt;/span> Entity &lt;span style="color:#00d;font-weight:bold">_&lt;/span>entity;
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">void&lt;/span> Awake()
{
&lt;span style="color:#888;font-weight:bold">var&lt;/span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
&lt;span style="color:#00d;font-weight:bold">_&lt;/span>entity = entityManager.CreateEntity();
&lt;span style="color:#888;font-weight:bold">var&lt;/span> dynamicBuffer = entityManager.AddBuffer&amp;lt;IntBufferElement&amp;gt;(&lt;span style="color:#00d;font-weight:bold">_&lt;/span>entity);
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement { Value = &lt;span style="color:#00d;font-weight:bold">1&lt;/span> });
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement { Value = &lt;span style="color:#00d;font-weight:bold">2&lt;/span> });
dynamicBuffer.Add(&lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement { Value = &lt;span style="color:#00d;font-weight:bold">3&lt;/span> });
&lt;span style="color:#888">// ERROR: Indexer access returns temporary value.
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#888">// Cannot modify struct member when accessed struct is not classified as a variable
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#888">// dynamicBuffer[0].Value *= 10;
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#888;font-weight:bold">var&lt;/span> intDynamicBuffer = dynamicBuffer.Reinterpret&amp;lt;&lt;span style="color:#888;font-weight:bold">int&lt;/span>&amp;gt;();
intDynamicBuffer[&lt;span style="color:#00d;font-weight:bold">0&lt;/span>] *= &lt;span style="color:#00d;font-weight:bold">10&lt;/span>;
}
&lt;span style="color:#080;font-weight:bold">private&lt;/span> &lt;span style="color:#080;font-weight:bold">void&lt;/span> Start()
{
&lt;span style="color:#888;font-weight:bold">var&lt;/span> entityManger = World.DefaultGameObjectInjectionWorld.EntityManager;
&lt;span style="color:#888;font-weight:bold">var&lt;/span> dynamicBuffer = entityManger.GetBuffer&amp;lt;IntBufferElement&amp;gt;(&lt;span style="color:#00d;font-weight:bold">_&lt;/span>entity);
&lt;span style="color:#888;font-weight:bold">var&lt;/span> intDynamicBuffer = dynamicBuffer.Reinterpret&amp;lt;&lt;span style="color:#888;font-weight:bold">int&lt;/span>&amp;gt;();
&lt;span style="color:#080;font-weight:bold">for&lt;/span> (&lt;span style="color:#888;font-weight:bold">var&lt;/span> i = &lt;span style="color:#00d;font-weight:bold">0&lt;/span>; i &amp;lt; intDynamicBuffer.Length; i++)
{
intDynamicBuffer[i]++;
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>잘 동작하는지 확인할게요. 버퍼 내의 모든 값이 1씩 증가한 것이 보이네요! 여전히 신기한 &lt;code>Reinterpret&amp;lt;T&amp;gt;()&lt;/code>.&lt;/p>
&lt;p>&lt;img src="images/04.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="authoring">Authoring&lt;/h2>
&lt;p>&lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.GenerateAuthoringComponentAttribute.html">&lt;code>GenerateAuthoringComponentAttribute&lt;/code>&lt;/a>를 적용하면 게임 오브젝트에 Authoring Component를 더해서 엔티티로 만들 수 있죠. &lt;code>IBufferElementData&lt;/code>도 같은 방법을 사용할 수 있어요.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>IntBufferElement&lt;/code>를 수정해서 &lt;code>GenerateAuthoringComponentAttribute&lt;/code>를 적용할게요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#369">[GenerateAuthoringComponent]&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">IntBufferElement&lt;/span> : IBufferElementData
{
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#888;font-weight:bold">int&lt;/span> Value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>그리고 Scene을 수정해서 자동으로 생성된 &lt;code>IntBufferElementAuthoring&lt;/code> 컴포넌트를 게임 오브젝트에 더하고 값을 넣어 봤어요. 그리고 게임 오브젝트의 엔티티화를 위해서 &lt;code>ConvertToEntity&lt;/code> 컴포넌트를 더했어요.&lt;/p>
&lt;p>&lt;img src="images/05.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Entity Debugger&lt;/em>로 보면 &lt;strong>Authoring&lt;/strong> 컴포넌트가 더해져 있던 게임 오브젝트와 같은 이름의 엔티티가 생성된 것을 확인할 수 있어요.&lt;/p>
&lt;p>&lt;img src="images/06.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>이후 과정을 위해 &lt;code>UnitTag&lt;/code>와 &lt;code>PlayerTag&lt;/code>, &lt;code>EnemyTag&lt;/code> 컴포넌트를 작성해서 각 컴포넌트를 포함하는 엔티티에 &lt;code>IntBufferElement&lt;/code> 버퍼를 더해 볼게요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">Unity.Entities&lt;/span>;
&lt;span style="color:#080;font-weight:bold">namespace&lt;/span> &lt;span style="color:#b06;font-weight:bold">DOTS_DynamicBuffer&lt;/span>
{
&lt;span style="color:#369"> [GenerateAuthoringComponent]&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">UnitTag&lt;/span> : IComponentData { }
&lt;span style="color:#369">
&lt;/span>&lt;span style="color:#369"> [GenerateAuthoringComponent]&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">PlayerTag&lt;/span> : IComponentData { }
&lt;span style="color:#369">
&lt;/span>&lt;span style="color:#369"> [GenerateAuthoringComponent]&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">EnemyTag&lt;/span> : IComponentData { }
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="images/07.png" alt="">&lt;/p>
&lt;p>&lt;img src="images/08.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="componentsystem에서-사용하기">&lt;code>ComponentSystem&lt;/code>에서 사용하기&lt;/h2>
&lt;p>&lt;code>ComponentSystem&lt;/code>을 상속하는 시스템을 작성해서 &lt;code>UnitTag&lt;/code> 컴포넌트를 포함하는 엔티티의 &lt;code>IntBufferElement&lt;/code> &lt;code>DynamicBuffer&lt;/code>에 접근해 볼게요.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>TestBufferFromEntitySystem&lt;/code>을 작성했어요. &lt;code>UnitTag&lt;/code>를 포함하는 엔티티들의 &lt;code>IntBufferElement&lt;/code>형 &lt;code>DynamicBuffer&lt;/code>에 접근해서 값을 변경하는 로직이에요. 20번 줄과 같이 사용하는 것은 안 되니 23&amp;ndash;28번 줄과 같이 사용해요. 물론 &lt;code>Reinterpret&amp;lt;T&amp;gt;()&lt;/code>도 사용할 수 있겠죠?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">Unity.Entities&lt;/span>;
&lt;span style="color:#080;font-weight:bold">namespace&lt;/span> &lt;span style="color:#b06;font-weight:bold">DOTS_DynamicBuffer&lt;/span>
{
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">TestBufferFromEntitySystem&lt;/span> : ComponentSystem
{
&lt;span style="color:#080;font-weight:bold">protected&lt;/span> &lt;span style="color:#080;font-weight:bold">override&lt;/span> &lt;span style="color:#080;font-weight:bold">void&lt;/span> OnUpdate()
{
&lt;span style="color:#888;font-weight:bold">var&lt;/span> bufferFromEntity = GetBufferFromEntity&amp;lt;IntBufferElement&amp;gt;();
Entities
.WithAll&amp;lt;UnitTag&amp;gt;()
.ForEach(entity =&amp;gt;
{
&lt;span style="color:#080;font-weight:bold">if&lt;/span> (bufferFromEntity.Exists(entity))
{
&lt;span style="color:#888;font-weight:bold">var&lt;/span> dynamicBufferFromUnitTag = bufferFromEntity[entity];
&lt;span style="color:#080;font-weight:bold">foreach&lt;/span> (&lt;span style="color:#888;font-weight:bold">var&lt;/span> intBufferElement &lt;span style="color:#080;font-weight:bold">in&lt;/span> dynamicBufferFromUnitTag)
{
&lt;span style="color:#888">// Foreach iteration variable &amp;#39;intBufferElement&amp;#39; is immutable.
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#888">// Cannot modify struct member when accessed struct is not classified as a variable
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#888">// intBufferElement.Value++;
&lt;/span>&lt;span style="color:#888">&lt;/span> }
&lt;span style="color:#080;font-weight:bold">for&lt;/span> (&lt;span style="color:#888;font-weight:bold">var&lt;/span> i = &lt;span style="color:#00d;font-weight:bold">0&lt;/span>; i &amp;lt; dynamicBufferFromUnitTag.Length; i++)
{
&lt;span style="color:#888;font-weight:bold">var&lt;/span> intBufferElement = dynamicBufferFromUnitTag[i];
intBufferElement.Value++;
dynamicBufferFromUnitTag[i] = intBufferElement;
}
}
});
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>플레이 모드에서 &lt;em>Entity Debugger&lt;/em>를 보면 &lt;code>UnitTag&lt;/code> 컴포넌트를 포함하는 엔티티의 &lt;code>IntBufferElement&lt;/code> &lt;code>DynamicBuffer&lt;/code>의 값이 변하는 것을 확인할 수 있어요.&lt;/p>
&lt;p>&lt;img src="images/09.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="jobcomponentsystem에서-사용하기">&lt;code>JobComponentSystem&lt;/code>에서 사용하기&lt;/h2>
&lt;p>&lt;code>JobComponentSystem&lt;/code>을 상속하는 시스템을 작성해서 &lt;code>PlayerTag&lt;/code> 컴포넌트를 포함하는 엔티티의 &lt;code>IntBufferElement&lt;/code> &lt;code>DynamicBuffer&lt;/code>에 접근해 볼게요.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>TestBufferFromEntityJobSystem&lt;/code>을 작성했어요. &lt;code>PlayerTag&lt;/code>를 포함하는 엔티티들의 &lt;code>IntBufferElement&lt;/code>형 &lt;code>DynamicBuffer&lt;/code>에 접근해서 값을 변경하는 로직이에요. 이번에는 &lt;code>Reinterpret&amp;lt;T&amp;gt;()&lt;/code>를 사용해 봤어요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">Unity.Entities&lt;/span>;
&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">Unity.Jobs&lt;/span>;
&lt;span style="color:#080;font-weight:bold">namespace&lt;/span> &lt;span style="color:#b06;font-weight:bold">DOTS_DynamicBuffer&lt;/span>
{
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">class&lt;/span> &lt;span style="color:#b06;font-weight:bold">TestBufferFromEntityJobSystem&lt;/span> : JobComponentSystem
{
&lt;span style="color:#080;font-weight:bold">protected&lt;/span> &lt;span style="color:#080;font-weight:bold">override&lt;/span> JobHandle OnUpdate(JobHandle inputDeps)
{
&lt;span style="color:#080;font-weight:bold">return&lt;/span> Entities
.WithAll&amp;lt;PlayerTag&amp;gt;()
.ForEach((&lt;span style="color:#080;font-weight:bold">ref&lt;/span> DynamicBuffer&amp;lt;IntBufferElement&amp;gt; dynamicBuffer) =&amp;gt;
{
&lt;span style="color:#888;font-weight:bold">var&lt;/span> intDynamicBuffer = dynamicBuffer.Reinterpret&amp;lt;&lt;span style="color:#888;font-weight:bold">int&lt;/span>&amp;gt;();
&lt;span style="color:#080;font-weight:bold">for&lt;/span> (&lt;span style="color:#888;font-weight:bold">var&lt;/span> i = &lt;span style="color:#00d;font-weight:bold">0&lt;/span>; i &amp;lt; intDynamicBuffer.Length; i++)
{
intDynamicBuffer[i]++;
}
})
.Schedule(inputDeps);
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>잘 동작하네요! 값이 쭉쭉 올라가고 있어요.&lt;/p>
&lt;p>&lt;img src="images/10.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="팁들">팁들&lt;/h2>
&lt;h3 id="internalbuffercapacityattributeinternalbuffercapacityattribute">&lt;a href="https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.InternalBufferCapacityAttribute.html">&lt;code>InternalBufferCapacityAttribute&lt;/code>&lt;/a>&lt;/h3>
&lt;p>엔티티는 기본적으로 청크에 포함되는데, &lt;code>IBufferElementData&lt;/code>를 구현하는 구조체에 &lt;code>InternalBufferCapacityAttribute&lt;/code>를 적용하면 청크 내 존재할 수 있는 최대 요소 수를 지정할 수 있어요. 지정한 요소 수를 넘어서면 해당 버퍼는 힙 메모리로 이동해요. 물론 이때에도 이전과 같이 &lt;code>DynamicBuffer&lt;/code> API로 해당 버퍼에 접근할 수 있어요.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>요소 수를 2개로 설정해 봤어요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#888">// InternalBufferCapacity specifies how many elements a buffer can have before
&lt;/span>&lt;span style="color:#888">// the buffer storage is moved outside the chunk.
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#369">[InternalBufferCapacity(2)]&lt;/span>
&lt;span style="color:#369">[GenerateAuthoringComponent]&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">IntBufferElement&lt;/span> : IBufferElementData
{
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#888;font-weight:bold">int&lt;/span> Value;
}
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>그리고 같은 청크에서 테스트하기 위해서 &lt;code>EnemyTag&lt;/code>를 포함하는 Enemy 게임 오브젝트를 두 개 더 복재했어요.&lt;/p>
&lt;p>&lt;img src="images/11.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Entity Debugger&lt;/em>를 확인해 봤어요. 그런데 &lt;code>IntBufferElement&lt;/code>가 여전히 청크에 남아 있는 것 처럼 보이네요. 힙 메모리로 이동됐어도 편의를 위해서 이렇게 보여주는 것인지는 확인이 필요하겠어요.&lt;/p>
&lt;p>&lt;img src="images/12.png" alt="">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="implicit-연산자">&lt;code>implicit&lt;/code> 연산자&lt;/h3>
&lt;p>편의를 위해서 이렇게 작성해서 사용할 수도 있겠죠?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-cs" data-lang="cs">&lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">Unity.Entities&lt;/span>;
&lt;span style="color:#080;font-weight:bold">namespace&lt;/span> &lt;span style="color:#b06;font-weight:bold">DOTS_DynamicBuffer&lt;/span>
{
&lt;span style="color:#888">// InternalBufferCapacity specifies how many elements a buffer can have before
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#888">// the buffer storage is moved outside the chunk.
&lt;/span>&lt;span style="color:#888">&lt;/span>&lt;span style="color:#369"> [InternalBufferCapacity(2)]&lt;/span>
&lt;span style="color:#369"> [GenerateAuthoringComponent]&lt;/span>
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">struct&lt;/span> &lt;span style="color:#b06;font-weight:bold">IntBufferElement&lt;/span> : IBufferElementData
{
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#888;font-weight:bold">int&lt;/span> Value;
&lt;span style="color:#888">// The following implicit conversions are optional, but can be convenient.
&lt;/span>&lt;span style="color:#888">&lt;/span> &lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#080;font-weight:bold">implicit&lt;/span> &lt;span style="color:#080;font-weight:bold">operator&lt;/span> &lt;span style="color:#888;font-weight:bold">int&lt;/span>(IntBufferElement e)
{
&lt;span style="color:#080;font-weight:bold">return&lt;/span> e.Value;
}
&lt;span style="color:#080;font-weight:bold">public&lt;/span> &lt;span style="color:#080;font-weight:bold">static&lt;/span> &lt;span style="color:#080;font-weight:bold">implicit&lt;/span> &lt;span style="color:#080;font-weight:bold">operator&lt;/span> IntBufferElement(&lt;span style="color:#888;font-weight:bold">int&lt;/span> e)
{
&lt;span style="color:#080;font-weight:bold">return&lt;/span> &lt;span style="color:#080;font-weight:bold">new&lt;/span> IntBufferElement { Value = e };
}
}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>&lt;code>IBufferElementData&lt;/code>와 &lt;code>DynamicBuffer&amp;lt;T&amp;gt;&lt;/code>를 가볍게 알아 봤어요.&lt;/p>
&lt;p>게임을 만들 때 오브젝트 풀링에 대해서 수도 없이 많이 들어 보셨을 거예요. 1회용 객체를 생성하는 것은 쓰레기를 만드는 것이기에 풀링해서 재사용하면 잦은 &lt;a href="https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)">쓰레기 수집&lt;/a>을 줄이고 인스턴스 생성 타이밍을 관리할 수 있어서 더욱 부드러운 게임을 만들 수 있죠.&lt;/p>
&lt;p>다음에는 이 기능을 게임에 어떻게 적용하는지 알아보고, 적용하기 전과 후를 비교하면서 어느정도 효과를 얻을 수 있는지 확인해 볼게요.&lt;/p></content><author><name>현승민</name><uri>https://github.com/boscohyun</uri><email>seungmin@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.9 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/04/libplanet-0.9/" title="Libplanet 0.9 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/04/libplanet-0.9/" hreflang="en" title="Libplanet 0.9 Released"/><id>https://snack.planetarium.dev/kor/2020/04/libplanet-0.9/</id><published>2020-04-28T00:00:00+00:00</published><updated>2020-04-28T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 아홉 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.9.0">0.9 버전&lt;/a>이
릴리스되었습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&lt;/p>
&lt;p>이번 버전부터 Libplanet은 여러 NuGet 패키지로 배포되는데요.
Libplanet의 외연이 확장되어 일부 의존 라이브러리를 모든 애플리케이션에서
포함하기에는 무거워졌기 때문입니다.&lt;/p>
&lt;p>이 글에서는 0.9 버전의 새로운 NuGet 패키지들을 소개하며 주요 변경 사항들에
대해서도 다루겠습니다.&lt;/p>
&lt;h2 id="libplanetrocksdbstore">&lt;a href="https://www.nuget.org/packages/Libplanet.RocksDBStore/">Libplanet.RocksDBStore&lt;/a>&lt;/h2>
&lt;p>Libplanet.RocksDBStore는 새로 추가된 NuGet 패키지로,
Lipblanet의 &lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Store.IStore.html">&lt;code>IStore&lt;/code> 인터페이스&lt;/a>를 &lt;a href="https://rocksdb.org/">RocksDB&lt;/a> 백엔드로 구현한
&lt;code>RocksDBStore&lt;/code> 클래스를 포함합니다. &lt;code>RocksDBStore&lt;/code>는 내부 테스트 결과 기존의
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Store.DefaultStore.html">&lt;code>DefaultStore&lt;/code>&lt;/a>에 비해 쓰기는 약 10배 읽기는 약 2배 이상
빨라졌으며, 압축 등의 효과 덕에 기존에 비해 15% 이하의 저장 공간만을 차지하게
됐습니다.&lt;/p>
&lt;p>위와 같은 장점에도, C++로 작성된 RocksDB 네이티브 바이너리를 애플리케이션과
함께 배포해야 하기 때문에 일부 플랫폼에서는 이용이 곤란할 수 있습니다.
따라서 &lt;code>RocksDBStore&lt;/code> 클래스는 Libplanet 패키지가 아닌
Libplanet.RocksDBStore라는 별도 NuGet 패키지로 배포하게 되었으며,
Libplanet 패키지에는 여전히 &lt;code>DefaultStore&lt;/code>가 제공됩니다. 따라서 개발할 때는
설치가 간편한 &lt;code>DefaultStore&lt;/code>를 쓰고 테스트 및 실제 배포시에만 &lt;code>RocksDBStore&lt;/code>를
쓰거나, RocksDB 바이너리를 제공하기 어려운 플랫폼에 한해 &lt;code>DefaultStore&lt;/code>를 쓰는
식의 활용이 가능합니다.&lt;/p>
&lt;p>자세한 내용은 이승훈 님이 쓰신 &lt;a href="https://snack.planetarium.dev/kor/2020/04/rocksdb/">Libplanet RocksDB 적용기&lt;/a>에서 볼 수 있습니다.&lt;/p>
&lt;h2 id="여러-피어로부터-블록-받기">여러 피어로부터 블록 받기&lt;/h2>
&lt;p>이제까지 &lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.Swarm-1.html">&lt;code>Swarm&amp;lt;T&amp;gt;&lt;/code> 클래스&lt;/a>의 &lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_PreloadAsync_System_Nullable_TimeSpan__IProgress_Libplanet_Net_PreloadState__IImmutableSet_Libplanet_Address__EventHandler_Libplanet_Net_PreloadBlockDownloadFailEventArgs__CancellationToken_">&lt;code>PreloadAsync()&lt;/code>&lt;/a> 및
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_StartAsync_TimeSpan_TimeSpan_CancellationToken_">&lt;code>StartAsync()&lt;/code> 메서드&lt;/a>는 네트워크에 쌓인 블록을 따라잡기
위해 하나의 피어에게 그간의 모든 블록을 요청하여 받게 되어 있었습니다.
쌓인 블록이 많을 경우 하나의 피어에게만 받다 보니 오래 걸리기 일쑤였고,
운이 안 좋으면 서로 통신이 아주 느린 피어에게 블록을 요청해 받기까지 아주 오래
걸리는 경우도 있었습니다. 블록을 보내주는 쪽에서도 홀로 큰 부담을 져야 하는데,
배포되는 애플리케이션에 기본값으로 설정된 시드 노드의 경우 그 부담이 무시하기
힘들 정도였습니다.&lt;/p>
&lt;p>이번 버전부터는 블록을 여러 피어에게 고루 받도록 개선되었으며, 그 가운데
특별히 느린 피어가 끼더라도 전체 블록을 받는 시간이 크게 늦어지는 일도
크게 줄었습니다.&lt;/p>
&lt;h2 id="서명된-앱-프로토콜-버전">서명된 앱 프로토콜 버전&lt;/h2>
&lt;p>지난해, &lt;a href="https://snack.planetarium.dev/kor/2019/05/libplanet-0.3/#%EB%B2%84%EC%A0%84%EC%9D%B4-%EB%8B%A4%EB%A5%B8-%EB%85%B8%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%82%AC%EC%9D%84-%EB%95%8C-%EB%B0%98%EC%9D%91%ED%95%98%EB%8A%94-api">Libplanet 0.3에는 &lt;code>Swarm&amp;lt;T&amp;gt;()&lt;/code> 생성자에 &lt;code>appProtocolVersion&lt;/code> 매개변수가
추가됐습니다.&lt;/a> 서로 프로토콜이 호환되는 노드끼리만 통신하고, 호환되지
않는 경우의 처리를 앱에 따라 적절히 처리할 수 있도록 한 것입니다.&lt;/p>
&lt;p>저희 팀 역시 이 기능을 활용했고, 더 높은 버전의 노드와 조우할 경우 소프트웨어
업데이트를 유도하는 용도로 썼습니다. 그러나 이렇게 활용하니, 변조된
소프트웨어가 악의적으로 (실제로는 발표된 적 없는) 높은 버전 숫자를 내보이게
하여 다른 노드들이 거짓 소프트웨어 업데이트를 시도하도록 공격하는 데에 쓰일
수 있다는 것을 알게 됐습니다.&lt;/p>
&lt;p>이러한 일을 피할 수 있도록, &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.int32">&lt;code>System.Int32&lt;/code>&lt;/a>로 표현되던
앱 프로토콜 버전은 이제 서명과 서명자 등 여러 메타데이터를 포함하는
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.AppProtocolVersion.html">&lt;code>AppProtocolVersion&lt;/code> 자료형&lt;/a>으로
바뀌었습니다. 앱 프로토콜 버전은 서명되어야 하며, 각 노드는 &lt;code>Swarm&amp;lt;T&amp;gt;()&lt;/code>
생성자의 &lt;code>trustedAppProtocolVersionSigners&lt;/code> 매개변수로 어떤 서명자의
앱 프로로콜 버전을 신뢰할지 &lt;em>각자&lt;/em> 정하게 됩니다.&lt;/p>
&lt;p>이러한 방식은 각 노드들을 의도하지 않은 (변조된) 소프트웨어 업데이트로부터
보호하는 동시에, 각 노드들이 원한다면 자유롭게 포크된 다른 애플리케이션 로드맵을
선택할 자유도 제공합니다.&lt;/p>
&lt;h2 id="키-저장소">키 저장소&lt;/h2>
&lt;p>지난해, &lt;a href="https://snack.planetarium.dev/kor/2019/11/libplanet-0.7/#%EA%B0%9C%EC%9D%B8%ED%82%A4%EB%A5%BC-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EC%A0%80%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%ED%82%A4-%EC%A0%80%EC%9E%A5%EC%86%8C-%EA%B5%AC%ED%98%84">Libplanet은 0.7 버전에서 &lt;code>PrivateKey&lt;/code>를 안전하게 저장할 수 있는
&lt;code>ProtectedPrivateKey&lt;/code> 클래스가 추가됐습니다.&lt;/a> 그렇지만
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.KeyStore.ProtectedPrivateKey.html">&lt;code>ProtectedPrivateKey&lt;/code>&lt;/a>는 하나의 키만 다룰 뿐으로,
여러 키를 다루려면 애플리케이션 측에서 디렉터리를 만들고 파일명을 결정하고
파일에 쓰는 등의 처리를 알아서 구현해야 했습니다.&lt;/p>
&lt;p>이번 버전에부터는 키를 물리적으로 보존하고 관리하는 기능인
&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.KeyStore.Web3KeyStore.html">&lt;code>Web3KeyStore&lt;/code>&lt;/a> 클래스가 제공되기 때문에, 더이상 그런 처리를
직접 구현할 필요가 없어졌습니다. 파일 시스템에 &lt;a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3 Secret Storage Definition&lt;/a>
형식으로 키를 보존하는 &lt;code>Web3KeyStore&lt;/code>와 더불어, 그러한 구체적인 보존 방식(구현
세부사항)을 추상화하는 &lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.KeyStore.IKeyStore.html">&lt;code>IKeyStore&lt;/code> 인터페이스&lt;/a> 역시 도입됐습니다.&lt;/p>
&lt;h2 id="planet-명령행-도구">&lt;code>planet&lt;/code>: 명령행 도구&lt;/h2>
&lt;p>&lt;a href="https://docs.libplanet.io/0.9.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1__ctor_Libplanet_Blockchain_BlockChain__0__Libplanet_Crypto_PrivateKey_Libplanet_Net_AppProtocolVersion_System_Int32_System_String_System_Nullable_System_Int32__IEnumerable_Libplanet_Net_IceServer__Libplanet_Net_DifferentAppProtocolVersionEncountered_IEnumerable_Libplanet_Crypto_PublicKey__">&lt;code>Swarm&amp;lt;T&amp;gt;()&lt;/code> 생성자&lt;/a>는 &lt;a href="https://snack.planetarium.dev/kor/2020/02/libplanet-0.8/#%EC%A0%9C%EB%84%88%EC%8B%9C%EC%8A%A4-%EB%B8%94%EB%A1%9D-%EC%83%81%EC%A0%95">지난 버전부터 특정 제너시스 블록을 상정하게
됐고&lt;/a>, &lt;a href="#%EC%84%9C%EB%AA%85%EB%90%9C-%EC%95%B1-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B2%84%EC%A0%84">이번 버전부터는 앱 프로토콜 버전을 서명하게 됐습니다.&lt;/a> 이와 같은
값들은 암호학 알고리즘의 결과를 포함하기 때문에, 사람이 임의로 아무 값이나
넣을 수 없습니다. 그렇지만 개발 과정에서는 임의의 값들을 채워봐야 할 일이 많기
때문에, 이 때마다 Libplanet API를 C# 대화형 셸이나 PowerShell 등에서 호출하여
원하는 값을 계산하는 것은 그것대로 여간 번거로운 일이 아니었습니다.&lt;/p>
&lt;p>이러한 작업을 좀더 쉽게 할 수 있도록, 이번 버전부터는 &lt;code>planet&lt;/code>이라는
명령행(&lt;abbr title="command-line interface">CLI&lt;/abbr>) 도구를 함께 배포합니다.
&lt;code>planet&lt;/code> 명령은 여러 서브커맨드를 포함하며, 현재로서는 키 저장소 관리와
앱 프로토콜 버전의 서명 기능을 제공합니다. 이후 임의의 제너시스 블록 생성 등의
기능도 추가될 예정입니다. 자세한 사용법은 &lt;code>planet --help&lt;/code> 명령을 확인해 주세요.&lt;/p>
&lt;p>&lt;code>planet&lt;/code> 명령은 &lt;a href="https://www.nuget.org/packages/Libplanet.Tools/">Libplanet.Tools&lt;/a>라는 NuGet 패키지로 배포되며, .NET Core SDK가
설치된 시스템에서 아래와 같이 설치할 수 있습니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-bash" data-lang="bash">dotnet tool install -g Libplanet.Tools
&lt;/code>&lt;/pre>&lt;/div>&lt;p>.NET Core SDK가 설치되지 않은 환경이라면 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.9.0">릴리스 페이지&lt;/a>에 첨부된
공식 바이너리를 받아서 설치할 수도 있습니다. 공식 바이너리는 Linux (x64),
macOS (x64), Windows (x64) 세 플랫폼의 버전이 제공되고 있습니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 밖의 여러 변경 사항은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.9.0">전체 변경 내용&lt;/a>에서 확인하실 수 있습니다.&lt;/p>
&lt;p>호기심이 생기신 분들은 설치해서 이용해 보시고, 궁금한 점이 있으시다면 저희 팀이
상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드&lt;/a>에도 놀러오세요!&lt;/p></content><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry><entry><title>Libplanet RocksDB 적용기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/04/rocksdb/" title="Libplanet RocksDB 적용기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/04/rocksdb/" hreflang="en" title="Applying RocksDB to Libplanet"/><id>https://snack.planetarium.dev/kor/2020/04/rocksdb/</id><published>2020-04-17T00:00:00+00:00</published><updated>2020-04-17T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 플라네타리움에서 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>을 만들고 있는 이승훈입니다.&lt;/p>
&lt;p>Libplanet에서는 &lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Store.IStore.html">&lt;code>IStore&lt;/code>&lt;/a>라는 저장계층 추상화 인터페이스와 기본 구현인 &lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Store.DefaultStore.html">&lt;code>DefaultStore&lt;/code>&lt;/a>를 제공하고 있고, Libplanet을 이용하여 만들고 있는 게임 &lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>도 이를 쓰고 있었습니다. &lt;code>DefaultStore&lt;/code>는 Libplanet에 기본으로 포함되어 곧바로 쓸 수 있다는 장점이 있었지만, 성능이나 저장 공간 효율 측면에서 한계가 있었습니다.&lt;/p>
&lt;p>이에 따라 저희는 여러 대안 저장 방식을 검토한 끝에 Facebook에서 제작한 &lt;a href="https://ko.wikipedia.org/wiki/%ED%82%A4-%EA%B0%92_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">키–값 데이터베이스&lt;/a> 라이브러리인 &lt;a href="https://rocksdb.org/">RocksDB&lt;/a>가 적합하다고 판단했고, 이를 백엔드로 사용하는 &lt;code>IStore&lt;/code> 구현체인 &lt;a href="https://github.com/planetarium/libplanet/blob/master/Libplanet.RocksDBStore/RocksDBStore.cs">&lt;code>RocksDBStore&lt;/code>&lt;/a>를 만들기로 했습니다. 이번 글에서는 &lt;code>RocksDBStore&lt;/code>를 만들면서 경험한 일들을 공유하려고 합니다.&lt;/p>
&lt;h2 id="의존하는-라이브러리-포함시키기1">의존하는 라이브러리 포함시키기&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/h2>
&lt;p>RocksDB는 압축이나 메모리 할당을 위해 또다른 라이브러리들에 의존합니다. &lt;a href="https://github.com/facebook/rocksdb/wiki/Building-on-Windows">Windows 빌드&lt;/a>와 다르게 macOS와 Linux의 경우 RocksDB 네이티브 라이브러리를 동적 링크 라이브러리 형태(&lt;em>.so&lt;/em> 및 &lt;em>.dylib&lt;/em>)로 사용하기 위해서는 RocksDB가 의존하는 라이브러리들도 시스템에 설치되어 있어야 합니다.&lt;/p>
&lt;p>일반적인 서버 앱에서는 시스템에 모든 의존 라이브러리들을 다 설치하는 것이 자연스러운 일입니다. 서버 앱을 구동하는 시스템은 보통 그 서버 앱만을 위해 운영되기 때문입니다. 하지만 저희는 블록체인 노드인 동시에 게이머의 시스템에서 돌아가는 앱을 만들고 있기 때문에 모든 게이머에게 이런 라이브러리들을 따로 설치하라고 요구하는 건 어려웠습니다.&lt;/p>
&lt;p>그래서 생각한 것이 게임 클라이언트 내에 RocksDB가 의존하는 라이브러리들도 함께 넣어 배포하는 것이었습니다. 하지만 별도의 수정 없이 가이드대로 RocksDB를 동적 링크 라이브러리 형태로 빌드할 경우, 빌드된 RocksDB 라이브러리에서 게임 클라이언트에 함께 포함된 의존 라이브러리들을 찾지 못하는 문제가 있었습니다.&lt;/p>
&lt;p>이 문제를 해결하기 위해 RocksDB 동적 링크 라이브러리 파일의 &lt;a href="https://en.wikipedia.org/wiki/Rpath">rpath&lt;/a>를 수정하는 방식을 사용했습니다. rpath란 &lt;q>run-time search path&lt;/q>를 가리키는 말로, 라이브러리 파일이나 실행 파일 내에 하드코딩 되어서 &lt;a href="https://en.wikipedia.org/wiki/Dynamic_linker">동적 링킹&lt;/a> &lt;a href="https://ko.wikipedia.org/wiki/%EB%A1%9C%EB%8D%94_(%EC%BB%B4%ED%93%A8%ED%8C%85)">로더&lt;/a>가 해당 파일에서 필요한 라이브러리를 찾기 위한 경로입니다. 처음에는 RocksDB 라이브러리를 빌드할때 rpath를 수정하는 방법을 고려했지만 RocksDB의 빌드 스크립트가 생각보다 복잡해 보였기 때문에 빌드가 완료된 라이브러리 파일의 rpath를 수정하기로 했습니다. 다행히 macOS에서는 &lt;a href="https://www.unix.com/man-page/osx/1/install_name_tool/">&lt;code>install_name_tool&lt;/code>&lt;/a>, Linux에서는 &lt;a href="https://github.com/NixOS/patchelf">&lt;code>patchelf&lt;/code>&lt;/a>라는 툴로 다음과 같이 간단하게 rpath를 현재 RocksDB 라이브러리가 존재하는 디렉터리로 수정할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-bash" data-lang="bash">&lt;span style="color:#888"># macOS&lt;/span>
$ install_name_tool -add_rpath &lt;span style="color:#d20;background-color:#fff0f0">&amp;#39;@loader_path&amp;#39;&lt;/span> librocksdb.dylib
&lt;span style="color:#888"># linux&lt;/span>
$ patchelf --set-rpath &lt;span style="color:#369">$ORIGIN&lt;/span> librocksdb.so
&lt;/code>&lt;/pre>&lt;/div>&lt;p>rpath 수정에 관한 보다 자세한 내용은 제가 참조한 아래 페이지들을 참조하시면 좋을 것 같습니다.&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://medium.com/@donblas/fun-with-rpath-otool-and-install-name-tool-e3e41ae86172">Fun with rpath, otool, and install_name_tool&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mindonmind.github.io/notes/linux/change_rpath.html">Change Library Search Path For Binary Files in Linux&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="애플리케이션에서의-데이터베이스-기능-구현">애플리케이션에서의 데이터베이스 기능 구현&lt;/h2>
&lt;p>RocksDB는 흔히 사용되는 &lt;a href="https://ko.wikipedia.org/wiki/%EA%B4%80%EA%B3%84%ED%98%95_%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4">관계형 데이터베이스&lt;/a>나 &lt;code>DefaultStore&lt;/code>에서 사용하고 있는 &lt;a href="https://www.litedb.org/">LiteDB&lt;/a>등과는 다르게 비교적 단순한 기능만을 지원합니다. 따라서 앞에서 얘기한 데이터베이스에서는 당연하게 지원하는 기능들도 RocksDB를 사용할 때는 애플리케이션에서 직접 구현을 해야 하는 경우가 종종 있습니다.&lt;/p>
&lt;p>대표적으로 저장된 데이터 열(rows)의 갯수를 세는 기능이 존재하지 않기 때문에, 데이터를 업데이트할 때마다 개수를 따로 저장해 놓거나 매번 데이터를 순회하면서 세는 등 여러 방식을 이용하여 해당 기능을 직접 구현해야 합니다.&lt;/p>
&lt;p>또 다른 예로는 키 검색 기능이 있습니다. RocksDB의 &lt;code>Seek&lt;/code>은 키의 첫머리(prefix)를 입력으로 받아서 해당하는 키의 위치를 찾아줍니다. 일반적인 데이터베이스의 키 검색 기능처럼 첫머리가 일치하는 키만 검색될 거라고 기대하기 쉽지만, 일반적인 데이터베이스에서의 검색보다는 파일의 오프셋을 이동하는 &lt;a href="http://man7.org/linux/man-pages/man2/lseek.2.html">&lt;code>lseek()&lt;/code>&lt;/a>와 좀 더 유사한 기능을 합니다. 따라서 이 기능을 이용해서 키를 순회할 때는 매 키 마다 해당 키의 첫머리가 내가 찾는 부분 문자열과 일치하는지 검사해야 합니다.&lt;/p>
&lt;h2 id="문서를-자세히-보지-않으면-하기-쉬운-실수들">문서를 자세히 보지 않으면 하기 쉬운 실수들&lt;/h2>
&lt;p>RocksDB의 API와 문서화는 기대했던 것에 비해 친절하게 되어있는 편은 아니어서 사용하는 데 약간의 주의가 필요했습니다.&lt;/p>
&lt;p>한 예로 RocksDB는 네임스페이스와 같은 역할을 하는 &lt;a href="https://github.com/facebook/rocksdb/wiki/Column-Families">칼럼 패밀리&lt;/a>(Column Family)가 있습니다. 이 칼럼 패밀리를 데이터베이스에 만들어두면 다음번에 데이터베이스를 사용할 때도 알아서 함께 가져올 것을 기대했지만, 기대와는 달리 데이터베이스를 열 때 &lt;code>ListColumnFamilies&lt;/code>라는 API를 이용해서 데이터베이스내의 모든 칼럼 패밀리를 명시해주지 않으면 예외가 발생하는 문제가 있었습니다.&lt;/p>
&lt;p>또 RocksDB는 문서화에 GitHub의 위키를 이용하는데, 버전별로 문서가 나뉘어있는 등의 정리는 따로 되어 있지 않습니다. 예를 들어 &lt;a href="https://github.com/facebook/rocksdb/wiki/Prefix-Seek">prefix seek&lt;/a>에 대한 문서를 보면 사용법이 변경에 따라 계속 추가되는데, 최신 사용법은 문서의 마지막에 기록되어 있어서 문서의 첫 부분만 볼 경우 예전 사용법대로 사용하기가 쉽습니다.&lt;/p>
&lt;h2 id="바인딩-라이브러리의-문제">바인딩 라이브러리의 문제&lt;/h2>
&lt;p>마지막은 RocksDB의 C# 바인딩 라이브러리인 &lt;a href="https://github.com/warrenfalk/rocksdb-sharp">rocksdb-sharp&lt;/a>에 관한 내용입니다.&lt;/p>
&lt;p>&lt;code>RocksDBStore&lt;/code>코드중 rocksdb-sharp의 &lt;code>RocksDBException&lt;/code> 예외를 잡아서 처리하는 코드가 있습니다. 그런데 일부 플랫폼에서는 이 예외를 처리하는 도중 아래와 같은 엉뚱한 예외가 발생하는 경우가 있었습니다.&lt;/p>
&lt;pre>&lt;code>ExecutionEngineException: String conversion error: Illegal byte sequence encounted in the input.
&lt;/code>&lt;/pre>
&lt;p>코드를 살펴본 결과 이는 rocksdb-sharp에서 RocksDB에서 발생한 에러메시지를 인코딩할 때 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringansi?view=netframework-4.8">&lt;code>Marshal.PtrToStringAnsi()&lt;/code>&lt;/a> 메서드를 사용했기 때문에 발생한 문제였습니다. 저희는 위에서 얘기한 라이브러리 의존성 문제를 해결하기 위해 rocksdb-sharp을 포크해서 사용하고 있었기 때문에 해당 부분에 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.runtime.interopservices.marshal.ptrtostringuni?view=netframework-4.8">&lt;code>Marshal.PtrToStringUni()&lt;/code>&lt;/a> 메서드를 사용하도록 변경함으로써 어렵지 않게 해당 문제를 해결할 수 있었습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>여러 과정을 거치며 RocksDB를 도입하고 저장공간이나 속도 측면에서 향상을 경험할 수 있었습니다. 자세한 구현은 &lt;a href="https://github.com/planetarium/libplanet/blob/master/Libplanet.RocksDBStore/RocksDBStore.cs">코드&lt;/a>를 통해 확인하실 수 있습니다.&lt;/p>
&lt;p>RocksDBStore 혹은 Libplanet에 대해 더 궁금한 점이 있으시다면 언제든 저희 팀이 상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에 놀러 오세요!&lt;/p>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>이 작업을 진행할 당시, &lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>은 아직 소수의 테스트 플레이어를 대상으로 인스톨러 없이 간소하게 배포할 때였기 때문에, 이런 접근을 하게 되었습니다. 그러나 최근에는 인스톨러를 포함하여 배포하게 되면서 다른 접근도 가능하게 되었습니다. 기회가 된다면 이후 스낵에 다른 접근을 소개하도록 하겠습니다.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></content><author><name>이승훈</name><uri>https://github.com/earlbread</uri><email>seunghun@planetariumhq.com</email></author></entry><entry><title>Libplanet 게임잼</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/03/libplanet-gamejam/" title="Libplanet 게임잼"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/03/libplanet-gamejam/" hreflang="en" title="Libplanet Game Jam"/><id>https://snack.planetarium.dev/kor/2020/03/libplanet-gamejam/</id><published>2020-03-19T00:00:00+00:00</published><updated>2020-03-19T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요, 플라네타리움의 게임 클라이언트 프로그래머인 송승걸입니다. 이번 시간에는 플라네타리움에서 열렸던 사내 &lt;a href="https://en.wikipedia.org/wiki/Game_jam">게임잼&lt;/a>에 대해 제가 느꼈던 점을 나눠보고자 합니다.&lt;/p>
&lt;p>플라네타리움에선 저희가 자체 제작한 블록체인 게임 라이브러리인 &lt;a href="https://github.com/planetarium/libplanet">Libplanet&lt;/a>을 사용해 게임을 만들고 있습니다. Libplanet은 현재 주로 &lt;a href="https://unity.com/">Unity&lt;/a>에서 사용하는 것을 상정하고 개발 중이기 때문에, 엔진 내에서의 사용성을 위해 Unity용 &lt;a href="https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4_%EA%B0%9C%EB%B0%9C_%ED%82%A4%ED%8A%B8">SDK&lt;/a>를 제작하기로 했습니다. 이를 위해 Unity에서 Libplanet을 사용하는 조그마한 예시 프로젝트를 만들어 작업에 도움을 받기 위해 플라네타리움 사내 게임잼을 개최했습니다.&lt;/p>
&lt;p>2~3명이 한 조를 이뤄 게임 개발을 할 것을 상정하고 개최일까지 2일의 시간을 두고 게임 기획안을 생각해봤고, 그동안 블록체인 기술을 적용해볼 멋진 게임 기획안이 5개나 제시되었습니다. 저는 &lt;a href="https://github.com/limebell">고찬혁&lt;/a> 님과 한 조가 되어 오목 게임을 만들기로 했습니다. 2명의 플레이어가 대국하게 하려고 세션 개념, 즉 여러분들이 익히 알고 계신 게임의 &lt;strong>방&lt;/strong> 개념을 Libplanet의 액션(&lt;code>Action&lt;/code>)과 상태(state) 개념을 사용해 구현했습니다.&lt;/p>
&lt;figure>&lt;img src="screenshot.png"
alt="저희가 만든 오목 게임의 멋진 모습입니다!"/>&lt;figcaption>
&lt;p>저희가 만든 오목 게임의 멋진 모습입니다!&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>우선 대표적인 상태들과 이를 변경시키는 액션들을 소개해 드리겠습니다.&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>SessionState&lt;/code>: 세션의 정보를 저장합니다. 세션 안의 플레이어 정보인 &lt;code>AgentState&lt;/code>의 리스트와 세션을 구분할 수 있는 고유한 키(방 제목 개념)가 존재하고, 당연하게도 이 상태를 접근할 수 있도록 하는 주소(Address)도 있습니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>AgentState&lt;/code>: 플레이어의 계정 정보를 저장합니다. 이곳엔 플레이어의 정보(대표적으로 전적)와 주소가 있습니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>PlayerState&lt;/code>: 플레이어가 게임 내에서 사용하는 돌들의 정보를 저장합니다. 오목판 내의 돌의 좌표 정보가 저장됩니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>JoinSession&lt;/code>: 사용자가 입력한 키를 가진 세션에 참가하는 액션입니다. 입력한 키를 가진 세션이 없다면 그 키를 가진 세션을 만듭니다. 이를 통해 &lt;code>SessionState&lt;/code>를 변화시킵니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>PlaceAction&lt;/code>: 바둑돌을 오목판 위에 올려두는 액션입니다. 이를 통해 &lt;code>PlayerState&lt;/code>의 돌 정보를 변화시킵니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>ResignAction&lt;/code>: 플레이어가 항복하는 액션입니다. 두 플레이어의 &lt;code>AgentState&lt;/code>를 모두 변화시키는데, 항복한 플레이어에 패배 기록을 함과 동시에 승리한 플레이어에게 승리 기록을 합니다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>자세한 내부 구현이나, 코드를 보고 싶으시다면 &lt;a href="https://github.com/planetarium/planet-omok">Github 저장소&lt;/a>를 둘러보세요!&lt;/p>
&lt;p>결국, Libplanet을 사용한 블록체인 게임 개발의 관건은 결국 이러한 상태와 액션을 어떻게 다루는지에 달려 있다고 생각합니다. 액션은 상태를 변화시키고, 게임 로직에서 상태를 사용해 게임이 동작하는 것이죠. 게임잼 전엔 플라네타리움과 함께 한 지 얼마 되지 않아 액션을 직접 만들어 보지 못했지만, 이번 기회에 일반화된 세션 개념을 고찬혁 님과 함께 구현해보니 액션과 상태의 의미와 일반적인 사용법에 익숙해져 여러모로 좋은 시간이었습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>게임잼이니만큼 간단한 예제로써 사용하기 적합한 게임으로 클리커 게임인 Planet Clicker의 &lt;a href="https://github.com/planetarium/planet-clicker">GitHub 저장소&lt;/a>를 둘러보시면서 간단한 액션과 상태 구조를 둘러보시는 건 어떠신가요? 더 자세한 용법이나 질문이 있으시다면 언제든 플라네타리움 팀원이 상주한 &lt;a href="https://discord.gg/planetarium">디스코드 서버&lt;/a>로 놀러 와주세요!&lt;/p></content><author><name>송승걸</name><uri>https://github.com/unengine</uri><email>ssg@planetariumhq.com</email></author></entry><entry><title>게임 개발자, Libplanet을 처음 만났을 때 😂</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/02/hi-libpalnet-i-am-game-developer/" title="게임 개발자, Libplanet을 처음 만났을 때 😂"/><id>https://snack.planetarium.dev/kor/2020/02/hi-libpalnet-i-am-game-developer/</id><published>2020-02-26T00:00:00+00:00</published><updated>2020-02-26T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 플라네타리움에서 게임을 만들고 있는 현승민입니다. 이번 글에서는 일반적인 게임의 &lt;dfn>클라이언트–서버&lt;/dfn> 구조가 아닌 Libplanet을 활용하여 &lt;dfn>&lt;abbr title="peer-to-peer">P2P&lt;/abbr>&lt;/dfn> 구조를 적용하는 방법을 찾아가는 이야기를 소개해드릴게요. 아래의 내용은 전적으로 경험에 기반한 내용이라는 것을 고려해 주세요.&lt;/p>
&lt;p>먼저 &lt;em>클라이언트–서버&lt;/em> 구조에 관해서 이야기해 볼게요. 저는 대부분 프로젝트에서 클라이언트–서버 구조로 개발했어요. 당연하게도 통신을 위해서 프로토콜을 작성했는데, 이 프로토콜은 웹 통신과 비슷하게 디자인했어요. 클라이언트 측에서 요청을 만들어 서버에 넘기면 서버 측에서 응답을 만들어서 클라이언트로 돌려주는 구조이죠. 요청은 주로 유저가 입력한 값을 포함했고, 응답은 프로토콜의 성패 정보를 담는 에러 코드와 요청에 의해 영향을 받은 상태 값(이하 &lt;dfn>변경점&lt;/dfn>)을 포함했어요. (골드를 사용하는 구매 요청에 대한 응답에 구매 후 남은 골드량을 포함하는 등) 물론 클라이언트 측에서 예측 가능한 변경점은 응답에 포함하지 않아도 되었죠.&lt;/p>
&lt;p>다음은 지금 제가 개발하는 환경인 &lt;em>P2P&lt;/em> 구조를 살펴볼게요. Libplanet에서는 위에서 언급한 프로토콜을 &lt;code>IAction&lt;/code> 인터페이스를 구현한 클래스(이하 &lt;dfn>액션&lt;/dfn>)로 작성해요. 클라이언트에서 액션을 만들어 노드에 넘기면 노드는 액션들을 모아서 트랜잭션을 만들고, 트랜잭션들을 모아서 블록을 만들어요. 이 과정에서 각 액션의 &lt;code>Render&lt;/code>(이하 &lt;dfn>렌더&lt;/dfn>)와 &lt;code>Unrender&lt;/code>(이하 &lt;dfn>언렌더&lt;/dfn>) 이벤트가 발생하는데, 이를 통해서 클라이언트 측은 &lt;em>액션이 반영되었다&lt;/em>거나 &lt;em>그 액션이 취소(롤백)되었다&lt;/em>는 상태를 알 수 있는 구조이죠.&lt;/p>
&lt;p>언뜻 비슷한 구조로 보일 수 있지만, 클라이언트–서버에서는 요청과 응답이 분리되어 있어서 응답이 요청의 정보(성패, 실패했다면 그 자세한 이유)는 물론 변경점까지 포함될 수 있는데, P2P에서는 요청(액션) 하나만 존재하고 요청(액션)의 정보(렌더 혹은 언렌더 여부, 이마저도 알려면 노드가 멈추지 않는 조건을 만족해야 함)만 알 수 있다는 차이가 있어요. 대신에 각 액션의 렌더, 언렌더 단계에서는 해당 &lt;em>액션의 전후 상태&lt;/em>를 알 수 있도록 인터페이스를 제공하고 있어요.&lt;/p>
&lt;p>위의 내용들은 제게 한 가지 고민을 만들어 주었어요.&lt;/p>
&lt;blockquote>
&lt;p>변경점은 어떻게 알 수 있을까?&lt;/p>
&lt;/blockquote>
&lt;p>캐릭터 인벤토리에 아이템을 하나 추가해주는 액션을 수행했을 때, 인벤토리 전부를 다시 그리는 것은 피하고 싶었거든요.&lt;/p>
&lt;h3 id="1-액션의-렌더-전후-상태값-비교하기">1. 액션의 렌더 전후 상태값 비교하기&lt;/h3>
&lt;p>처음 생각한 방식은 액션의 렌더 전과 후의 상태 값을 비교해서 변경점을 뽑아 내는 방법이었어요. 하지만, 블록에 직렬화되어 있는 정보를 역직렬화와 캐스팅을 통해서 상태 값 A와 B로 만들어 내고, 그 둘을 비교하는 과정을 매 렌더·언렌더 단계에서 수행하는 것이 성능에 무리가 생길 것이라는 걱정이 생겼어요. 상태 값 A와 B는 이미 덩치가 컸고, 앞으로 더 커질 여지가 다분했기 때문이었죠.&lt;/p>
&lt;h3 id="2-변경점을-각-액션에-포함-시키기">2. 변경점을 각 액션에 포함 시키기&lt;/h3>
&lt;p>이 방법이면 기존 구조를 변경하지 않는 선에서 목표를 완수할 수 있겠다는 생각으로 액션들을 척척 작성해가고 있었어요. 모든 것이 원하는 대로 잘 돌아가는 줄로만 알고 있었던 어느 날, 이제까지의 테스트가 싱글 노드에서 진행되었고 멀티 노드 환경에서는 문제가 생길 거라는 것을 알게 되었죠. 그 이유는 다음과 같았어요.&lt;/p>
&lt;p>네트워크에 참여하는 모든 노드가 특정 액션을 처리하는데, 이를 다른 노드가 처리해서 전파 받더라도 두 처리 결과가 동일할 수 있도록 보장하는 역할을 &lt;code>IAction.PlainValue&lt;/code> 속성과 &lt;code>IAction.LoadPlainValue()&lt;/code> 메서드가 해요. 싱글 노드에서는 얼렁뚱땅 되는 것 처럼 보였어도 멀티 노드에서 잘 되려면 액션의 다른 곳이 아니라 해당 속성에 포함시켜야 되는 것을 깨달은 것이죠. 그렇다고 진짜 포함시키면 (저는 진짜 그냥 단순히 포함시켜 봤어요) &lt;code>InvalidTxSignatureException&lt;/code> 예외가 발생해요. 이것은 액션의 상태값이 바뀔 때 발생하는데, 당연한 것이 변경점은 액션을 만들 때는 비어있고 액션이 렌더된 이후에 채워지기 때문이죠. 이 과정에서 &lt;em>액션의 상태값은 바뀌지 않도록 작성한다&lt;/em>는 깨달음을 얻었어요.&lt;/p>
&lt;p>그렇다면 액션을 만들 때 &lt;em>예측 가능한 변경점&lt;/em>을 포함시키면 되지 않을까 생각했어요. 이것은 클라이언트가 만들어준 값을 노드가 믿는 구조가 되기 때문에 해킹에 용이해서 3초 만에 머리 속에서 지웠죠. 하지만 그 &lt;em>예측 가능한 변경점&lt;/em>을 액션 내에서 검증할 수 있다면 가능하겠다는 생각이 드네요!? 그래서 엔진팀에 문의해 봤더니 엔진에서 제공하는 &lt;code>IRandom&lt;/code> 인터페이스가 완전히 공정하기 때문에 &lt;em>예측 가능한 변경점&lt;/em>은 존재하지 않는다는 감동만이 남았네요. 감동.&lt;/p>
&lt;h3 id="3-변경점을-각-액션이-변경시키는-대상의-상태-값이하-대상-상태-값에-포함-시키기">3. 변경점을 각 액션이 변경시키는 대상의 상태 값(이하 대상 상태 값)에 포함 시키기&lt;/h3>
&lt;p>이 방법도 괜찮아 보였어요. 액션의 변경점을 대상 상태 값에 포함시키면 구조 수정 없이 확장 만으로 목표를 완수할 수 있지 않을까 하는 기대를 갖고 액션들을 척척 작성해 가고 있었어요. 대상 상태 값에는 각 액션의 변경점들이 쌓이기 시작했고, 클라이언트는 특정 액션의 렌더 단계에서 대상 상태 값에 쌓여 있는 변경점을 참조하는 방법을 사용했죠. 이미 한 번 계산한 변경점을 다시 계산할 필요가 없어졌고, 변경점의 참조 타이밍도 문맥상 안전해서 클라이언트 개발이 순조로웠어요. 하지만 문제는 생기기 마련이었죠.&lt;/p>
&lt;blockquote>
&lt;p>대상 상태 값에 쌓이는 특정 액션에 대한 변경점의 생명 주기는 어떻게 관리할 것인가?&lt;/p>
&lt;/blockquote>
&lt;p>상태 값의 변경은 액션을 통해서만 이루어지는 특성상, 더 이상 필요가 없는 변경점을 제거하기 위해서는 별도의 액션으로 처리해야 했어요. A액션의 변경점을 쌓아두기 위해 대상 상태 값을 변경했는데, 이미 사용해서 쌓아둘 필요가 없는 변경점을 대상 상태 값에서 제거하기 위해 B액션을 사용할 때, 그 변경점은 다시 대상 상태 값에 담겨야 하는가? 네, 로직에 예외가 생기더라고요. 이 안은 보류했어요.&lt;/p>
&lt;hr>
&lt;p>이 글을 작성하는 동안에도 Libplanet은 꾸준히 강력해졌어요. 액션의 실행 단계에서 확보되는 &lt;code>IActionContext&lt;/code>형 인자는 액션의 상태값과 무관하게 모든 노드에서 같은 결과를 결정적으로 확보할 수 있도록 &lt;code>IRandom&lt;/code> 인터페이스를 제공하고 있어요. 유니티에서 제공하는 랜덤 객체는 모든 노드에서 같은 결과를 얻을 수 없지만, &lt;code>IRandom&lt;/code> 인터페이스는 이를 보장해주고 있어요. 다시 2번의 접근이 가능하겠다는 각이 보이죠?&lt;/p>
&lt;p>다음 글에서는 &lt;code>IRandom&lt;/code> 인터페이스를 파해치고, 아름다운 클라이언트 환경을 어떻게 만들어 내는지 이야기해 볼게요.&lt;/p></content><author><name>현승민</name><uri>https://github.com/boscohyun</uri><email>seungmin@planetariumhq.com</email></author></entry><entry><title>태국에서만 2562년으로 가는 소프트웨어?</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/02/thai-in-2562/" title="태국에서만 2562년으로 가는 소프트웨어?"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/02/thai-in-2562/" hreflang="en" title="Software from Year 2562 Emerges in Thailand?"/><id>https://snack.planetarium.dev/kor/2020/02/thai-in-2562/</id><published>2020-02-25T00:00:00+00:00</published><updated>2020-02-25T00:00:00+00:00</updated><content type="html">&lt;h2 id="미래에서-온-손님">미래에서 온 손님&lt;/h2>
&lt;p>작년 12월에 저희는 마침내 첫 번째 알파테스트를 진행했고, 감사하게도 세계 각지에서 많은 분이 참여해 주셨습니다. 이는 팀에게 있어 굉장한 기회인 동시에 도전이기도 했습니다. 당연하게 크고 작은 문제가 있었는데요. 그중 저희를 난처하게 만들었던 문제 중 하나는 IBD였습니다.&lt;/p>
&lt;p>&lt;abbr title="initial block download">IBD&lt;/abbr>란 게임을 켰을 때 네트워크의 다른 피어들로부터 그동안 쌓인 블록들을 내려받아 최신 상태로 동기화하는 단계인데요. 아무래도 세계 각지에서 참여하시다 보니 네트워크 지연 등의 문제로 인해 시간이 오래 걸리거나 이상 종료되는 경우가 종종 있었습니다.&lt;/p>
&lt;p>그런데 그중에서도 특이한 증상을 보고한 사용자가 있었습니다. 당시 저희가 겪던 다른 문제들과 다르게 가장 첫 번째 블록을 내려받고 나서 이후 블록을 받을 수 없다는 것이었습니다.&lt;/p>
&lt;figure>&lt;img src="1.png"
alt="사용자로부터 받은 스크린숏"/>&lt;figcaption>
&lt;p>사용자로부터 받은 스크린숏&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>저희는 이 사용자가 보내 준 스크린숏을 확인하고 한 가지 이상한 점을 깨달았습니다. 날짜가 2019년이 아닌 2562년으로 적혀있던 것이었는데요. 그래서 저희는 한가지 가설을 세웠습니다. 모종의 이유로 파일 시스템이 고장이 나 있어서 블록 헤더의 해시가 잘못 계산되고 있다는 것이죠.&lt;/p>
&lt;p>이를 검증하기 위해 저희는 양해를 구하고 원격 데스크톱을 통해 문제가 발생한 시스템을 직접 조사하기로 했습니다.&lt;/p>
&lt;h2 id="날짜가-잘못되지-않았다">날짜가 잘못되지 않았다&lt;/h2>
&lt;p>다행히 해당 문제를 겪고 있던 사용자는 접속을 흔쾌히 허락해주셨습니다. 스크린숏으로 확인한 것처럼 여전히 날짜는 2562년이었습니다. 일단 가장 먼저 시간을 맞추기 위해 제어판을 열었습니다. 대부분의 현대적인 운영체제가 그렇듯이 Windows도 네트워크를 통해 시간을 동기화하는 기능이 있습니다. 그러나 이렇게 시간을 다시 동기화해도 제어판과 시스템의 날짜는 2562년으로 변함없었고 마지막 동기화 시각도 연도만이 다를 뿐 날짜, 시간이 모두 제가 사용하고 있는 시스템과 다르지 않았습니다.&lt;/p>
&lt;p>그런데 문제를 조금 살펴보기로 하고 제어판 이곳저곳을 확인 하던 중 제 눈길을 끄는 화면이 있었습니다.&lt;/p>
&lt;figure>&lt;img src="2.png"
alt="그레고리안력으로는 2019년이라고 표시되어 있다."/>&lt;figcaption>
&lt;p>그레고리안력으로는 2019년이라고 표시되어 있다.&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>저희 개발팀에서 태국어를 읽을 수 있는 사람은 없었지만, &amp;ldquo;Date in Gregorian&amp;quot;을 보니 &amp;ldquo;2562년&amp;quot;은 &amp;ldquo;2019년&amp;quot;의 다른 표현이라는 것을 알아차렸습니다. 그래서 시험 삼아 포맷을 바꾸니 예상대로 2019년 12월 16일이 표시되었고, 혹시나 하는 마음에 게임을 실행해보니 IBD 단계에서 문제없이 잘 실행이 되었습니다.&lt;/p>
&lt;h2 id="불력-佛曆">불력 (佛曆)&lt;/h2>
&lt;p>재현 방법과 실마리를 찾았으니 사용자께는 일단 잠시 지역 설정을 미국으로 해주실 것을 제안드렸고, 감사하게도 그 사용자분은 그 제안을 승낙하셨습니다.&lt;/p>
&lt;p>문제를 재현하기 위해 저희는 로컬 개발 환경에서 운영체제의 지역 설정을 태국으로 변경한 뒤 Libplanet의 단위 테스트를 돌려봤습니다. 아니나 다를까, 몇몇 테스트가 실패하는 것을 확인할 수 있었습니다. 그 가운데 가장 치명적인 문제는 내용상으로는 같은 블록의 해시가 달라지는 현상이었습니다. 살펴보니 해시의 입력을 만드는 과정에 &lt;a href="https://github.com/planetarium/libplanet/blob/82aaba0c37591ebf51207038e8c5c122272ce98b/Libplanet/Blocks/Block.cs#L488">&lt;code>Block&amp;lt;T&amp;gt;.Timestamp&lt;/code> 필드를 직렬화&lt;/a>한 결과가 기대와 달랐습니다. &lt;code>DateTimeOffset.ToString()&lt;/code> 메서드의 동작이 운영체제의 로캘에 영향을 받는 것입니다.&lt;/p>
&lt;p>인도차이나반도에서 불교는 유럽의 기독교와 같은 위치입니다. 그래서 역법에서도 예수 그리스도의 탄신을 기원(epoch)으로 삼는 &lt;a href="https://ko.wikipedia.org/wiki/%EA%B7%B8%EB%A0%88%EA%B3%A0%EB%A6%AC%EB%A0%A5">그레고리력&lt;/a> 대신, 석가모니의 입멸을 기원으로 삼는 &lt;a href="https://en.wikipedia.org/wiki/Buddhist_calendar">불력&lt;/a>(佛曆)이 일반적으로 쓰였다고 합니다. 캄보디아나 라오스 같은 나라들은 이제 서기 연도를 쓰게 바뀌었지만, 태국은 여전히 불력을 양력으로 고친 &lt;a href="https://en.wikipedia.org/wiki/Thai_solar_calendar">타이 태양력&lt;/a>을 쓰고 있습니다. 석가모니 입멸은 기원전 543년으로, 서기 2019년은 타이 태양력으로 2562년이 됩니다.&lt;/p>
&lt;p>이와 같이, 세계에는 문화권에 따라 다양한 역법을 쓰고 있으므로, 사용자 인터페이스를 표시할 때 각 문화권에 알맞는 날짜 형식으로 표시되어야 합니다. 사실 &lt;code>DateTimeOffset.ToString()&lt;/code> 메서드는 이를 위해 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.iformatprovider?view=netstandard-2.0">&lt;code>IFormatProvider&lt;/code>&lt;/a> 객체도 파라미터로 받는 오버로드를 갖고 있습니다. &lt;code>IFormatProvider&lt;/code> 인터페이스를 구현하는 클래스 중에서 가장 많이 쓰이는 것이 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo?view=netstandard-2.0">&lt;code>CultureInfo&lt;/code>&lt;/a>입니다. 이름에서 알 수 있듯, &lt;code>CultureInfo&lt;/code>는 유닉스 계열에서 로캘(locale)이라고 부르는 것과 같은 개념입니다. 아래와 같이, &lt;code>DateTimeOffset.ToString()&lt;/code> 메서드는 파라미터로 어떤 로캘을 설정하느냐에 따라 결과물이 달라집니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-csharp" data-lang="csharp">&amp;gt; &lt;span style="color:#080;font-weight:bold">using&lt;/span> &lt;span style="color:#b06;font-weight:bold">System.Globalization&lt;/span>;
&amp;gt; &lt;span style="color:#888;font-weight:bold">var&lt;/span> now = DateTimeOffset.Now;
&amp;gt; now.ToString(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;yyyy-MM-ddTHH:mm:ss.ffffffZ&amp;#34;&lt;/span>, &lt;span style="color:#080;font-weight:bold">new&lt;/span> CultureInfo(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;ko-KR&amp;#34;&lt;/span>))
&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2020-02-13T17:37:16.436163Z&amp;#34;&lt;/span>
&amp;gt; now.ToString(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;yyyy-MM-ddTHH:mm:ss.ffffffZ&amp;#34;&lt;/span>, &lt;span style="color:#080;font-weight:bold">new&lt;/span> CultureInfo(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;th-TH&amp;#34;&lt;/span>))
&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2563-02-13T17:37:16.436163Z&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 아무 로캘도 설정하지 않고 해당 파라미터를 생략하면 적당히 그 코드가 실행되는 환경의 로캘을 따라가게 됩니다. 아래 코드는 제가 운영체제의 지역 설정을 한국으로 해뒀을 때의 결과입니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-csharp" data-lang="csharp">&amp;gt; now.ToString(&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;yyyy-MM-ddTHH:mm:ss.ffffffZ&amp;#34;&lt;/span>)
&lt;span style="color:#d20;background-color:#fff0f0">&amp;#34;2020-02-13T17:37:16.436163Z&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.datetimeoffset.tostring?view=netstandard-2.0#System_DateTimeOffset_ToString">문서에 따르면, 해당 파라미터가 생략된 오버로드&lt;/a>는 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.currentculture?view=netstandard-2.0">&lt;code>CultureInfo.CurrentCulture&lt;/code>&lt;/a>를 따른다고 합니다. &lt;code>CultureInfo.CurrentCulture&lt;/code> 속성은 이름에서도 알 수 있듯 실행 환경의 로캘을 가르킵니다. 따라서, 실행 환경의 로캘과 무관하게 언제나 결정적인 동작을 원한다면 명시적으로 &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.globalization.cultureinfo.invariantculture?view=netstandard-2.0">&lt;code>CultureInfo.InvariantCulture&lt;/code>&lt;/a>를 지정해야 합니다.&lt;/p>
&lt;p>메서드가 비결정적으로 동작할 수 있음에도 불구하고 해당 파라미터를 생략하면 실행 환경의 로캘을 따르도록 API를 설계한 것은, 아마 저러한 서식(formatting) 연산이 대개 사용자 인터페이스를 그리는 데에 쓰이고, 그렇기 때문에 국제화에 큰 신경을 쓰지 않고 코딩을 해도 자연스럽게 문화권에 알맞은 서식으로 보이도록 하려는 의도일 것입니다. 하지만 저희가 해당 메서드를 쓴 것은 사용자 인터페이스가 아니라, 결정적이어야 하는 암호학적 해시의 입력인 것이 불찰이었습니다.&lt;/p>
&lt;p>원인을 알았으니 &lt;a href="https://github.com/planetarium/libplanet/pull/734">&lt;code>DateTimeOffset.ToString()&lt;/code> 메서드와 마찬가지로 &lt;code>CultureInfo&lt;/code>나 &lt;code>IFormatProvider&lt;/code> 파라미터가 생략된 메서드를 찾아서, 명시적으로 &lt;code>CultureInfo.InvariantCulture&lt;/code>를 지정하도록 패치&lt;/a>하는 것으로 급한 문제는 일단락됐습니다.&lt;/p>
&lt;p>CI에서도 아랍어나 프랑스어, 히브리어 로캘 등에서도 단위 테스트를 실행하도록 보강하기도 했습니다. 유럽에는 소수점 표시를 점(&lt;code>.&lt;/code>)이 아니라 쉼표(&lt;code>,&lt;/code>)로 하는 나라도 많고, 중동에는 오른쪽에서 왼쪽으로 글을 쓰기도 하므로, 저희에게 다소 생소하게 느껴지는 언어권을 일부러 고른 것입니다.&lt;/p>
&lt;p>또, 앞으로 비슷한 실수는 얼마든지 일어날 수 있기 때문에, 실행 환경의 로캘에 따라 동작이 달라지는 코드를 찾아주는 &lt;a href="https://github.com/planetarium/libplanet/pull/737">정적 분석도 도입&lt;/a>하였습니다.&lt;/p>
&lt;h2 id="마치며">마치며&lt;/h2>
&lt;p>앞서 언급한 것처럼 암호학적 해시를 계산하는 함수에 서식 같은 비결정적인 동작이 예상되는 API를 사용하는 것은 장기적으로 좋은 결정은 아닙니다. 일반적으로 문자열은 이러한 서식이 많이 적용되기 때문에 자료형 차원에서 피하는 것이 안전합니다.&lt;/p>
&lt;p>하지만 아쉽게도 저희는 이 문제를 테스트 중간에 발견하였고, 해시 방식을 바꾸는 것은 이전 데이터의 호환성을 깨는 결정이었기 때문에 아직 대대적인 수정은 하지 못했습니다. 하지만 Libplanet 릴리스 1.0 전에는 이러한 부분을 수정할 예정입니다.&lt;/p></content><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>쿠버네티스로 P2P 게임 테스트하기</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/02/k8s-1/" title="쿠버네티스로 P2P 게임 테스트하기"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/02/k8s-1/" hreflang="en" title="Testing P2P Game with Kubernetes"/><id>https://snack.planetarium.dev/kor/2020/02/k8s-1/</id><published>2020-02-20T00:00:00+00:00</published><updated>2020-02-20T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요, &lt;a href="https://planetariumhq.com">플라네타리움&lt;/a>에서 &lt;a href="https://libplanet.io">Libplanet&lt;/a>을 개발하고 있는 문성원입니다. 작년 12월 16일부터 2주일간, 저희가 만들고 있는 완전 탈중앙 MMORPG인 &lt;a href="https://nine-chronicles.com">나인 크로니클&lt;/a>의 알파 테스트가 있었는데요. 오늘은 그 준비를 위해 &lt;a href="https://kubernetes.io/">쿠버네티스&lt;/a>(Kubernetes)에 헤드리스 게임을 배포한 경험을 공유해보려고 합니다.&lt;/p>
&lt;h2 id="어떤-게-필요한가요">어떤 게 필요한가요?&lt;/h2>
&lt;p>Libplanet으로 개발된 게임은 블록체인 노드라고 할 수 있는데, 이는 나인 크로니클도 마찬가지입니다. 즉 모든 게임 클라이언트는 그 자체로 일반적인 게임 서버와 비슷한 역할(데이터 저장, 판정)을 온전히 수행할 수 있습니다. 이러한 P2P 환경에서 게임 환경과 최대한 유사하게 테스트하기 위해서는, 이러한 게임 클라이언트를 동시에 많이 실행하여 테스트할 필요가 있었습니다.&lt;/p>
&lt;h2 id="구체적인-희망-사항">구체적인 희망 사항&lt;/h2>
&lt;ul>
&lt;li>(많은 소프트웨어가 그렇듯이) 테스트 중인 게임 역시 필요에 따라 업데이트를 해야 할 때가 있습니다. 이때 실행된 모든 클라이언트를 돌면서 직접 업데이트하는 것은 그리 좋은 전략이 아닙니다.&lt;/li>
&lt;li>한두 개를 켜서 실행하는 것은 개발자 개인이 쉽게 할 수 있는 일이지만, 우리는 그것보다 많은 게임 클라이언트를 테스트하고 싶습니다.&lt;/li>
&lt;li>게임을 실행하긴 하지만, 많은 게임 클라이언트를 동시에 띄우는 것이기 때문에 각 게임 클라이언트의 화면을 보는 것은 그렇게 중요한 사항이 아닙니다. 즉 아무런 UI 없이 &lt;a href="https://en.wikipedia.org/wiki/Headless_software">헤드리스&lt;/a>(headless)로 실행해도 괜찮습니다.&lt;/li>
&lt;/ul>
&lt;h2 id="도커docker">도커(Docker)&lt;/h2>
&lt;p>이런 사항을 만족하기 위해서는 여러 개의 프로세스를 동시에 실행하고 관리해야 했는데, 이때 사용한 솔루션이 &lt;a href="https://docker.com">도커&lt;/a>(Docker)입니다. 도커는 리눅스 응용 프로그램을 실행환경째로 컨테이너화하여 실행하기 위해 많이 사용하는 솔루션입니다. 나인 크로니클은 첫 출시에서 리눅스를 주요 플랫폼으로 고려하고 있진 않지만, Unity를 사용해서 게임 개발을 하다보니 비교적 쉽게 리눅스용 빌드를 뽑을 수 있었고 (헤드리스 테스트 노드에선 크게 중요치 않은) UI 버그를 제외하면 동작도 크게 다르진 않았습니다.&lt;/p>
&lt;h2 id="쿠버네티스kubernetes">쿠버네티스(Kubernetes)&lt;/h2>
&lt;p>도커를 사용해서 게임 빌드를 어디서나 쉽게 돌릴 수 있게 컨테이너로 만들었지만 이걸로 끝은 아니었습니다. 저희의 목표는 어디까지나 많은 클라이언트를 손쉽게 실행/종료/업데이트하며 테스트 환경을 유지하는 것이니까요. 이를 위해서는 도커만으로는 부족했습니다.&lt;/p>
&lt;p>가장 먼저 떠오른 방법은 &lt;abbr title="Elastic Container Service">&lt;a href="https://aws.amazon.com/ko/ecs/">ECS&lt;/a>&lt;/abbr>와 같이 클라우드 공급자가 제공하는 실행 환경이었습니다. 이런 실행 환경들은 복잡한 워크플로우를 효율적으로 설정할 수 있게 디자인되어있지만, 바꾸어보면 설정이 복잡하며 테스트 환경에서만 사용한다면 많은 기능을 사용하지 않을 것이라는 생각이 들었습니다. 또한 특정 클라우드 공급자에 종속되는 테스트 환경이 이후 이전 작업등에 부담이 될 것 같기도 했고요.&lt;/p>
&lt;figure>&lt;img src="comparison.png"
alt="AWS 컨테이너 오케스트레이션 비교"/>&lt;figcaption>
&lt;p>AWS 컨테이너 오케스트레이션 비교&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>그래서 떠올린 대안이 쿠버네티스였습니다. 쿠버네티스는 저희가 ECS 같은 서비스를 통해서 하고 싶은 일을 공급자 중립적(Provider Agonistic)으로 할 수 있는 오픈소스 프로젝트입니다. 여러 종류의 복잡한 컨테이너를 손쉽게 띄우고 내리는 기능을 컨테이너 오케스트레이션이라고 하는데, 저희는 거의 같은 종류의 컨테이너(게임)를 여러 개 띄우고 싶은 것뿐이니 설정은 그리 복잡하지 않았습니다.&lt;/p>
&lt;h2 id="다음-이야기">다음 이야기&lt;/h2>
&lt;p>적다 보니 이야기가 많이 길어졌네요. 다음 시간에는 테스트를 위해 쿠버네티스를 어떻게 설정하고 클라우드 상에 배치하고 있는지 구체적인 절차에 대해 살펴보도록 하겠습니다.&lt;/p></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.8 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2020/02/libplanet-0.8/" title="Libplanet 0.8 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2020/02/libplanet-0.8/" hreflang="en" title="Libplanet 0.8 Released"/><id>https://snack.planetarium.dev/kor/2020/02/libplanet-0.8/</id><published>2020-02-05T00:00:00+00:00</published><updated>2020-02-05T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요.
저희 팀은 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 여덟 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.8.0">0.8 버전&lt;/a>을
릴리스했습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때,
그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는
공용 라이브러리입니다.&lt;/p>
&lt;p>거의 세 달 만의 새 버전인 만큼, 0.8 버전에서는 저장소 최적화를 비롯한 많은
개선이 있었습니다.
이 글에서는 0.8 버전의 주요 변경 사항들에 대해 다루겠습니다.&lt;/p>
&lt;h2 id="제너시스-블록-상정">제너시스 블록 상정&lt;/h2>
&lt;p>&lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code>는 이제 특정한 제너시스 블록을 상정하게 되었습니다.
이는 Libplanet으로 만든 여러 게임들이 서로 별개의 네트워크를 구성함에도,
Libplanet이 일종의 메타프로토콜로 동작하기에 엉뚱한 네트워크에 접속 시도를
하는 등의 실수를 방지하기 위해서 입니다.&lt;/p>
&lt;p>&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1__ctor_Libplanet_Blockchain_Policies_IBlockPolicy__0__Libplanet_Store_IStore_Libplanet_Blocks_Block__0__">&lt;code>BlockChain&amp;lt;T&amp;gt;()&lt;/code> 생성자&lt;/a>는 &lt;code>Block&amp;lt;T&amp;gt;&lt;/code> 객체를 인자로 받으며,
해당 블록이 가장 첫 블록이 됩니다. 만약 &lt;code>IStore&lt;/code>에 들어있는 제너시스 블록과
&lt;code>BlockChain&amp;lt;T&amp;gt;()&lt;/code> 생성자가 기대하는 제너시스 블록이 일치하지 않을 경우
&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Blocks.InvalidGenesisBlockException.html">&lt;code>InvalidGenesisBlockException&lt;/code>&lt;/a>이 일어나게
됩니다.&lt;/p>
&lt;p>현재는 생성자가 제너시스 &lt;code>Block&amp;lt;T&amp;gt;&lt;/code> 객체를 통째로 받지만,
&lt;a href="https://github.com/planetarium/libplanet/pull/769">다음 버전에는 제너시스 블록 해시만 받고 실제 블록 내용은 네트워크의 다른
노드한테 받을 수도 있게 개선될 예정입니다.&lt;/a>&lt;/p>
&lt;h2 id="defaultstoredefaultstore--litedbstore">&lt;a href="https://docs.libplanet.io/master/api/Libplanet.Store.DefaultStore.html">&lt;code>DefaultStore&lt;/code>&lt;/a> ← &lt;code>LiteDBStore&lt;/code>&lt;/h2>
&lt;p>내장 &lt;code>IStore&lt;/code> 구현이었던 &lt;code>LiteDBStore&lt;/code>가 사라지고 그 자리를
&lt;a href="https://docs.libplanet.io/master/api/Libplanet.Store.DefaultStore.html">&lt;code>DefaultStore&lt;/code>&lt;/a>가 대체했습니다.&lt;/p>
&lt;p>이름이 바뀐 까닭은 더이상 LiteDB 파일 하나가 아닌,
여러 포맷이 섞인 파일들을 담는 디렉터리에 저장되게 바뀌었기 때문입니다.&lt;/p>
&lt;p>또한, 1.0.0 릴리스 전까지 실험을 거듭하여 저장소 최적화를 할 예정으로,
이름에서 구현 세부 사항을 제거하는 의도도 있었습니다.&lt;/p>
&lt;p>그 외에도 저장 공간을 줄이기 위한 &lt;a href="https://docs.libplanet.io/master/api/Libplanet.Store.DefaultStore.html#Libplanet_Store_DefaultStore__ctor_System_String_System_Boolean_System_Boolean_System_Int32_System_Int32_System_Int32_System_Int32_System_Boolean_System_Boolean_">&lt;code>DefaultStore()&lt;/code> 생성자&lt;/a>에는
&lt;code>compress&lt;/code> 옵션이 생겼습니다. 이번 버전에서는 아직 기본적으로 꺼져 있지만,
다음 버전에서는 기본값이 &lt;code>true&lt;/code>로 바뀔 예정입니다.&lt;/p>
&lt;h2 id="icryptobackendicryptobackend">&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Crypto.ICryptoBackend.html">&lt;code>ICryptoBackend&lt;/code>&lt;/a>&lt;/h2>
&lt;p>Libplanet은 다양한 플랫폼에서도 쓸 수 있도록,
순수 C#으로 작성된 암호학 라이브러리인 &lt;a href="http://www.bouncycastle.org/csharp/">Bouncy Castle&lt;/a>을 써왔습니다.
그러나 순수 C# 구현은 이식성에서는 큰 장점이 되지만,
성능에서는 오히려 페널티로 작용합니다.&lt;/p>
&lt;p>새 버전에서는 이식성과 성능 중 어느 쪽을 취할지 게임 제작자가 고를 수 있도록,
&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Crypto.ICryptoBackend.html">&lt;code>ICryptoBackend&lt;/code>&lt;/a>라는 추상화 계층이 추가됐습니다.
기본 구현인 &lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Crypto.DefaultCryptoBackend.html">&lt;code>DefaultCryptoBackend&lt;/code>&lt;/a>는 여전히
내부적으로 Bouncy Castle에 의존하지만,
게임 제작자는 게임의 타깃 플랫폼에 따라 적절히 &lt;code>ICryptoBackend&lt;/code> 인터페이스를
구현하여 성능 이점을 누릴 수 있습니다.&lt;/p>
&lt;p>예를 들어, Libplanet이 &lt;code>ICryptoBackend&lt;/code>를 구현한 &lt;code>MyCryptoBackend&lt;/code> 클래스를
쓰게 하고 싶다면,
아래와 같이 &lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Crypto.CryptoConfig.html#Libplanet_Crypto_CryptoConfig_CryptoBackend">&lt;code>CryptoConfig.CryptoBackend&lt;/code> 속성&lt;/a>를
덮어씌우면 됩니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff">&lt;code class="language-csharp" data-lang="csharp">CryptoConfig.CryptoBackend = &lt;span style="color:#080;font-weight:bold">new&lt;/span> MyCryptoBackend();
&lt;/code>&lt;/pre>&lt;/div>&lt;p>저희 팀에서 만드는 게임인 &lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>에서는 비트코인 프로젝트에서 공개한
&lt;a href="https://github.com/bitcoin-core/secp256k1">secp256k1&lt;/a> C 라이브러리를 호출하는 &lt;code>ICryptoBackend&lt;/code> 인터페이스를 구현하여
게임 성능을 개선하기도 했습니다.&lt;/p>
&lt;h2 id="라우팅-테이블-개선">라우팅 테이블 개선&lt;/h2>
&lt;p>Libplanet은 &lt;a href="https://snack.planetarium.dev/kor/2019/09/kademlia/">분산 해시 테이블 방식&lt;/a>을 적용하여 다른 피어와 통신하기 때문에
라우팅 테이블의 자신과 연결된 피어들의 정보를 저장합니다.&lt;/p>
&lt;p>기존에는 이 라우팅 테이블에 해당 피어와 가장 최근에 통신한 시점만을
저장하고 있었는데,
추가로 해당 피어와의 통신 딜레이를 추가하여 사용자가 네트워크 환경에 대한
자세한 정보를 알 수 있도록 하였습니다.&lt;/p>
&lt;p>개발자들은 새로 추가된
&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_CheckAllPeersAsync_System_Nullable_TimeSpan__CancellationToken_">&lt;code>Swarm&amp;lt;T&amp;gt;.CheckAllPeersAsync()&lt;/code> 메서드&lt;/a>를
이용하여 라우팅 테이블에 저장된 피어들을 갱신할 수 있고,
&lt;a href="https://docs.libplanet.io/0.8.0/api/Libplanet.Net.Swarm-1.html#Libplanet_Net_Swarm_1_Peers">&lt;code>Swarm&amp;lt;T&amp;gt;.Peers&lt;/code> 속성&lt;/a>에 접근해 Libplanet의 외부에서도 현재
자신의 라우팅 테이블에 들어있는 피어들을 확인할 수 있게 되었습니다.&lt;/p>
&lt;h2 id="블록-구조-및-직렬화-방식의-변경">블록 구조 및 직렬화 방식의 변경&lt;/h2>
&lt;p>블록체인을 구성하는 요소인 블록은 크게 트랜잭션을 제외한 메타데이터 부분과
트랜잭션, 이렇게 두 부분로 나눌 수 있습니다.&lt;/p>
&lt;p>많은 블록체인 프로젝트들이 그렇듯 저희 역시 여기서 트랜잭션을 뺀
부분을 블록 헤더로 정의하였고,
기존에 블록 해시로만 수행하던 연산들을 좀더 풍부한 정보를 담은 블록 헤더를
이용해 수행하게 바꾸어 기존보다 효율적인 연산을 할 수 있게 되었습니다.&lt;/p>
&lt;p>더불어, 블록과 트랜잭션을 직렬화할 때 필드 키를 짧게 줄이고,
비어있는 필드는 아예 배제함으로써 직렬화된 표현을 경량화했습니다.&lt;/p>
&lt;h2 id="문서-개선">문서 개선&lt;/h2>
&lt;p>라이브러리 자체의 변경은 아니지만, &lt;a href="https://docs.libplanet.io/0.8.0/">문서 웹사이트&lt;/a>의 디자인에 개선이
있었고, 문성원 님이 작성하신 새로운 &lt;a href="https://docs.libplanet.io/0.8.0/articles/overview.html">개요&lt;/a> 문서도 추가됐습니다.&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>그 밖에도, 세 달 남짓 Libplanet으로 만들고 있는 게임 &lt;a href="https://nine-chronicles.com/">나인 크로니클&lt;/a>의
퍼블릭 테스트를 몇 차례 진행하며 발견한 많은 문제들을 바로잡느라 매우 다양한
변화가 있었습니다. 자세한 것은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.8.0">전체 변경 내역&lt;/a>에서 확인할 수 있습니다.&lt;/p>
&lt;p>호기심이 생기신 분들은 설치해서 이용해 보시고, 궁금한 점이 있으시다면 저희 팀이
상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드&lt;/a>에 놀러오세요!&lt;/p></content><author><name>고찬혁</name><uri>https://github.com/limebell</uri><email>lime@planetariumhq.com</email></author><author><name>홍민희</name><uri>https://github.com/dahlia</uri><email>hong.minhee@planetariumhq.com</email></author></entry><entry><title>Libplanet 0.7 릴리스</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/11/libplanet-0.7/" title="Libplanet 0.7 릴리스"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/11/libplanet-0.7/" hreflang="en" title="Libplanet 0.7 Released"/><id>https://snack.planetarium.dev/kor/2019/11/libplanet-0.7/</id><published>2019-11-11T00:00:00+00:00</published><updated>2019-11-11T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 저희 팀은 &lt;a href="https://libplanet.io/">Libplanet&lt;/a>의 일곱 번째 마이너 버전인 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.7.0">0.7 버전&lt;/a>을 릴리스했습니다.&lt;/p>
&lt;p>Libplanet은 분산 P2P로 돌아가는 온라인 멀티플레이어 게임을 만들 때, 그러한 게임들이 매번 구현해야 하는 P2P 통신이나 데이터 동기화 등의 문제를 푸는 공용 라이브러리입니다.&lt;/p>
&lt;p>0.7 버전에서는 Libplanet의 안정성 및 성능 개선과 더불어 다양한 사용성 개선이 있었습니다. 이 글에서는 0.7 버전의 주요 변경 사항들에 대해 다루겠습니다.&lt;/p>
&lt;h2 id="액션-및-상태의-타입-제한">액션 및 상태의 타입 제한&lt;/h2>
&lt;p>기존 Libplanet에서 상태 및 액션의 속성은 &lt;code>object&lt;/code> 타입으로 표현되고 저장할 때는 알아서 &lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/binary-serialization">.NET의 바이너리 직렬화&lt;/a> 포맷으로 직렬화되었습니다. 이 방식은 .NET 객체를 그대로 직렬화할 수 있으므로 Libplanet을 쓰는 쪽에서도 만드는 쪽에서도 생각할 게 적다는 장점이 있습니다. 하지만 저희 팀은 이 방식을 처음 도입했을 때부터 여러 한계를 인식한 채 한시적으로 사용할 것을 의도했는데, 그 한계는 다음과 같은 것들이 있습니다.&lt;/p>
&lt;ul>
&lt;li>직렬화 역직렬화가 구체적으로 이뤄지는 방식이 암시적입니다. 타입의 구현이 달라지면 직렬화되는 포맷에도 영향이 가지만 구체적으로 어떤 변화가 일어나는지 짐작하기 어렵습니다.&lt;/li>
&lt;li>과거에는 모양이 달랐던 타입의 값이 직렬화되어 블록체인에 저장된 뒤, 현재 타입으로 역직렬화를 시도했을 때 런타임 오류가 나거나 의도한 것과 다른 의미로 해석될 수 있습니다.&lt;/li>
&lt;li>팀에서 정의한 타입이라면 &lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/version-tolerant-serialization">VTS&lt;/a> 같은 기법을 도입할 수도 있지만, 실수로 팀에서 만든 어셈블리가 아닌 패키지 등을 통해 가져다 쓴 타입이 섞여서 직렬화된 경우 나중에 해당 타입의 내부 표현이 달라져서 직렬화 형식이 바뀌어도 대응하기가 어렵습니다.&lt;/li>
&lt;li>직렬화된 결과를 .NET이 아닌 플랫폼에서 해석하기 어려울뿐더러, 같은 .NET 플랫폼이라도 직렬화된 타입을 포함한 어셈블리를 공유하지 않으면 역직렬화는 어렵습니다. 따라서 &lt;a href="https://github.com/planetarium/libplanet-explorer">Libplanet Explorer&lt;/a>나 &lt;a href="https://docs.microsoft.com/en-us/dotnet/standard/serialization/version-tolerant-serialization">Libplanet Explorer Frontend&lt;/a> 같은 앱에서 액션의 속성이나 특정 시점의 상태를 사람이 보기 쉽게 표시하기 힘듭니다.&lt;/li>
&lt;/ul>
&lt;p>그래서 이번 버전부터는 상태 및 액션의 속성은 &lt;a href="https://github.com/planetarium/bencodex.net">Bencodex&lt;/a>의 &lt;a href="https://github.com/planetarium/bencodex.net/blob/0.2.0/Bencodex/Types/IValue.cs">&lt;code>IValue&lt;/code>&lt;/a> 타입을 통해서 표현하도록 바뀌었습니다. 따라서 게임 내부에서 정의해서 쓰는 타입들을 &lt;code>IValue&lt;/code> 형식으로 변환하는 코드, 그리고 &lt;code>IValue&lt;/code> 형식으로 표현된 것을 다시 게임 내 타입들로 해석하는 코드를 명시적으로 써야 합니다. 조금 귀찮아진 것도 사실이지만, 대신 직렬화하려는 타입의 내부 표현이 바뀌어도 직렬화 혹은 역직렬화 메서드에 해당 변경에 따른 처리 로직을 추가할 수 있게 되었고, 각기 다른 버전 사이의 호환을 좀 더 구현하기 쉽게 되었습니다.&lt;/p>
&lt;h2 id="blockchaint의-ireadonlylistt-구현-제거">&lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code>의 &lt;code>IReadOnlyList&amp;lt;T&amp;gt;&lt;/code> 구현 제거&lt;/h2>
&lt;p>이전 버전까지 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code> 클래스는 &lt;code>IReadOnlyList&amp;lt;T&amp;gt;&lt;/code> 인터페이스를 구현하고 있었고, 그에 따라 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code> 객체에 직접 &lt;a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/linq/">LINQ&lt;/a> 확장 메서드들을 사용할 수 있었습니다. LINQ 확장 메서드는 선형적인 객체를 다룰 때 다양한 편리를 제공하지만, 사용 방법에 따라 상당한 성능상의 차이를 가져올 수 있습니다. 예를 들어 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code> 객체에 10,000개의 블록이 있을 때 LINQ의 &lt;code>.Last()&lt;/code> 메서드를 사용하여 10,000 번째 블록을 가져오고자 한다면 마지막 블록만을 저장소에서 바로 가져온다고 생각하기 쉽습니다. 하지만 실제로는 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code>의 첫 블록부터 마지막 블록까지 조회하며 각 블록에 대해 스토리지에 저장된 내용을 메모리에 올리고 해석하는 작업이 이뤄지게 됩니다. 저장된 블록이 적을 때는 이런 점이 큰 문제가 되지 않지만, 블록이 많아질수록 이런 사용방식이 큰 성능 문제로 이어질 수 있습니다.&lt;/p>
&lt;p>이번 버전부터는 &lt;code>BlockChain&amp;lt;T&amp;gt;&lt;/code> 클래스에서 &lt;code>IReadOnlyList&amp;lt;T&amp;gt;&lt;/code> 구현을 아예 제거함으로써 LINQ 확장 메서드를 잘못 사용해 생길 수 있는 문제를 방지하도록 했습니다. 대신 &lt;a href="https://docs.libplanet.io/0.7.0/api/Libplanet.Blockchain.BlockChain-1.html#Libplanet_Blockchain_BlockChain_1_Contains_Libplanet_Blocks_Block__0__">&lt;code>BlockChain&amp;lt;T&amp;gt;.Contains()&lt;/code>&lt;/a> 같이 자주 쓰이는 연산은 효율적인 구현을 직접 제공하기로 했습니다.&lt;/p>
&lt;h2 id="개인키를-안전하게-저장할-수-있는-키-저장소-구현">개인키를 안전하게 저장할 수 있는 키 저장소 구현&lt;/h2>
&lt;p>이번 버전에서는 개인키를 암호화하여 안전하게 보호할 수 있도록 키 저장소가 추가되었습니다. 키 저장소 내 각각의 키 파일은 &lt;a href="https://docs.libplanet.io/0.7.0/api/Libplanet.KeyStore.ProtectedPrivateKey.html">&lt;code>ProtectedPrivateKey&lt;/code>&lt;/a> 클래스로 표현되며, 사용자가 입력한 암호(passphrase)로 개인키를 암호화 하여 저장할 수 있습니다. 또한, &lt;a href="https://docs.libplanet.io/0.7.0/api/Libplanet.KeyStore.ProtectedPrivateKey.html#Libplanet_KeyStore_ProtectedPrivateKey_WriteJson_Stream_System_Nullable_Guid___">&lt;code>ProtectedPrivateKey.WriteJson()&lt;/code>&lt;/a> 메서드를 이용해 &lt;a href="https://en.wikipedia.org/wiki/Ethereum">이더리움&lt;/a>의 &lt;a href="https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition">Web3 Secret Storage Definition&lt;/a>에 따라 JSON 형식으로 저장할 수 있습니다. 추후 키 저장소 디렉터리를 통합적으로 관리하는 기능도 추가될 예정입니다.&lt;/p>
&lt;p>현재 &lt;a href="https://en.wikipedia.org/wiki/Key_derivation_function">키 유도함수&lt;/a>는 &lt;a href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2&lt;/a>와 &lt;a href="https://en.wikipedia.org/wiki/Scrypt">Scrypt&lt;/a>가 구현되어있고, &lt;a href="https://ko.wikipedia.org/wiki/%EA%B3%A0%EA%B8%89_%EC%95%94%ED%98%B8%ED%99%94_%ED%91%9C%EC%A4%80">AES&lt;/a>-128-&lt;a href="https://ko.wikipedia.org/wiki/%EB%B8%94%EB%A1%9D_%EC%95%94%ED%98%B8_%EC%9A%B4%EC%9A%A9_%EB%B0%A9%EC%8B%9D#%EC%B9%B4%EC%9A%B4%ED%84%B0_(CTR)">CTR&lt;/a> 암호화 알고리즘을 지원하고 있습니다. 이 중 Scrypt 구현은 &lt;a href="https://github.com/minhoryang">minhoryang&lt;/a> 님의 &lt;a href="https://github.com/planetarium/libplanet/pull/654">기여&lt;/a>로 추가되었습니다. 🎉&lt;/p>
&lt;h2 id="그-외">그 외&lt;/h2>
&lt;p>이번 버전에는 &lt;a href="https://hacktoberfest.digitalocean.com/">Hacktoberfest&lt;/a> 행사로 많은 분의 기여가 있었습니다. 해당 행사에 관한 내용은 문성원 님이 작성하신 &lt;a href="/kor/2019/11/looking-back-at-hacktoberfest/">Hacktoberfest를 돌아보며&lt;/a>에서 자세히 보실 수 있고, 그 외 이번 버전의 모든 변경 사항은 &lt;a href="https://github.com/planetarium/libplanet/releases/tag/0.7.0">전체 변경 내용&lt;/a>에서 확인하실 수 있습니다.&lt;/p>
&lt;p>이번 변경 사항이나 Libplanet에 대해 궁금한 점이 있으시다면 언제든 저희 팀이 상주해 있는 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에 방문해 주세요!&lt;/p></content><author><name>이승훈</name><uri>https://github.com/earlbread</uri><email>seunghun@planetariumhq.com</email></author></entry><entry><title>Hacktoberfest를 돌아보며</title><link rel="alternate" href="https://snack.planetarium.dev/kor/2019/11/looking-back-at-hacktoberfest/" title="Hacktoberfest를 돌아보며"/><link rel="alternate" href="https://snack.planetarium.dev/eng/2019/11/looking-back-at-hacktoberfest/" hreflang="en" title="Looking Back on Hacktoberfest"/><id>https://snack.planetarium.dev/kor/2019/11/looking-back-at-hacktoberfest/</id><published>2019-11-08T00:00:00+00:00</published><updated>2019-11-08T00:00:00+00:00</updated><content type="html">&lt;p>안녕하세요. 오늘은 저희 &lt;a href="https://planetariumhq.com">플라네타리움&lt;/a> 팀이 지난 10월 한 달간 &lt;a href="https://hacktoberfest.digitalocean.com/">Hacktoberfest&lt;/a>에 참가하여 받은 기여들을 소개해보려 합니다.&lt;/p>
&lt;h1 id="둘러보기">둘러보기&lt;/h1>
&lt;p>Hacktoberfest를 맞아 저희는 36개의 이슈를 준비했고, 그중 15개의 이슈가 기여를 통해 처리되었습니다.&lt;/p>
&lt;figure>&lt;img src="1.png"
alt="처리된 이슈들"/>&lt;figcaption>
&lt;p>처리된 이슈들&lt;/p>
&lt;/figcaption>
&lt;/figure>
&lt;p>한 달간 기여를 받아보니 다음과 같은 재밌는 사실도 알게 되었습니다.&lt;/p>
&lt;ul>
&lt;li>절반 정도의 기여가 월초에 집중되었습니다. 초반 스퍼트가 중요해 보이네요. 🏃&lt;/li>
&lt;li>대부분의 이슈가 초심자를 위한 이슈(&lt;code>label:&amp;quot;good first issue&amp;quot;&lt;/code>)였습니다.&lt;/li>
&lt;li>&lt;a href="https://github.com/planetarium/libplanet/">Libplanet&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet-explorer/">Libplanet Explorer&lt;/a>, &lt;a href="https://github.com/planetarium/libplanet-explorer-frontend/">Libplanet Explorer Frontend&lt;/a> 3개 프로젝트가 고르게 기여를 받았습니다.&lt;/li>
&lt;/ul>
&lt;h1 id="기억에-남는-기여들">기억에 남는 기여들&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/MaxStalker">@MaxStalker&lt;/a> 님이 작업해 주신 &lt;a href="https://github.com/planetarium/libplanet-explorer-frontend/issues/37">Auto refresh when block mined&lt;/a>는 코멘트 숫자에서도 알 수 있듯이, 꽤 난항을 겪은 이슈였습니다. Libplanet Explorer Frontend는 특성상 GraphQL 백엔드인 Libplanet Explorer가 있어야 하는데, 저희가 준비한 GraphQL 백엔드가 계속 내려가는 문제가 있어서 꽤 기다리셔야 했거든요. 😢 서비스가 정상화된 뒤에도 &lt;a href="https://discord.gg/planetarium">저희 디스코드 서버&lt;/a>에서 이런저런 트러블슈팅을 함께 해가면서 기여를 마무리해 주신 @MaxStalker 님께 이 자리를 빌려 감사의 말씀을 전합니다. 🙇&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/RozzaysRed">@RozzaysRed&lt;/a> 님은 Hackoberfest 기간 중, &lt;em>hacktoberfest&lt;/em> 레이블이 붙어있는 이슈뿐만 아니라 그렇지 않은 이슈들에도 &lt;a href="https://github.com/issues?q=assignee%3ARozzaysRed+is%3Aclosed">많은 기여&lt;/a>를 해주셨습니다. 이럴 줄 알았으면 저희가 &lt;em>hacktoberfest&lt;/em> 레이블을 좀 더 빨리, 많이 붙여둘 걸 그랬네요. 😊&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/planetarium/libplanet/issues/555">Rename “maxValue” parameters in IRandom.Next() methods&lt;/a> 이슈에서는 &lt;a href="https://github.com/pBouillon">@pBouillon&lt;/a> 님께 기여뿐 아니라 적당한 파라미터 명(&lt;code>lowerBound&lt;/code>, &lt;code>upperBound&lt;/code>)을 제안받기도 했습니다. 💬&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h1 id="마치며">마치며&lt;/h1>
&lt;p>그 밖에도 Hacktoberfest 기간 중 저희가 준비한 프로젝트에 관심과 기여를 보내 주신 모든 분들께 다시 한번 감사의 말씀 드립니다.&lt;/p>
&lt;p>Hacktoberfest는 끝났지만, 저희는 언제나 여러분을 기다리고 있습니다. 혹시 저희가 풀고 있는 문제에 관심이 있거나 함께 하고 싶으신 분은 언제라도 &lt;a href="https://discord.gg/planetarium">디스코드 대화방&lt;/a>에서 알려주세요!&lt;/p></content><author><name>문성원</name><uri>https://github.com/longfin</uri><email>swen@planetariumhq.com</email></author></entry></feed>