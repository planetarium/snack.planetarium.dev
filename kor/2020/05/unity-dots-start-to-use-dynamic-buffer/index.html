<!doctype html><html lang=ko prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#">
<head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge,chrome=1">
<meta name=description content>
<meta name=HandheldFriendly content="True">
<meta name=MobileOptimized content="320">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=keywords content>
<meta property="og:type" content="article">
<meta property="og:description" content>
<meta property="og:title" content="Unity DOTS DynamicBuffer 사용하기">
<meta property="og:site_name" content="플라네타리움 엔지니어링 스낵">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/01.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/02.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/03.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/04.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/05.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/06.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/07.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/08.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/09.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/10.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/11.png">
<meta property="og:image" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/images/12.png">
<meta property="og:image" content="https://snack.planetarium.dev/og/kor.png">
<meta property="og:url" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/">
<meta property="og:locale" content="ko">
<meta property="article:published_time" content="2020-05-18">
<meta property="article:modified_time" content="2020-05-18">
<meta name=twitter:card content="summary">
<meta name=twitter:site content="@">
<meta name=twitter:creator content="@">
<meta name=twitter:title content="Unity DOTS DynamicBuffer 사용하기 | 플라네타리움 엔지니어링 스낵">
<meta name=twitter:description content="안녕하세요. 플라네타리움에서 나인 크로니클을 개발하고 있는 현승민입니다. 해당 프로젝트는 아직 Unity DOTS를 사용하고 있지 않지만, 차기작에 적용하기 위해 열심히 공부 중인데요. 앞으로 공부한 내용을 꾸준히 공유해보려고 해요.
이번에는 DynamicBuffer<T>에 대해서 알아 볼게요. 엔티티에 동적 버퍼를 설정하고 이를 사용하는 방법에 대한 것인데요. DOTS와 관련한 첫 번째 글 치고는 몇 단계를 넘어 오기는 했지만 그 양이 적으니 관련한 내용을 함께 보시면 바로 이해하실 수 있을 것이라 생각해요.
이 글은 Unity 공식 문서와 튜토리얼 영상을 참고했어요.|">
<meta name=twitter:image:src content>
<meta name=twitter:domain content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/">
<title>Unity DOTS DynamicBuffer 사용하기</title>
<link rel=canonical href=https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/>
<link rel=alternate href=https://snack.planetarium.dev/eng/2020/05/unity-dots-start-to-use-dynamic-buffer/ hreflang=en title="How to Use Unity DOTS DynamicBuffer">
<link href=https://snack.planetarium.dev/index.xml rel=alternate type=application/atom+xml title="Unity DOTS DynamicBuffer 사용하기">
<link rel=stylesheet href=https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css>
<link rel=stylesheet href=https://snack.planetarium.dev/css/style.min.e1d6437358a5772f79ae0fd01e6ee2736e7fc6536065652581cf2a9c461d4bb0.css integrity="sha256-4dZDc1ildy95rg/QHm7ic25/xlNgZWUlgc8qnEYdS7A=">
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-132504786-2"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','UA-132504786-2')</script>
<link rel=icon href=/favicon-32x32.png type=image/png sizes=32x32>
<link rel="shortcut icon" href=/favicon.ico type=image/x-icon>
<link rel=apple-touch-icon href=/apple-touch-icon.png>
</head>
<body class="sans-serif w-90 w-60-ns center center-ns mv2 mv5-ns" itemscope itemtype=http://schema.org/Article>
<a href=https://snack.planetarium.dev/kor/ id=site-title class="b bb bw1 pb1 no-underline dark-gray">플라네타리움 엔지니어링 스낵</a>
<section id=main class=mt5>
<h1 itemprop=name id=title class=mb1>Unity DOTS DynamicBuffer 사용하기</h1>
<div class="f6 gray dib-ns">
<time itemprop=datePublished datetime=2020-05-18>
2020년 5월 18일
</time>
(<strong>한국어</strong>
&bull;
<a href=https://snack.planetarium.dev/eng/2020/05/unity-dots-start-to-use-dynamic-buffer/ hreflang=en title="How to Use Unity DOTS DynamicBuffer" class=gray>English</a>)
</div>
<article itemprop=articleBody id=content class="w-100 lh-copy">
<p>안녕하세요. <a href=https://planetariumhq.com/>플라네타리움</a>에서 <a href=https://nine-chronicles.com/>나인 크로니클</a>을 개발하고 있는 현승민입니다. 해당 프로젝트는 아직 Unity <a href=https://unity.com/dots><abbr title="Data-Oriented Technology Stack">DOTS</abbr></a>를 사용하고 있지 않지만, 차기작에 적용하기 위해 열심히 공부 중인데요. 앞으로 공부한 내용을 꾸준히 공유해보려고 해요.</p>
<p>이번에는 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html><code>DynamicBuffer&lt;T></code></a>에 대해서 알아 볼게요. 엔티티에 동적 버퍼를 설정하고 이를 사용하는 방법에 대한 것인데요. DOTS와 관련한 첫 번째 글 치고는 몇 단계를 넘어 오기는 했지만 그 양이 적으니 관련한 내용을 함께 보시면 바로 이해하실 수 있을 것이라 생각해요.</p>
<p>이 글은 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/manual/dynamic_buffers.html>Unity 공식 문서</a>와 <a href="https://www.youtube.com/watch?v=XC84bc95heI">튜토리얼 영상</a>을 참고했어요.</p>
<h2 id=개발-환경>개발 환경</h2>
<dl>
<dt>Unity</dt>
<dd>2019.3.12f1</dd>
<dt><code>com.unity.entities</code></dt>
<dd>0.10.0-preview.6</dd>
</dl>
<h2 id=ibufferelementdataibufferelementdata-구현하기><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IBufferElementData.html><code>IBufferElementData</code></a> 구현하기</h2>
<p>엔티티에 더하는 컴포넌트가 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IComponentData.html><code>IComponentData</code> 인터페이스</a>를 구현해야 하는 것과 마찬가지로, <code>DynamicBuffer&lt;T></code> 또한 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IBufferElementData.html><code>IBufferElementData</code> 인터페이스</a>를 구현해야 해요.</p>
<ul>
<li>
<p><code>IBufferElementData</code>를 구현하는 <code>IntBufferElement</code> 구조체를 만들었어요. <code>IComponentData</code>와 같은 흐름이죠?</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;

<span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
{
  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>IntBufferElement</span> : IBufferElementData
  {
    <span style=color:#080;font-weight:700>public</span> <span style=color:#888;font-weight:700>int</span> Value;
  }
}
</code></pre></div></li>
</ul>
<h2 id=entitymanageraddbuffertentitymanageraddbuffert-사용하기><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddBuffer__1_Unity_Entities_Entity_><code>EntityManager.AddBuffer&lt;T>()</code></a> 사용하기</h2>
<p>엔티티에 컴포넌트를 더하는 방법과 같이 버퍼를 더할 때도 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html><code>EntityManager</code></a>를 활용해요. 아래에서는 게임 오브젝트에 더해서 사용할 <code>PlayModeTest</code>라는 컴포넌트를 작성하고 플레이 모드에서 <em>Entity Debugger</em>를 확인해 볼게요.</p>
<ul>
<li>
<p>엔티티에 <code>IntBufferElement</code> 버퍼를 더하고, 그 버퍼에 값을 좀 넣어 볼게요.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>UnityEngine</span>;
<span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;

<span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
{
  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>PlayModeTest</span> : MonoBehaviour
  {
    <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>void</span> Awake()
    {
      <span style=color:#888;font-weight:700>var</span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
      <span style=color:#888;font-weight:700>var</span> entity = entityManager.CreateEntity();
      <span style=color:#888;font-weight:700>var</span> dynamicBuffer = entityManager.AddBuffer&lt;IntBufferElement&gt;(entity);
      dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>1</span> });
      dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>2</span> });
      dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>3</span> });
    }
  }
}
</code></pre></div></li>
<li>
<p><em>DOTS_DynamicBufferScene</em>을 만들고 <code>PlayModeTest</code> 스크립트를 같은 이름의 게임 오브젝트에 추가했어요.</p>
<p><img src=images/01.png alt></p>
</li>
<li>
<p>플레이 모드에서 <em>Entity Debugger</em> 를 통해서 <code>PlayModeTest.Awake()</code> 메서드에서 생성한 엔티티를 확인할 수 있어요. <code>IntBufferElement</code> 버퍼에 값이 세 개인 것이 보이시죠?</p>
<p><img src=images/02.png alt></p>
</li>
</ul>
<h2 id=dynamicbuffertreinterpretudynamicbuffertreinterpretu-사용하기><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html#Unity_Entities_DynamicBuffer_1_Reinterpret__1><code>DynamicBuffer&lt;T>.Reinterpret&lt;U>()</code></a> 사용하기</h2>
<p>버퍼에 담긴 구조체가 포함하는 값을 직접 수정하는 방법을 알아 볼게요.</p>
<ul>
<li>
<p><code>PlayModeTest.Awake()</code> 메서드를 조금 수정해서 재해석이라는 의미의 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html#Unity_Entities_DynamicBuffer_1_Reinterpret__1><code>DynamicBuffer&lt;T>.Reinterpret&lt;U>()</code> 메서드</a>를 사용해 봤어요. 12번 줄에서와 같이 인덱스로 접근한 구조체는 변수로 분류되지 않는 임시 값이기 때문에 변경할 수 없는데, 14&ndash;15번 줄에서와 같은 방법을 사용하면 값을 수정할 수 있어요.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>void</span> Awake()
{
    <span style=color:#888;font-weight:700>var</span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
    <span style=color:#888;font-weight:700>var</span> entity = entityManager.CreateEntity();
    <span style=color:#888;font-weight:700>var</span> dynamicBuffer = entityManager.AddBuffer&lt;IntBufferElement&gt;(entity);
    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement {Value = <span style=color:#00d;font-weight:700>1</span>});
    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement {Value = <span style=color:#00d;font-weight:700>2</span>});
    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement {Value = <span style=color:#00d;font-weight:700>3</span>});

    <span style=color:#888>// ERROR: Indexer access returns temporary value.
</span><span style=color:#888></span>    <span style=color:#888>// Cannot modify struct member when accessed struct is not classified as a variable
</span><span style=color:#888></span>    <span style=color:#888>// dynamicBuffer[0].Value *= 10;
</span><span style=color:#888></span>
    <span style=color:#888;font-weight:700>var</span> intDynamicBuffer = dynamicBuffer.Reinterpret&lt;<span style=color:#888;font-weight:700>int</span>&gt;();
    intDynamicBuffer[<span style=color:#00d;font-weight:700>0</span>] *= <span style=color:#00d;font-weight:700>10</span>;
}
</code></pre></div></li>
<li>
<p>값이 바뀌었는지 플레이 모드에서 확인해 볼게요. 잘 바뀌었네요! 15번 줄에서 변경한 <code>intDynamicBuffer[0]</code>의 값을 <code>dynamicBuffer[0]</code>에 다시 넣지 않았는데 버퍼의 값이 바뀐 것이 중요한 점으로 보여요.</p>
<p><img src=images/03.png alt></p>
</li>
</ul>
<h2 id=entitymanagergetbuffertentitymanagergetbuffert-사용하기><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_GetBuffer__1_Unity_Entities_Entity_><code>EntityManager.GetBuffer&lt;T>()</code></a> 사용하기</h2>
<p>엔티티의 버퍼에 접근하는 방법도 필요하겠죠?</p>
<ul>
<li>
<p><code>PlayModeTest</code> 클래스를 수정했어요. <code>Awake()</code> 메서드에서 생성한 엔티티와 이것에 추가한 버퍼를 <code>Start()</code> 메서드에서 불러와서 값을 수정했어요.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>PlayModeTest</span> : MonoBehaviour
{
  <span style=color:#080;font-weight:700>private</span> Entity <span style=color:#00d;font-weight:700>_</span>entity;

  <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>void</span> Awake()
  {
    <span style=color:#888;font-weight:700>var</span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
    <span style=color:#00d;font-weight:700>_</span>entity = entityManager.CreateEntity();

    <span style=color:#888;font-weight:700>var</span> dynamicBuffer = entityManager.AddBuffer&lt;IntBufferElement&gt;(<span style=color:#00d;font-weight:700>_</span>entity);
    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>1</span> });
    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>2</span> });
    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>3</span> });

    <span style=color:#888>// ERROR: Indexer access returns temporary value.
</span><span style=color:#888></span>    <span style=color:#888>// Cannot modify struct member when accessed struct is not classified as a variable
</span><span style=color:#888></span>    <span style=color:#888>// dynamicBuffer[0].Value *= 10;
</span><span style=color:#888></span>    <span style=color:#888;font-weight:700>var</span> intDynamicBuffer = dynamicBuffer.Reinterpret&lt;<span style=color:#888;font-weight:700>int</span>&gt;();
    intDynamicBuffer[<span style=color:#00d;font-weight:700>0</span>] *= <span style=color:#00d;font-weight:700>10</span>;
  }

  <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>void</span> Start()
  {
    <span style=color:#888;font-weight:700>var</span> entityManger = World.DefaultGameObjectInjectionWorld.EntityManager;
    <span style=color:#888;font-weight:700>var</span> dynamicBuffer = entityManger.GetBuffer&lt;IntBufferElement&gt;(<span style=color:#00d;font-weight:700>_</span>entity);
    <span style=color:#888;font-weight:700>var</span> intDynamicBuffer = dynamicBuffer.Reinterpret&lt;<span style=color:#888;font-weight:700>int</span>&gt;();
    <span style=color:#080;font-weight:700>for</span> (<span style=color:#888;font-weight:700>var</span> i = <span style=color:#00d;font-weight:700>0</span>; i &lt; intDynamicBuffer.Length; i++)
    {
      intDynamicBuffer[i]++;
    }
  }
}
</code></pre></div></li>
<li>
<p>잘 동작하는지 확인할게요. 버퍼 내의 모든 값이 1씩 증가한 것이 보이네요! 여전히 신기한 <code>Reinterpret&lt;T>()</code>.</p>
<p><img src=images/04.png alt></p>
</li>
</ul>
<h2 id=authoring>Authoring</h2>
<p><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.GenerateAuthoringComponentAttribute.html><code>GenerateAuthoringComponentAttribute</code></a>를 적용하면 게임 오브젝트에 Authoring Component를 더해서 엔티티로 만들 수 있죠. <code>IBufferElementData</code>도 같은 방법을 사용할 수 있어요.</p>
<ul>
<li>
<p><code>IntBufferElement</code>를 수정해서 <code>GenerateAuthoringComponentAttribute</code>를 적용할게요.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#369>[GenerateAuthoringComponent]</span>
<span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>IntBufferElement</span> : IBufferElementData
{
  <span style=color:#080;font-weight:700>public</span> <span style=color:#888;font-weight:700>int</span> Value;
}
</code></pre></div></li>
<li>
<p>그리고 Scene을 수정해서 자동으로 생성된 <code>IntBufferElementAuthoring</code> 컴포넌트를 게임 오브젝트에 더하고 값을 넣어 봤어요. 그리고 게임 오브젝트의 엔티티화를 위해서 <code>ConvertToEntity</code> 컴포넌트를 더했어요.</p>
<p><img src=images/05.png alt></p>
</li>
<li>
<p><em>Entity Debugger</em>로 보면 <strong>Authoring</strong> 컴포넌트가 더해져 있던 게임 오브젝트와 같은 이름의 엔티티가 생성된 것을 확인할 수 있어요.</p>
<p><img src=images/06.png alt></p>
</li>
<li>
<p>이후 과정을 위해 <code>UnitTag</code>와 <code>PlayerTag</code>, <code>EnemyTag</code> 컴포넌트를 작성해서 각 컴포넌트를 포함하는 엔티티에 <code>IntBufferElement</code> 버퍼를 더해 볼게요.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;

<span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
{
<span style=color:#369>  [GenerateAuthoringComponent]</span>
  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>UnitTag</span> : IComponentData { }
<span style=color:#369>
</span><span style=color:#369>  [GenerateAuthoringComponent]</span>
  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>PlayerTag</span> : IComponentData { }
<span style=color:#369>
</span><span style=color:#369>  [GenerateAuthoringComponent]</span>
  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>EnemyTag</span> : IComponentData { }
}
</code></pre></div><p><img src=images/07.png alt></p>
<p><img src=images/08.png alt></p>
</li>
</ul>
<h2 id=componentsystem에서-사용하기><code>ComponentSystem</code>에서 사용하기</h2>
<p><code>ComponentSystem</code>을 상속하는 시스템을 작성해서 <code>UnitTag</code> 컴포넌트를 포함하는 엔티티의 <code>IntBufferElement</code> <code>DynamicBuffer</code>에 접근해 볼게요.</p>
<ul>
<li>
<p><code>TestBufferFromEntitySystem</code>을 작성했어요. <code>UnitTag</code>를 포함하는 엔티티들의 <code>IntBufferElement</code>형 <code>DynamicBuffer</code>에 접근해서 값을 변경하는 로직이에요. 20번 줄과 같이 사용하는 것은 안 되니 23&ndash;28번 줄과 같이 사용해요. 물론 <code>Reinterpret&lt;T>()</code>도 사용할 수 있겠죠?</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;

<span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
{
  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>TestBufferFromEntitySystem</span> : ComponentSystem
  {
    <span style=color:#080;font-weight:700>protected</span> <span style=color:#080;font-weight:700>override</span> <span style=color:#080;font-weight:700>void</span> OnUpdate()
    {
      <span style=color:#888;font-weight:700>var</span> bufferFromEntity = GetBufferFromEntity&lt;IntBufferElement&gt;();
      Entities
        .WithAll&lt;UnitTag&gt;()
        .ForEach(entity =&gt;
        {
          <span style=color:#080;font-weight:700>if</span> (bufferFromEntity.Exists(entity))
          {
            <span style=color:#888;font-weight:700>var</span> dynamicBufferFromUnitTag = bufferFromEntity[entity];
            <span style=color:#080;font-weight:700>foreach</span> (<span style=color:#888;font-weight:700>var</span> intBufferElement <span style=color:#080;font-weight:700>in</span> dynamicBufferFromUnitTag)
            {
              <span style=color:#888>// Foreach iteration variable &#39;intBufferElement&#39; is immutable.
</span><span style=color:#888></span>              <span style=color:#888>// Cannot modify struct member when accessed struct is not classified as a variable
</span><span style=color:#888></span>              <span style=color:#888>// intBufferElement.Value++;
</span><span style=color:#888></span>            }

            <span style=color:#080;font-weight:700>for</span> (<span style=color:#888;font-weight:700>var</span> i = <span style=color:#00d;font-weight:700>0</span>; i &lt; dynamicBufferFromUnitTag.Length; i++)
            {
              <span style=color:#888;font-weight:700>var</span> intBufferElement = dynamicBufferFromUnitTag[i];
              intBufferElement.Value++;
              dynamicBufferFromUnitTag[i] = intBufferElement;
            }
          }
        });
    }
  }
}
</code></pre></div></li>
<li>
<p>플레이 모드에서 <em>Entity Debugger</em>를 보면 <code>UnitTag</code> 컴포넌트를 포함하는 엔티티의 <code>IntBufferElement</code> <code>DynamicBuffer</code>의 값이 변하는 것을 확인할 수 있어요.</p>
<p><img src=images/09.png alt></p>
</li>
</ul>
<h2 id=jobcomponentsystem에서-사용하기><code>JobComponentSystem</code>에서 사용하기</h2>
<p><code>JobComponentSystem</code>을 상속하는 시스템을 작성해서 <code>PlayerTag</code> 컴포넌트를 포함하는 엔티티의 <code>IntBufferElement</code> <code>DynamicBuffer</code>에 접근해 볼게요.</p>
<ul>
<li>
<p><code>TestBufferFromEntityJobSystem</code>을 작성했어요. <code>PlayerTag</code>를 포함하는 엔티티들의 <code>IntBufferElement</code>형 <code>DynamicBuffer</code>에 접근해서 값을 변경하는 로직이에요. 이번에는 <code>Reinterpret&lt;T>()</code>를 사용해 봤어요.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;
<span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Jobs</span>;

<span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
{
  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>TestBufferFromEntityJobSystem</span> : JobComponentSystem
  {
    <span style=color:#080;font-weight:700>protected</span> <span style=color:#080;font-weight:700>override</span> JobHandle OnUpdate(JobHandle inputDeps)
    {
      <span style=color:#080;font-weight:700>return</span> Entities
        .WithAll&lt;PlayerTag&gt;()
        .ForEach((<span style=color:#080;font-weight:700>ref</span> DynamicBuffer&lt;IntBufferElement&gt; dynamicBuffer) =&gt;
        {
          <span style=color:#888;font-weight:700>var</span> intDynamicBuffer = dynamicBuffer.Reinterpret&lt;<span style=color:#888;font-weight:700>int</span>&gt;();
          <span style=color:#080;font-weight:700>for</span> (<span style=color:#888;font-weight:700>var</span> i = <span style=color:#00d;font-weight:700>0</span>; i &lt; intDynamicBuffer.Length; i++)
          {
            intDynamicBuffer[i]++;
          }
        })
        .Schedule(inputDeps);
    }
  }
}
</code></pre></div></li>
<li>
<p>잘 동작하네요! 값이 쭉쭉 올라가고 있어요.</p>
<p><img src=images/10.png alt></p>
</li>
</ul>
<h2 id=팁들>팁들</h2>
<h3 id=internalbuffercapacityattributeinternalbuffercapacityattribute><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.InternalBufferCapacityAttribute.html><code>InternalBufferCapacityAttribute</code></a></h3>
<p>엔티티는 기본적으로 청크에 포함되는데, <code>IBufferElementData</code>를 구현하는 구조체에 <code>InternalBufferCapacityAttribute</code>를 적용하면 청크 내 존재할 수 있는 최대 요소 수를 지정할 수 있어요. 지정한 요소 수를 넘어서면 해당 버퍼는 힙 메모리로 이동해요. 물론 이때에도 이전과 같이 <code>DynamicBuffer</code> API로 해당 버퍼에 접근할 수 있어요.</p>
<ul>
<li>
<p>요소 수를 2개로 설정해 봤어요.</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#888>// InternalBufferCapacity specifies how many elements a buffer can have before
</span><span style=color:#888>// the buffer storage is moved outside the chunk.
</span><span style=color:#888></span><span style=color:#369>[InternalBufferCapacity(2)]</span>
<span style=color:#369>[GenerateAuthoringComponent]</span>
<span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>IntBufferElement</span> : IBufferElementData
{
  <span style=color:#080;font-weight:700>public</span> <span style=color:#888;font-weight:700>int</span> Value;
}
</code></pre></div></li>
<li>
<p>그리고 같은 청크에서 테스트하기 위해서 <code>EnemyTag</code>를 포함하는 Enemy 게임 오브젝트를 두 개 더 복재했어요.</p>
<p><img src=images/11.png alt></p>
</li>
<li>
<p><em>Entity Debugger</em>를 확인해 봤어요. 그런데 <code>IntBufferElement</code>가 여전히 청크에 남아 있는 것 처럼 보이네요. 힙 메모리로 이동됐어도 편의를 위해서 이렇게 보여주는 것인지는 확인이 필요하겠어요.</p>
<p><img src=images/12.png alt></p>
</li>
</ul>
<h3 id=implicit-연산자><code>implicit</code> 연산자</h3>
<p>편의를 위해서 이렇게 작성해서 사용할 수도 있겠죠?</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;

<span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
{
  <span style=color:#888>// InternalBufferCapacity specifies how many elements a buffer can have before
</span><span style=color:#888></span>  <span style=color:#888>// the buffer storage is moved outside the chunk.
</span><span style=color:#888></span><span style=color:#369>  [InternalBufferCapacity(2)]</span>
<span style=color:#369>  [GenerateAuthoringComponent]</span>
  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>IntBufferElement</span> : IBufferElementData
  {
    <span style=color:#080;font-weight:700>public</span> <span style=color:#888;font-weight:700>int</span> Value;

    <span style=color:#888>// The following implicit conversions are optional, but can be convenient.
</span><span style=color:#888></span>    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#080;font-weight:700>implicit</span> <span style=color:#080;font-weight:700>operator</span> <span style=color:#888;font-weight:700>int</span>(IntBufferElement e)

    {
      <span style=color:#080;font-weight:700>return</span> e.Value;
    }

    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#080;font-weight:700>implicit</span> <span style=color:#080;font-weight:700>operator</span> IntBufferElement(<span style=color:#888;font-weight:700>int</span> e)

    {
      <span style=color:#080;font-weight:700>return</span> <span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = e };
    }
  }
}
</code></pre></div><h2 id=마치며>마치며</h2>
<p><code>IBufferElementData</code>와 <code>DynamicBuffer&lt;T></code>를 가볍게 알아 봤어요.</p>
<p>게임을 만들 때 오브젝트 풀링에 대해서 수도 없이 많이 들어 보셨을 거예요. 1회용 객체를 생성하는 것은 쓰레기를 만드는 것이기에 풀링해서 재사용하면 잦은 <a href=https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)>쓰레기 수집</a>을 줄이고 인스턴스 생성 타이밍을 관리할 수 있어서 더욱 부드러운 게임을 만들 수 있죠.</p>
<p>다음에는 이 기능을 게임에 어떻게 적용하는지 알아보고, 적용하기 전과 후를 비교하면서 어느정도 효과를 얻을 수 있는지 확인해 볼게요.</p>
</article>
<script>(function(){var d,h,e,a,g,c,f,b;if(!location.hash.match(/^#/))return;if(d=document.getElementById('content'),h=window.decodeURIComponent(location.hash.substring(1)),e=document.getElementById(h),a=e.nodeName.match(/^H([123456])$/),!a||e.parentNode!==d)return;g=window.parseInt(a[1]),c=!1;for(f=0;f<d.childNodes.length;f++)b=d.childNodes[f],c?(a=b.nodeName.match(/^H([123456])$/),a&&window.parseInt(a[1])>=g&&(c=!1)):b===e&&(c=!0),!c&&!b.nodeName.match(/^#/)&&(b.className+=' dim')})()</script>
<div class=recruit>
<a href=https://planetariumhq.com>플라네타리움</a>은 게임에 특화된 오픈 소스 P2P 라이브러리 <a href=https://libplanet.io/>Libplanet</a>과, 그 위에서 중앙 서버 없는 온라인 게임 <a href=https://nine-chronicles.com/>나인 크로니클</a>을 만들고 있습니다. 저희와 흥미로운 기술적 도전을 함께 하실 분들을 모시고 있습니다. 지금 <a href=https://recruit.planetariumhq.com/>채용 페이지</a>를 확인해주세요!
</div>
<div itemprop=author class="fl tc mr3">
<a href=https://github.com/boscohyun rel=author itemprop=url class="no-underline mid-gray b f6">
<img src="https://www.gravatar.com/avatar/c34d881a6bfa3ddba681523b2b732607?d=https://avatars.githubusercontent.com/boscohyun" itemprop=image class="w3 h3 br-100 mb1">
<br>현승민
</a>
</div>
</section>
<footer>
<div>
<p class="f6 gray mt6 lh-copy">
&copy; 2019&ndash;2021
<a href=https://planetariumhq.com/ style=color:inherit;text-decoration:inherit>Planetarium</a>.
</p>
</div>
</footer>
</body>
</html>