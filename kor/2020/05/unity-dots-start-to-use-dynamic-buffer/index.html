<!doctype html><html lang=ko prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb#"><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><meta name=description content><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=keywords content><meta property="og:type" content="article"><meta property="og:description" content><meta property="og:title" content="Unity DOTS DynamicBuffer 사용하기"><meta property="og:site_name" content="플라네타리움 엔지니어링 스낵"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/01.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/02.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/03.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/04.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/05.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/06.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/07.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/08.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/09.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/10.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/11.png"><meta property="og:image" content="https://snack.planetarium.dev/1/01/unity-dots-start-to-use-dynamic-buffer/images/12.png"><meta property="og:url" content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/"><meta property="og:locale" content="ko"><meta property="article:published_time" content="2020-05-18"><meta property="article:modified_time" content="2020-05-18"><meta name=twitter:card content="summary"><meta name=twitter:site content="@"><meta name=twitter:creator content="@"><meta name=twitter:title content="Unity DOTS DynamicBuffer 사용하기 | 플라네타리움 엔지니어링 스낵"><meta name=twitter:description content="안녕하세요. 플라네타리움에서 나인 크로니클을 개발하고 있는 현승민입니다. 해당 프로젝트는 아직 Unity DOTS를 사용하고 있지 않지만, 차기작에 적용하기 위해 열심히 공부 중인데요. 앞으로 공부한 내용을 꾸준히 공유해보려고 해요.
이번에는 DynamicBuffer<T>에 대해서 알아 볼게요. 엔티티에 동적 버퍼를 설정하고 이를 사용하는 방법에 대한 것인데요. DOTS와 관련한 첫 번째 글 치고는 몇 단계를 넘어 오기는 했지만 그 양이 적으니 관련한 내용을 함께 보시면 바로 이해하실 수 있을 것이라 생각해요.|"><meta name=twitter:image:src content><meta name=twitter:domain content="https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/"><title>Unity DOTS DynamicBuffer 사용하기</title>
<link rel=canonical href=https://snack.planetarium.dev/kor/2020/05/unity-dots-start-to-use-dynamic-buffer/><link rel=alternate href=https://snack.planetarium.dev/eng/2020/05/unity-dots-start-to-use-dynamic-buffer/ hreflang=en title="How to Use Unity DOTS DynamicBuffer"><link href=https://snack.planetarium.dev/index.xml rel=alternate type=application/atom+xml title="Unity DOTS DynamicBuffer 사용하기"><link rel=stylesheet href=https://unpkg.com/tachyons@4.10.0/css/tachyons.min.css><link rel=stylesheet href=https://snack.planetarium.dev/css/style.min.1a35efb5c5da4fd20bd2ec86458da5ee7cc1cfc81c4f107944b5e0fc59a3d809.css integrity="sha256-GjXvtcXaT9IL0uyGRY2l7nzBz8gcTxB5RLXg/Fmj2Ak="><script async src="https://www.googletagmanager.com/gtag/js?id=UA-132504786-2"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-132504786-2")</script><link rel=icon href=/favicon-32x32.png type=image/png sizes=32x32><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link rel=apple-touch-icon href=/apple-touch-icon.png></head><body class="sans-serif w-90 w-60-ns center center-ns mv2 mv5-ns" itemscope itemtype=http://schema.org/Article><a href=https://snack.planetarium.dev/kor/ id=site-title class="b bb bw1 pb1 no-underline dark-gray">플라네타리움 엔지니어링 스낵</a><section id=main class=mt5><h1 itemprop=name id=title class=mb1>Unity DOTS DynamicBuffer 사용하기</h1><div class="f6 gray dib-ns"><time itemprop=datePublished datetime=2020-05-18>2020년 5월 18일
</time>(<strong></strong>
&bull;
<a href=https://snack.planetarium.dev/eng/2020/05/unity-dots-start-to-use-dynamic-buffer/ hreflang=en title="How to Use Unity DOTS DynamicBuffer" class=gray></a>)</div><article itemprop=articleBody id=content class="w-100 lh-copy"><p>안녕하세요. <a href=https://planetariumhq.com/>플라네타리움</a>에서 <a href=https://nine-chronicles.com/>나인 크로니클</a>을 개발하고 있는 현승민입니다. 해당 프로젝트는 아직 Unity <a href=https://unity.com/dots><abbr title="Data-Oriented Technology Stack">DOTS</abbr></a>를 사용하고 있지 않지만, 차기작에 적용하기 위해 열심히 공부 중인데요. 앞으로 공부한 내용을 꾸준히 공유해보려고 해요.</p><p>이번에는 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html><code>DynamicBuffer&lt;T></code></a>에 대해서 알아 볼게요. 엔티티에 동적 버퍼를 설정하고 이를 사용하는 방법에 대한 것인데요. DOTS와 관련한 첫 번째 글 치고는 몇 단계를 넘어 오기는 했지만 그 양이 적으니 관련한 내용을 함께 보시면 바로 이해하실 수 있을 것이라 생각해요.</p><p>이 글은 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/manual/dynamic_buffers.html>Unity 공식 문서</a>와 <a href="https://www.youtube.com/watch?v=XC84bc95heI">튜토리얼 영상</a>을 참고했어요.</p><h2 id=개발-환경>개발 환경</h2><dl><dt>Unity</dt><dd>2019.3.12f1</dd><dt><code>com.unity.entities</code></dt><dd>0.10.0-preview.6</dd></dl><h2 id=ibufferelementdataibufferelementdata-구현하기><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IBufferElementData.html><code>IBufferElementData</code></a> 구현하기</h2><p>엔티티에 더하는 컴포넌트가 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IComponentData.html><code>IComponentData</code> 인터페이스</a>를 구현해야 하는 것과 마찬가지로, <code>DynamicBuffer&lt;T></code> 또한 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.IBufferElementData.html><code>IBufferElementData</code> 인터페이스</a>를 구현해야 해요.</p><ul><li><p><code>IBufferElementData</code>를 구현하는 <code>IntBufferElement</code> 구조체를 만들었어요. <code>IComponentData</code>와 같은 흐름이죠?</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>IntBufferElement</span> : IBufferElementData
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>public</span> <span style=color:#888;font-weight:700>int</span> Value;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><h2 id=entitymanageraddbuffertentitymanageraddbuffert-사용하기><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddBuffer__1_Unity_Entities_Entity_><code>EntityManager.AddBuffer&lt;T>()</code></a> 사용하기</h2><p>엔티티에 컴포넌트를 더하는 방법과 같이 버퍼를 더할 때도 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html><code>EntityManager</code></a>를 활용해요. 아래에서는 게임 오브젝트에 더해서 사용할 <code>PlayModeTest</code>라는 컴포넌트를 작성하고 플레이 모드에서 <em>Entity Debugger</em>를 확인해 볼게요.</p><ul><li><p>엔티티에 <code>IntBufferElement</code> 버퍼를 더하고, 그 버퍼에 값을 좀 넣어 볼게요.</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>UnityEngine</span>;
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>PlayModeTest</span> : MonoBehaviour
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>void</span> Awake()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#888;font-weight:700>var</span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
</span></span><span style=display:flex><span>      <span style=color:#888;font-weight:700>var</span> entity = entityManager.CreateEntity();
</span></span><span style=display:flex><span>      <span style=color:#888;font-weight:700>var</span> dynamicBuffer = entityManager.AddBuffer&lt;IntBufferElement&gt;(entity);
</span></span><span style=display:flex><span>      dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>1</span> });
</span></span><span style=display:flex><span>      dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>2</span> });
</span></span><span style=display:flex><span>      dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>3</span> });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p><em>DOTS_DynamicBufferScene</em>을 만들고 <code>PlayModeTest</code> 스크립트를 같은 이름의 게임 오브젝트에 추가했어요.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/01.png></p></li><li><p>플레이 모드에서 <em>Entity Debugger</em> 를 통해서 <code>PlayModeTest.Awake()</code> 메서드에서 생성한 엔티티를 확인할 수 있어요. <code>IntBufferElement</code> 버퍼에 값이 세 개인 것이 보이시죠?</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/02.png></p></li></ul><h2 id=dynamicbuffertreinterpretudynamicbuffertreinterpretu-사용하기><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html#Unity_Entities_DynamicBuffer_1_Reinterpret__1><code>DynamicBuffer&lt;T>.Reinterpret&lt;U>()</code></a> 사용하기</h2><p>버퍼에 담긴 구조체가 포함하는 값을 직접 수정하는 방법을 알아 볼게요.</p><ul><li><p><code>PlayModeTest.Awake()</code> 메서드를 조금 수정해서 재해석이라는 의미의 <a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.DynamicBuffer-1.html#Unity_Entities_DynamicBuffer_1_Reinterpret__1><code>DynamicBuffer&lt;T>.Reinterpret&lt;U>()</code> 메서드</a>를 사용해 봤어요. 12번 줄에서와 같이 인덱스로 접근한 구조체는 변수로 분류되지 않는 임시 값이기 때문에 변경할 수 없는데, 14&ndash;15번 줄에서와 같은 방법을 사용하면 값을 수정할 수 있어요.</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>void</span> Awake()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> entity = entityManager.CreateEntity();
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> dynamicBuffer = entityManager.AddBuffer&lt;IntBufferElement&gt;(entity);
</span></span><span style=display:flex><span>    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement {Value = <span style=color:#00d;font-weight:700>1</span>});
</span></span><span style=display:flex><span>    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement {Value = <span style=color:#00d;font-weight:700>2</span>});
</span></span><span style=display:flex><span>    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement {Value = <span style=color:#00d;font-weight:700>3</span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#888>// ERROR: Indexer access returns temporary value.</span>
</span></span><span style=display:flex><span>    <span style=color:#888>// Cannot modify struct member when accessed struct is not classified as a variable</span>
</span></span><span style=display:flex><span>    <span style=color:#888>// dynamicBuffer[0].Value *= 10;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> intDynamicBuffer = dynamicBuffer.Reinterpret&lt;<span style=color:#888;font-weight:700>int</span>&gt;();
</span></span><span style=display:flex><span>    intDynamicBuffer[<span style=color:#00d;font-weight:700>0</span>] *= <span style=color:#00d;font-weight:700>10</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>값이 바뀌었는지 플레이 모드에서 확인해 볼게요. 잘 바뀌었네요! 15번 줄에서 변경한 <code>intDynamicBuffer[0]</code>의 값을 <code>dynamicBuffer[0]</code>에 다시 넣지 않았는데 버퍼의 값이 바뀐 것이 중요한 점으로 보여요.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/03.png></p></li></ul><h2 id=entitymanagergetbuffertentitymanagergetbuffert-사용하기><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_GetBuffer__1_Unity_Entities_Entity_><code>EntityManager.GetBuffer&lt;T>()</code></a> 사용하기</h2><p>엔티티의 버퍼에 접근하는 방법도 필요하겠죠?</p><ul><li><p><code>PlayModeTest</code> 클래스를 수정했어요. <code>Awake()</code> 메서드에서 생성한 엔티티와 이것에 추가한 버퍼를 <code>Start()</code> 메서드에서 불러와서 값을 수정했어요.</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>PlayModeTest</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>private</span> Entity _entity;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>void</span> Awake()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> entityManager = World.DefaultGameObjectInjectionWorld.EntityManager;
</span></span><span style=display:flex><span>    _entity = entityManager.CreateEntity();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> dynamicBuffer = entityManager.AddBuffer&lt;IntBufferElement&gt;(_entity);
</span></span><span style=display:flex><span>    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>1</span> });
</span></span><span style=display:flex><span>    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>2</span> });
</span></span><span style=display:flex><span>    dynamicBuffer.Add(<span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = <span style=color:#00d;font-weight:700>3</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#888>// ERROR: Indexer access returns temporary value.</span>
</span></span><span style=display:flex><span>    <span style=color:#888>// Cannot modify struct member when accessed struct is not classified as a variable</span>
</span></span><span style=display:flex><span>    <span style=color:#888>// dynamicBuffer[0].Value *= 10;</span>
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> intDynamicBuffer = dynamicBuffer.Reinterpret&lt;<span style=color:#888;font-weight:700>int</span>&gt;();
</span></span><span style=display:flex><span>    intDynamicBuffer[<span style=color:#00d;font-weight:700>0</span>] *= <span style=color:#00d;font-weight:700>10</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>private</span> <span style=color:#080;font-weight:700>void</span> Start()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> entityManger = World.DefaultGameObjectInjectionWorld.EntityManager;
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> dynamicBuffer = entityManger.GetBuffer&lt;IntBufferElement&gt;(_entity);
</span></span><span style=display:flex><span>    <span style=color:#888;font-weight:700>var</span> intDynamicBuffer = dynamicBuffer.Reinterpret&lt;<span style=color:#888;font-weight:700>int</span>&gt;();
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>for</span> (<span style=color:#888;font-weight:700>var</span> i = <span style=color:#00d;font-weight:700>0</span>; i &lt; intDynamicBuffer.Length; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      intDynamicBuffer[i]++;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>잘 동작하는지 확인할게요. 버퍼 내의 모든 값이 1씩 증가한 것이 보이네요! 여전히 신기한 <code>Reinterpret&lt;T>()</code>.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/04.png></p></li></ul><h2 id=authoring>Authoring</h2><p><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.GenerateAuthoringComponentAttribute.html><code>GenerateAuthoringComponentAttribute</code></a>를 적용하면 게임 오브젝트에 Authoring Component를 더해서 엔티티로 만들 수 있죠. <code>IBufferElementData</code>도 같은 방법을 사용할 수 있어요.</p><ul><li><p><code>IntBufferElement</code>를 수정해서 <code>GenerateAuthoringComponentAttribute</code>를 적용할게요.</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#369>[GenerateAuthoringComponent]</span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>IntBufferElement</span> : IBufferElementData
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#888;font-weight:700>int</span> Value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>그리고 Scene을 수정해서 자동으로 생성된 <code>IntBufferElementAuthoring</code> 컴포넌트를 게임 오브젝트에 더하고 값을 넣어 봤어요. 그리고 게임 오브젝트의 엔티티화를 위해서 <code>ConvertToEntity</code> 컴포넌트를 더했어요.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/05.png></p></li><li><p><em>Entity Debugger</em>로 보면 <strong>Authoring</strong> 컴포넌트가 더해져 있던 게임 오브젝트와 같은 이름의 엔티티가 생성된 것을 확인할 수 있어요.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/06.png></p></li><li><p>이후 과정을 위해 <code>UnitTag</code>와 <code>PlayerTag</code>, <code>EnemyTag</code> 컴포넌트를 작성해서 각 컴포넌트를 포함하는 엔티티에 <code>IntBufferElement</code> 버퍼를 더해 볼게요.</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#369>  [GenerateAuthoringComponent]</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>UnitTag</span> : IComponentData { }
</span></span><span style=display:flex><span><span style=color:#369>
</span></span></span><span style=display:flex><span><span style=color:#369>  [GenerateAuthoringComponent]</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>PlayerTag</span> : IComponentData { }
</span></span><span style=display:flex><span><span style=color:#369>
</span></span></span><span style=display:flex><span><span style=color:#369>  [GenerateAuthoringComponent]</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>EnemyTag</span> : IComponentData { }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/07.png></p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/08.png></p></li></ul><h2 id=componentsystem에서-사용하기><code>ComponentSystem</code>에서 사용하기</h2><p><code>ComponentSystem</code>을 상속하는 시스템을 작성해서 <code>UnitTag</code> 컴포넌트를 포함하는 엔티티의 <code>IntBufferElement</code> <code>DynamicBuffer</code>에 접근해 볼게요.</p><ul><li><p><code>TestBufferFromEntitySystem</code>을 작성했어요. <code>UnitTag</code>를 포함하는 엔티티들의 <code>IntBufferElement</code>형 <code>DynamicBuffer</code>에 접근해서 값을 변경하는 로직이에요. 20번 줄과 같이 사용하는 것은 안 되니 23&ndash;28번 줄과 같이 사용해요. 물론 <code>Reinterpret&lt;T>()</code>도 사용할 수 있겠죠?</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>TestBufferFromEntitySystem</span> : ComponentSystem
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>protected</span> <span style=color:#080;font-weight:700>override</span> <span style=color:#080;font-weight:700>void</span> OnUpdate()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#888;font-weight:700>var</span> bufferFromEntity = GetBufferFromEntity&lt;IntBufferElement&gt;();
</span></span><span style=display:flex><span>      Entities
</span></span><span style=display:flex><span>        .WithAll&lt;UnitTag&gt;()
</span></span><span style=display:flex><span>        .ForEach(entity =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>if</span> (bufferFromEntity.Exists(entity))
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>            <span style=color:#888;font-weight:700>var</span> dynamicBufferFromUnitTag = bufferFromEntity[entity];
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>foreach</span> (<span style=color:#888;font-weight:700>var</span> intBufferElement <span style=color:#080;font-weight:700>in</span> dynamicBufferFromUnitTag)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              <span style=color:#888>// Foreach iteration variable &#39;intBufferElement&#39; is immutable.</span>
</span></span><span style=display:flex><span>              <span style=color:#888>// Cannot modify struct member when accessed struct is not classified as a variable</span>
</span></span><span style=display:flex><span>              <span style=color:#888>// intBufferElement.Value++;</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#080;font-weight:700>for</span> (<span style=color:#888;font-weight:700>var</span> i = <span style=color:#00d;font-weight:700>0</span>; i &lt; dynamicBufferFromUnitTag.Length; i++)
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>              <span style=color:#888;font-weight:700>var</span> intBufferElement = dynamicBufferFromUnitTag[i];
</span></span><span style=display:flex><span>              intBufferElement.Value++;
</span></span><span style=display:flex><span>              dynamicBufferFromUnitTag[i] = intBufferElement;
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>플레이 모드에서 <em>Entity Debugger</em>를 보면 <code>UnitTag</code> 컴포넌트를 포함하는 엔티티의 <code>IntBufferElement</code> <code>DynamicBuffer</code>의 값이 변하는 것을 확인할 수 있어요.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/09.png></p></li></ul><h2 id=jobcomponentsystem에서-사용하기><code>JobComponentSystem</code>에서 사용하기</h2><p><code>JobComponentSystem</code>을 상속하는 시스템을 작성해서 <code>PlayerTag</code> 컴포넌트를 포함하는 엔티티의 <code>IntBufferElement</code> <code>DynamicBuffer</code>에 접근해 볼게요.</p><ul><li><p><code>TestBufferFromEntityJobSystem</code>을 작성했어요. <code>PlayerTag</code>를 포함하는 엔티티들의 <code>IntBufferElement</code>형 <code>DynamicBuffer</code>에 접근해서 값을 변경하는 로직이에요. 이번에는 <code>Reinterpret&lt;T>()</code>를 사용해 봤어요.</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Jobs</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>class</span> <span style=color:#b06;font-weight:700>TestBufferFromEntityJobSystem</span> : JobComponentSystem
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>protected</span> <span style=color:#080;font-weight:700>override</span> JobHandle OnUpdate(JobHandle inputDeps)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>return</span> Entities
</span></span><span style=display:flex><span>        .WithAll&lt;PlayerTag&gt;()
</span></span><span style=display:flex><span>        .ForEach((<span style=color:#080;font-weight:700>ref</span> DynamicBuffer&lt;IntBufferElement&gt; dynamicBuffer) =&gt;
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#888;font-weight:700>var</span> intDynamicBuffer = dynamicBuffer.Reinterpret&lt;<span style=color:#888;font-weight:700>int</span>&gt;();
</span></span><span style=display:flex><span>          <span style=color:#080;font-weight:700>for</span> (<span style=color:#888;font-weight:700>var</span> i = <span style=color:#00d;font-weight:700>0</span>; i &lt; intDynamicBuffer.Length; i++)
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>            intDynamicBuffer[i]++;
</span></span><span style=display:flex><span>          }
</span></span><span style=display:flex><span>        })
</span></span><span style=display:flex><span>        .Schedule(inputDeps);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>잘 동작하네요! 값이 쭉쭉 올라가고 있어요.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/10.png></p></li></ul><h2 id=팁들>팁들</h2><h3 id=internalbuffercapacityattributeinternalbuffercapacityattribute><a href=https://docs.unity3d.com/Packages/com.unity.entities@0.10/api/Unity.Entities.InternalBufferCapacityAttribute.html><code>InternalBufferCapacityAttribute</code></a></h3><p>엔티티는 기본적으로 청크에 포함되는데, <code>IBufferElementData</code>를 구현하는 구조체에 <code>InternalBufferCapacityAttribute</code>를 적용하면 청크 내 존재할 수 있는 최대 요소 수를 지정할 수 있어요. 지정한 요소 수를 넘어서면 해당 버퍼는 힙 메모리로 이동해요. 물론 이때에도 이전과 같이 <code>DynamicBuffer</code> API로 해당 버퍼에 접근할 수 있어요.</p><ul><li><p>요소 수를 2개로 설정해 봤어요.</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#888>// InternalBufferCapacity specifies how many elements a buffer can have before</span>
</span></span><span style=display:flex><span><span style=color:#888>// the buffer storage is moved outside the chunk.</span>
</span></span><span style=display:flex><span><span style=color:#369>[InternalBufferCapacity(2)]</span>
</span></span><span style=display:flex><span><span style=color:#369>[GenerateAuthoringComponent]</span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>IntBufferElement</span> : IBufferElementData
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#888;font-weight:700>int</span> Value;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li><li><p>그리고 같은 청크에서 테스트하기 위해서 <code>EnemyTag</code>를 포함하는 Enemy 게임 오브젝트를 두 개 더 복재했어요.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/11.png></p></li><li><p><em>Entity Debugger</em>를 확인해 봤어요. 그런데 <code>IntBufferElement</code>가 여전히 청크에 남아 있는 것 처럼 보이네요. 힙 메모리로 이동됐어도 편의를 위해서 이렇게 보여주는 것인지는 확인이 필요하겠어요.</p><p><img src=/1/01/unity-dots-start-to-use-dynamic-buffer/images/12.png></p></li></ul><h3 id=implicit-연산자><code>implicit</code> 연산자</h3><p>편의를 위해서 이렇게 작성해서 사용할 수도 있겠죠?</p><div class=highlight><pre tabindex=0 style=background-color:#fff><code class=language-cs data-lang=cs><span style=display:flex><span><span style=color:#080;font-weight:700>using</span> <span style=color:#b06;font-weight:700>Unity.Entities</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#080;font-weight:700>namespace</span> <span style=color:#b06;font-weight:700>DOTS_DynamicBuffer</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#888>// InternalBufferCapacity specifies how many elements a buffer can have before</span>
</span></span><span style=display:flex><span>  <span style=color:#888>// the buffer storage is moved outside the chunk.</span>
</span></span><span style=display:flex><span><span style=color:#369>  [InternalBufferCapacity(2)]</span>
</span></span><span style=display:flex><span><span style=color:#369>  [GenerateAuthoringComponent]</span>
</span></span><span style=display:flex><span>  <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>struct</span> <span style=color:#b06;font-weight:700>IntBufferElement</span> : IBufferElementData
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>public</span> <span style=color:#888;font-weight:700>int</span> Value;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#888>// The following implicit conversions are optional, but can be convenient.</span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#080;font-weight:700>implicit</span> <span style=color:#080;font-weight:700>operator</span> <span style=color:#888;font-weight:700>int</span>(IntBufferElement e)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>return</span> e.Value;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#080;font-weight:700>public</span> <span style=color:#080;font-weight:700>static</span> <span style=color:#080;font-weight:700>implicit</span> <span style=color:#080;font-weight:700>operator</span> IntBufferElement(<span style=color:#888;font-weight:700>int</span> e)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      <span style=color:#080;font-weight:700>return</span> <span style=color:#080;font-weight:700>new</span> IntBufferElement { Value = e };
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=마치며>마치며</h2><p><code>IBufferElementData</code>와 <code>DynamicBuffer&lt;T></code>를 가볍게 알아 봤어요.</p><p>게임을 만들 때 오브젝트 풀링에 대해서 수도 없이 많이 들어 보셨을 거예요. 1회용 객체를 생성하는 것은 쓰레기를 만드는 것이기에 풀링해서 재사용하면 잦은 <a href=https://ko.wikipedia.org/wiki/%EC%93%B0%EB%A0%88%EA%B8%B0_%EC%88%98%EC%A7%91_(%EC%BB%B4%ED%93%A8%ED%84%B0_%EA%B3%BC%ED%95%99)>쓰레기 수집</a>을 줄이고 인스턴스 생성 타이밍을 관리할 수 있어서 더욱 부드러운 게임을 만들 수 있죠.</p><p>다음에는 이 기능을 게임에 어떻게 적용하는지 알아보고, 적용하기 전과 후를 비교하면서 어느정도 효과를 얻을 수 있는지 확인해 볼게요.</p></article><script>(function(){if(!location.hash.match(/^#/))return;var t,n,s,a,o=document.getElementById("content"),r=window.decodeURIComponent(location.hash.substring(1)),i=document.getElementById(r),e=i.nodeName.match(/^H([123456])$/);if(!e||i.parentNode!==o)return;for(a=window.parseInt(e[1]),t=!1,s=0;s<o.childNodes.length;s++)n=o.childNodes[s],t?(e=n.nodeName.match(/^H([123456])$/),e&&window.parseInt(e[1])>=a&&(t=!1)):n===i&&(t=!0),!t&&!n.nodeName.match(/^#/)&&(n.className+=" dim")})()</script><div class=recruit><a href=https://planetariumhq.com>플라네타리움</a>은 게임에 특화된
오픈 소스 P2P 라이브러리 <a href=https://libplanet.io/>Libplanet</a>과,
그 위에서 중앙 서버 없는 온라인 게임
〈<a href=https://nine-chronicles.com/>나인 크로니클</a>〉을 만들고
있습니다. 저희와 흥미로운 기술적 도전을 함께 하실 분들을 모시고 있습니다.
지금 <a href=https://recruit.planetariumhq.com/>인재 영입 페이지</a>를
확인해주세요!</div><div itemprop=author class="fl tc mr3"><a href=https://github.com/boscohyun rel=author itemprop=url class="no-underline mid-gray b f6"><img src="https://www.gravatar.com/avatar/c34d881a6bfa3ddba681523b2b732607?d=https://avatars.githubusercontent.com/boscohyun" itemprop=image class="w3 h3 br-100 mb1"><br>현승민</a></div></section><footer><div><p class="f6 gray mt6 lh-copy">&copy; 2019&ndash;2023
<a href=https://planetariumlabs.com/ style=color:inherit;text-decoration:inherit>Planetarium</a>.</p></div></footer></body></html>